{"questions":[{"id":"100","name":" Same Tree","language":"java","code":"class Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null \u0026\u0026 q == null)\n            return true;\n​\n        if (p == null || q == null)\n            return false;\n​\n        return p.val == q.val \u0026\u0026 isSameTree(p.left, q.left) \u0026\u0026 isSameTree(p.right, q.right);\n    }\n}\n"},{"id":"1","name":" Two Sum","language":"java","code":"class Solution {\n    public int[] twoSum(int[] nums, int target) {\n    Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e();\n    for (int i = 0; i \u003c nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[] { map.get(complement), i };\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n}\n"},{"id":"1095","name":" Find in Mountain Array","language":"java","code":"/**\n * // This is MountainArray's API interface.\n * // You should not implement it, or speculate about its implementation\n * interface MountainArray {\n *     public int get(int index) {}\n *     public int length() {}\n * }\n */\n \nclass Solution {\n  int findInMountainArray(int target, MountainArray A) {\n        int n = A.length(), l, r, m, peak = 0;\n        // find index of peak\n        l  = 0;\n        r = n - 1;\n        while (l \u003c r) {\n            m = (l + r) / 2;\n            if (A.get(m) \u003c A.get(m + 1))\n                l = peak = m + 1;\n            else\n                r = m;\n        }\n        // find target in the left of peak\n        l = 0;\n        r = peak;\n        while (l \u003c= r) {\n            m = (l + r) / 2;\n            if (A.get(m) \u003c target)\n                l = m + 1;\n            else if (A.get(m) \u003e target)\n                r = m - 1;\n            else\n                return m;\n        }\n        // find target in the right of peak\n        l = peak;\n        r = n - 1;\n        while (l \u003c= r) {\n            m = (l + r) / 2;\n            if (A.get(m) \u003e target)\n                l = m + 1;\n            else if (A.get(m) \u003c target)\n                r = m - 1;\n            else\n                return m;\n        }\n        return -1;\n    }\n}\n"},{"id":"1354","name":" Construct Target Array With Multiple Sums","language":"java","code":"class Solution {\n    public boolean isPossible(int[] target) {\n        while (isAllElementsAreOne(target) == false) {\n            int[] maxEle = getMaxElement(target); // [idx, el]\n            int subtract = subtractFromAllElements(target, maxEle);\n            if (subtract \u003c 1)\n                return false;\n            target[maxEle[0]] = 1;\n        }\n        return true;\n    }\n​\n    private int subtractFromAllElements(int[] target, int[] max) {\n        // TODO Auto-generated method stub\n        int sub = max[1];\n        for (int i = 0; i \u003c target.length; i++) {\n            if (max[0] != i) sub -= target[i];\n        }\n        return sub;\n    }\n​\n    private int[] getMaxElement(int[] target) {\n        // TODO Auto-generated method stub\n        int max = Integer.MIN_VALUE;\n        int id = -1;\n        for (int i = 0; i \u003c target.length; i++) {\n            if (max \u003c target[i]) {\n                max = target[i];\n                id = i;\n            }\n        }\n        return new int[] { id, max };\n    }\n​\n    private boolean isAllElementsAreOne(int[] target) {\n        // TODO Auto-generated method stub\n        for (int x : target) {\n            if (x != 1)\n                return false;\n        }\n        return true;\n    }\n    \n}\n"},{"id":"563","name":" Binary Tree Tilt","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int overall_tilt = 0;\n    public int findTilt(TreeNode root) {\n        _findTilt(root);\n        return this.overall_tilt;\n    }\n    public int _findTilt(TreeNode root) {\n        if (root == null)\n            return 0;\n        \n        // faith\n        int left_sum = this._findTilt(root.left);\n        int right_sum = this._findTilt(root.right);\n        \n        int mysum = root.val + left_sum + right_sum;\n        this.overall_tilt += Math.abs(left_sum - right_sum);\n        \n        return mysum;\n    }\n}\n"},{"id":"1008","name":" Construct Binary Search Tree from Preorder Traversal","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int curindx = 0;\n    public TreeNode bstFromPreorder(int[] preorder) {\n        return _bst_construct(preorder, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n    \n​\n    private TreeNode _bst_construct(int[] preorder, int minValue, int maxValue) {\n​\n        if (curindx \u003e= preorder.length ||\n                preorder[curindx] \u003e maxValue || preorder[curindx] \u003c minValue) return null;\n​\n        TreeNode node = new TreeNode(preorder[curindx++]);\n​\n        node.left = _bst_construct(preorder, minValue, node.val);\n        node.right = _bst_construct(preorder, node.val, maxValue);\n​\n        return node;\n    }\n}\n"},{"id":"No companies found for this problem2518","name":" Number of Great Partitions","language":"java","code":"class Solution {\n    private int MOD=1000000007;\n    Map\u003cString, Integer\u003e cache=new HashMap\u003c\u003e();\n    \n    public int countPartitions(int[] nums, int k) {\n        /**\n        this clealy seems to be a subsequence sort-of problem\n        you can pick / un-pick\n        \n        f(i) --\u003e f(i+1, sum + arr[i])\n        **/\n        \n        if (tsum(nums) / 2 \u003c k) return 0;\n        \n        int wrongPartitions=exploreAllPartitions(nums,0,k,0);\n        int totalPartitions=(int) (Math.pow(2, nums.length) % MOD); \n        \n        int goodPartitions=(totalPartitions-2*wrongPartitions) + MOD;\n        \n        \n        return goodPartitions % MOD;\n    }\n    \n    public int exploreAllPartitions(int[] nums, int currIndex, int k, int sum) {\n        // do the subsequecing....\n        \n        if (currIndex \u003e= nums.length) {\n            return sum \u003c k ? 1 : 0;\n        }\n        \n        String key=currIndex + \"#\" + sum;\n        if (cache.containsKey(key)) return cache.get(key);\n        \n        // pick\n        int p1=0; int p2=0;\n        if (sum + nums[currIndex] \u003c k) {\n            p1=exploreAllPartitions(nums,currIndex+1,k,sum+nums[currIndex]) % MOD;\n        }\n        // un pick\n        p2=exploreAllPartitions(nums, currIndex+1,k,sum) % MOD;\n        \n        cache.put(key,  (p1+p2) % MOD);\n        return cache.get(key);\n    }\n    \n    private int tsum(int[] arr) {\n        int x=0;\n        for (int xx : arr) x = (x + (xx % MOD) ) % MOD;\n        return x % MOD;\n    }\n}\n"},{"id":"101","name":" Symmetric Tree","language":"cpp","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if(root == NULL){\n            return true;\n        }\n        return f(root-\u003eleft, root-\u003eright);\n    }\n    bool f(TreeNode* left, TreeNode* right){\n        if(left == NULL or right == NULL){\n            return left == right;\n        }\n        if(left-\u003eval != right-\u003eval){\n            return false;\n        }\n        return f(left-\u003eleft, right-\u003eright) \u0026\u0026 f(left-\u003eright, right-\u003eleft);\n    }\n};\n"},{"id":"1639","name":" Number of Ways to Form a Target String Given a Dictionary","language":"java","code":"// https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/\nclass Solution {\n    Map\u003cString, Integer\u003e memoMap = new HashMap\u003c\u003e();\n    int MOD=(int) (1e9+7);\n​\n    public int numWays(String[] words, String target) {\n        int max_characters = 26;\n        int max_length = words[0].length();\n        int[][] frequencyTable = new int[max_characters][max_length];\n        for (int index = 0; index \u003c max_length; index++) {\n            for (String word : words) {\n                char character = word.charAt(index);\n                int characterIndex = character - 'a';\n                frequencyTable[characterIndex][index]++;\n            }\n        }\n        for (int[] row : frequencyTable)\n            System.out.println(Arrays.toString(row));\n        return solve(target, 0, 0, frequencyTable);\n    }\n​\n    private int solve(String target, int wordIndex, int targetIndex, int[][] frequencyTable) {\n        if (targetIndex == target.length())\n            return 1;\n        if (wordIndex == frequencyTable[0].length)\n            return 0;\n​\n        if (memoMap.containsKey(targetIndex + \"@\" + wordIndex))\n            return memoMap.get(targetIndex + \"@\" + wordIndex);\n​\n        int notTaken = solve(target, wordIndex + 1, targetIndex, frequencyTable);\n        int frequencyTimes = frequencyTable[target.charAt(targetIndex) - 'a'][wordIndex];\n        int taken = (solve(target, wordIndex + 1, targetIndex + 1, frequencyTable) * frequencyTimes)%MOD;\n​\n        int totalWays = (notTaken + taken) % MOD;\n        memoMap.put(targetIndex + \"@\" + wordIndex, totalWays);\n        return totalWays;\n    }\n}\n"},{"id":"1015","name":" Smallest Integer Divisible by K","language":"cpp","code":"class Solution {\npublic:\n    int smallestRepunitDivByK(int k) {\n         if(k%2 == 0 || k%5 == 0)\n        {\n            return -1;\n        }\n​\n        int prevRem = 0;\n        for(int i = 1; i \u003c=k; i++)\n        {\n            prevRem = (prevRem*10+1)%k;\n            if(prevRem==0)\n            {\n                return i;\n            }\n        }\n        return -1; \n    }\n};\n"},{"id":"1641","name":" Count Sorted Vowel Strings","language":"cpp","code":"class Solution {\n    string vowels = \"aeiou\";\npublic:\n    int easyMathSolution(int n) {\n        return ((n+4)*(n+3)*(n+2)*(n)) / 24\n    }\n    int countVowelStrings(int n) {\n        int ans = 0;\n        for (char x : vowels ) {\n            ans += dfs(x, n-1);\n        }\n        return ans;\n    }\n    int dfs(char lastvowel, int n) {\n        if (n==0) {\n            return 1;\n        }\n        int ans=0;\n        for (char vowel : vowels) {\n            if (vowel \u003e= lastvowel) \n                ans+=dfs(vowel, n-1);\n        }\n        return ans;\n    }\n};\n"},{"id":"11","name":" Container With Most Water","language":"cpp","code":"class Solution {\npublic:\n    #define fo(i, k, n) for(int i = k; i \u003c n; i++)\n    const int inf = 0x3f3f3f3f;\n    \n    int maxArea(vector\u003cint\u003e\u0026 nums) {\n        \n        /*\n            O(N*N)solutions:\n            \n            for(i,0,n){\n                for(j,i+1,n){\n                    minn = min(height[i], height[j]);\n                    maxv = max(maxv, minn*(j-i));\n                }\n            }\n            return maxv;\n        */\n        \n        int n = nums.size();\n        int maxv = -1 * inf;\n        int i = 0, j = n-1;\n        while(i \u003c j) {\n            int minn = min(nums[i], nums[j]);\n            maxv = max(maxv, minn*(j-i));\n            if(nums[i]\u003cnums[j]) {\n                i++;\n            } else {\n                j--;\n            }\n       }\n       return maxv;\n    }\n};\n"},{"id":"164","name":" Maximum Gap","language":"java","code":"class Solution {\n public int maximumGap(int[] nums) {\n    \n      if(nums.length\u003c2)return 0;\n      int min = nums[0] , max = 0;\n    \n      for(int num : nums){\n          min = Math.min(min,num);\n          max = Math.max(max,num);\n      }\n      \n      int interval = (int)Math.ceil((max-min+0.0)/(nums.length-1));\n    \n      int[] bucketMin = new int[nums.length-1];\n      int[] bucketMax = new int[nums.length-1];\n      \n      Arrays.fill(bucketMin,Integer.MAX_VALUE);\n      Arrays.fill(bucketMax,-1);\n      \n      for(int i=0;i\u003cnums.length;i++){\n          if(nums[i]==min || nums[i]==max)continue;\n          \n          int index = (nums[i]-min)/interval;\n          bucketMin[index] = Math.min(bucketMin[index],nums[i]);\n          bucketMax[index] = Math.max(bucketMax[index],nums[i]);\n      }\n        \n      int prev = min;\n      int maxGap = 0;\n      for(int i=0;i\u003cbucketMin.length;i++){\n          if(bucketMax[i]==-1)continue;\n          maxGap = Math.max(bucketMin[i]-prev,maxGap);\n          prev = bucketMax[i];\n      }\n      maxGap = Math.max(max-prev,maxGap);\n      \n      return maxGap;\n    }\n}\n"},{"id":"102","name":" Binary Tree Level Order Traversal","language":"js","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrder = function (root) {\n  let result = [];\n​\n   function dfs (root, level) {\n        if (!root) return;\n​\n        dfs(root.left, level + 1);\n​\n        if (result[level]) {\n          result[level].push(root.val);\n        } else {\n          result[level] = [root.val];\n        }\n​\n        dfs(root.right, level + 1);\n    };\n      dfs(root, 0);\n      return result;\n};\n​\n"},{"id":"136","name":" Single Number","language":"cpp","code":"class Solution {\npublic:\n    int singleNumber(vector\u003cint\u003e\u0026 nums) {\n        int xr = 0;\n        for(auto \u0026\u0026 x : nums ){\n            xr = xr ^ x;\n        }\n        return xr;\n    }\n};\n"},{"id":"1646","name":" Get Maximum in Generated Array","language":"cpp","code":"class Solution {\n    vector\u003cint\u003e nums;\npublic:\n    int getMaximumGenerated(int n) {\n        if(n \u003c 2) {\n            return n;\n        }\n        nums.resize(n+1);\n        nums[1] = 1;\n        \n        for (int i = 2; i \u003c= n; i++) {\n            if(i\u00261) {\n                nums[i] = nums[i/2]+nums[(i/2)+1];\n            }\n            else {\n                nums[i] = nums[i/2];\n            }\n        }\n     \n        return *max_element(nums.begin(), nums.end());\n    }\n};\n"},{"id":"1020","name":" Number of Enclaves","language":"java","code":"class Solution {\n    private boolean isWater(int val) {\n        return val == 0;\n    }\n\n    public int numEnclaves(int[][] grid) {\n        int R = grid.length;\n        int C = grid[0].length;\n        int enclaves = 0;\n\n        // search for the boundary cells that has land==1\n\n        // LEFT BOUNDARY \u0026 RIGHT BOUNDARY\n        for (int row = 0; row \u003c R; row++) {\n            // only 1st and last col check for land\n            if (!isWater(grid[row][0]))\n                checkIfFormsAnIsland(grid, row, 0);\n            if (!isWater(grid[row][C - 1]))\n                checkIfFormsAnIsland(grid, row, C - 1);\n        }\n\n        // TOP BOUNDARY \u0026 BOTTOM BOUNDARY\n        for (int col = 0; col \u003c R; col++) {\n            // only 1st and last col check for land\n            if (!isWater(grid[0][col]))\n                checkIfFormsAnIsland(grid, 0, col);\n            if (!isWater(grid[R - 1][col]))\n                checkIfFormsAnIsland(grid, R - 1, col);\n        }\n\n        // now only count for no. of 1s\n        for (int row = 1; row \u003c R; row++) {\n            for (int col = 1; col \u003c C; col++)\n                if (!isWater(grid[row][col]))\n                    enclaves++;\n        }\n        return enclaves;\n\n    }\n\n    private void checkIfFormsAnIsland(int[][] grid, int row, int col) {\n        int R = grid.length;\n        int C = grid[0].length;\n\n        int[] dx = new int[] { 0, -1, 0, 1 };\n        int[] dy = new int[] { -1, 0, 1, 0 };\n\n        grid[row][col] = 0;\n\n        for (int k = 0; k \u003c dx.length; k++) {\n            int nrow = row + dx[k];\n            int ncol = col + dy[k];\n            if (nrow \u003e= 0 \u0026\u0026 ncol \u003e= 0 \u0026\u0026 nrow \u003c R \u0026\u0026 ncol \u003c C \u0026\u0026 !isWater(grid[nrow][ncol])) {\n                checkIfFormsAnIsland(grid, nrow, ncol);\n            }\n        }\n    }\n}\n"},{"id":"11","name":" Container With Most Water","language":"java","code":"class Solution {\n    public int maxArea(int[] height) {\n        return mostWater(height);\n    }\n    public int mostWater(int[] heights) {\n        // write your code here\n        int maxwater = 0;\n​\n        int i = 0;\n        int j = heights.length-1;\n​\n        while (i \u003c j) {\n            int l = j - i;\n            int h = Math.min( heights[i], heights[j] );\n            int water = l * h;\n​\n            maxwater = Math.max(maxwater, water);\n​\n            if (heights[i] \u003c heights[j]) {\n                i++;\n            } else {\n                j--;\n            }\n        }\n​\n        return maxwater;\n    }\n​\n}\n"},{"id":"572","name":" Subtree of Another Tree","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n        boolean status = false;\n​\n        if (root == null) {\n            return false; // base case\n        }\n        if (root.val == subRoot.val) {\n            if (isSameTree(root, subRoot)) {\n                return true;\n            }\n        }\n        status = isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n        return status;\n    }\n​\n    private boolean isSameTree(TreeNode root, TreeNode subRoot) {\n        if (root == null \u0026\u0026 subRoot == null) {\n            return true;\n        }\n        if (root == null || subRoot == null) {\n            return false;\n        }\n        return root.val == subRoot.val \u0026\u0026 isSameTree(root.left, subRoot.left) \u0026\u0026 isSameTree(root.right, subRoot.right);\n    }\n​\n}\n"},{"id":"1026","name":" Maximum Difference Between Node and Ancestor","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxAncestorDiff(TreeNode root) {\n        return _solver(root, root.val, root.val);\n    }\n​\n    private int _solver(TreeNode root, int low, int high) {\n        // TODO Auto-generated method stub\n        if (root == null) {\n            return Math.abs(high - low);\n        }\n​\n        low = Math.min(low, root.val);\n        high = Math.max(high, root.val);\n        int a1 = _solver(root.left, low, high);\n        int a2 = _solver(root.right, low, high);\n​\n        return Math.max(a1, a2);\n    }\n​\n    public int maxAncestorDiff2(TreeNode root) {\n        if (root == null)\n            return 0;\n​\n        int maxdiff1 = helper(root.left, root.val);\n        int maxdiff2 = helper(root.right, root.val);\n​\n        int ma = Math.max(maxAncestorDiff2(root.left), maxAncestorDiff2(root.right));\n​\n        return Math.max(ma, Math.max(maxdiff1, maxdiff2));\n    }\n​\n    private int helper(TreeNode root, int a) {\n        // TODO Auto-generated method stub\n        if (root == null)\n            return 0;\n​\n        int diff1 = helper(root.left, a);\n        int diff2 = helper(root.right, a);\n        int mydiff = Math.abs(root.val - a);\n        return Math.max(mydiff, Math.max(diff1, diff2));\n    }\n}\n​\n"},{"id":"1710","name":" Maximum Units on a Truck","language":"java","code":"class Solution {\n    // TC: O(NLogN)\n    // SPACE: O(N) ~ O(1) also done; I just used typed. class definations.\n    class BoxType {\n        int totalBoxes;\n        int unitsPerBox;\n​\n        public BoxType(int totlaBoxes, int unitPerbox) {\n            // TODO Auto-generated constructor stub\n            this.totalBoxes = totlaBoxes;\n            this.unitsPerBox = unitPerbox;\n        }\n​\n        @Override\n        public String toString() {\n            return \"BoxType [totalBoxes=\" + totalBoxes + \", unitsPerBox=\" + unitsPerBox + \"]\";\n        }\n​\n    }\n​\n    public int maximumUnits(int[][] boxTypes, int truckSize) {\n        ArrayList\u003cBoxType\u003e boxes = new ArrayList\u003c\u003e();\n        for (int[] boxtype : boxTypes)\n            boxes.add(new BoxType(boxtype[0], boxtype[1]));\n​\n        Collections.sort(boxes, new Comparator\u003cBoxType\u003e() {\n            @Override\n            // SORT BY DESC\n            public int compare(BoxType o1, BoxType o2) {\n                // TODO Auto-generated method stub\n                return o2.unitsPerBox - o1.unitsPerBox;\n            }\n        });\n​\n        int totalUnits = 0;\n        int curIndex = 0;\n        while (truckSize \u003e= 0 \u0026\u0026 curIndex \u003c boxes.size()) {\n            BoxType curBox = boxes.get(curIndex);\n            if (curBox.totalBoxes \u003c= truckSize) {\n                truckSize -= curBox.totalBoxes;\n                totalUnits += (curBox.unitsPerBox * curBox.totalBoxes);\n            } else {\n                totalUnits += (curBox.unitsPerBox * truckSize);\n                truckSize = 0;\n            }\n            System.out.println(curBox);\n            System.out.println(\"TS: \" + truckSize + \" , unit: \" + totalUnits);\n            curIndex++;\n        }\n​\n        return totalUnits;\n​\n    }\n}\n​\n"},{"id":"347","name":" Top K Frequent Elements","language":"java","code":"class Solution {\n    private class FrequencyPair {\n        int frequency;\n        int data;\n​\n        public FrequencyPair(int frequency, int data) {\n            this.frequency = frequency;\n            this.data = data;\n        }\n    }\n    public int[] topKFrequent(int[] nums, int k) {\n        HashMap\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e();\n        for (int elem : nums)\n            map.put(elem, map.getOrDefault(elem,0) + 1);\n​\n        PriorityQueue\u003cFrequencyPair\u003e heap = new PriorityQueue\u003c\u003e((a, b) -\u003e a.frequency - b.frequency);\n        for (int key : map.keySet()) {\n            heap.offer(createFrequencyPair(map, key));\n            if (heap.size() \u003e k)\n                heap.poll();\n        }\n​\n        int[] result = new int[k];\n        int counter = 0;\n        while (!heap.isEmpty()){\n            counter = pushDataIntoResult(heap, result, counter);\n        }\n        return result;\n    }\n​\n    private int pushDataIntoResult(PriorityQueue\u003cFrequencyPair\u003e heap, int[] result, int counter) {\n        result[counter] = heap.poll().data;\n        counter++;\n        return counter;\n    }\n​\n    private FrequencyPair createFrequencyPair(HashMap\u003cInteger, Integer\u003e map, int key) {\n        return new FrequencyPair(map.get(key), key);\n    }\n}\n"},{"id":"1657","name":" Determine if Two Strings Are Close","language":"java","code":"class Solution {\n    public boolean closeStrings(String word1, String word2) {\n        Map\u003cCharacter, Integer\u003e map1 = buildFrequencyMap(word1);\n        Map\u003cCharacter, Integer\u003e map2 = buildFrequencyMap(word2);\n​\n        if (map1.equals(map2))\n            return true;\n        return canBeMapped(map1, map2) ? true : false;\n    }\n​\n    private boolean canBeMapped(Map\u003cCharacter, Integer\u003e map1, Map\u003cCharacter, Integer\u003e map2) {\n        if (!map1.keySet().equals(map2.keySet()))\n            return false;\n​\n        Map\u003cInteger, List\u003cCharacter\u003e\u003e reverseMap1 = buildReverseMap(map1);\n        Map\u003cInteger, List\u003cCharacter\u003e\u003e reverseMap2 = buildReverseMap(map2);\n​\n        for (Map.Entry\u003cInteger, List\u003cCharacter\u003e\u003e kv : reverseMap1.entrySet()) {\n            List\u003cCharacter\u003e set1 = kv.getValue();\n            List\u003cCharacter\u003e set2 = reverseMap2.get(kv.getKey());\n            if (set2 == null || set1.size() != set2.size())\n                return false;\n        }\n​\n        return true;\n    }\n​\n    private Map\u003cInteger, List\u003cCharacter\u003e\u003e buildReverseMap(Map\u003cCharacter, Integer\u003e map1) {\n        Map\u003cInteger, List\u003cCharacter\u003e\u003e rmap = new HashMap\u003c\u003e();\n        for (Map.Entry\u003cCharacter, Integer\u003e kv : map1.entrySet()) {\n            rmap.putIfAbsent(kv.getValue(), new ArrayList\u003c\u003e());\n            rmap.get(kv.getValue()).add(kv.getKey());\n        }\n        return rmap;\n    }\n​\n    private Map\u003cCharacter, Integer\u003e buildFrequencyMap(String word1) {\n        Map\u003cCharacter, Integer\u003e map = new HashMap\u003c\u003e();\n        for (char c : word1.toCharArray()) {\n            map.put(c, map.getOrDefault(c, 0) + 1);\n        }\n        return map;\n    }\n}\n"},{"id":"137","name":" Single Number II","language":"cpp","code":"class Solution {\npublic:\n    int singleNumber(vector\u003cint\u003e\u0026 nums) {\n        // map\u003cint, int\u003e cache;\n        // for(auto \u0026\u0026x : nums){cache[x]++ ;}\n        // for(auto \u0026\u0026p : cache) {\n        //     if(p.second == 1){\n        //         return p.first;\n        //     }\n        // }\n        // return -1;\n        \n        int seen1 = 0,seen2 = 0;\n        for(auto \u0026\u0026x : nums) {\n            seen1 = ~seen2 \u0026 (seen1 ^ x);\n            seen2 = ~seen1 \u0026 (seen2 ^ x);\n        }\n        return seen1;\n    }\n};\n"},{"id":"1029","name":" Two City Scheduling","language":"java","code":"public class TwoCityScheduler {\n    class CityCost {\n        int person;\n        int costForA;\n        int costForB;\n​\n        public CityCost(int person, int costForA, int costForB) {\n            super();\n            this.person = person;\n            this.costForA = costForA;\n            this.costForB = costForB;\n        }\n​\n        @Override\n        public String toString() {\n            return \"CityCost [person=\" + person + \", costForA=\" + costForA + \", costForB=\" + costForB + \"]\";\n        }\n​\n    }\n​\n    public int twoCitySchedCost(int[][] costs) {\n        int n = costs.length;\n        CityCost[] costTrack = new CityCost[n];\n​\n        for (int i = 0; i \u003c n; i++) {\n            int person = i;\n            int costa = costs[i][0];\n            int costb = costs[i][1];\n            costTrack[i] = new CityCost(person, costa, costb);\n        }\n​\n        Arrays.sort(costTrack, new Comparator\u003cCityCost\u003e() {\n            public int compare(CityCost a, CityCost b) {\n                return (a.costForA - a.costForB) - (b.costForA - b.costForB);\n            }\n        });\n​\n        int ans = 0;\n        for (int i = 0; i \u003c n/2; i++) {\n            ans += (costTrack[i].costForA + costTrack[i+(n/2)].costForB);\n        }\n​\n        return ans;\n    }\n}\n​\n"},{"id":"1920","name":" Build Array from Permutation","language":"java","code":"class Solution {\n    public int[] buildArray(int[] nums) {\n        final int n = nums.length;\n        int[] ans = new int [n];\n​\n        int i = 0;\n        for (int index : nums) {\n            ans[i] = nums[index];\n            i++;\n        }\n        \n        return ans;\n    }\n}\n"},{"id":"110","name":" Balanced Binary Tree","language":"js","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\n​\n/*\n    Solution 1 - O(N*N) looks\n    ---------------------------\nvar isBalanced = function(root) {\n    if(!root) {\n        return true ;\n    }\n    \n    function dfs(root) {\n        if (!root) {\n            return 0 ;\n        }\n        return Math.max(dfs(root.left), dfs(root.right)) + 1;\n    }\n    \n    if(Math.abs(dfs(root.left) - dfs(root.right)) \u003e 1) {\n        return false;\n    }\n    \n    return isBalanced(root.left) \u0026\u0026 isBalanced(root.right);\n};\n*/\n​\nvar isBalanced = function(root) {\n    if(!root) {\n        return true ;\n    }\n    \n    function dfs(root) {\n        if (!root) {\n            return 0 ;\n        }\n        \n        leftHeight = dfs(root.left);\n        rightHeight = dfs(root.right);\n        balanceFactor = Math.abs (leftHeight - rightHeight);\n        \n        if (balanceFactor \u003e 1 || leftHeight == -1 || rightHeight == -1) {return -1;}\n        \n        return 1 + Math.max(leftHeight, rightHeight) ;\n    }\n    \n   return dfs(root) != -1;\n};\n"},{"id":"576","name":" Out of Boundary Paths","language":"java","code":"class Solution {\n    private Long[][][] dp;\n    private int[] dx = new int[] {1,-1,0,0};\n    private int[] dy = new int[] {0,0,-1,1};\n    private int mod = 1000000007;\n    \n    public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n        dp = new Long[m+1][n+1][maxMove+1];\n        return (int) _findPaths(m, n, maxMove, startRow, startColumn);\n    }\n    \n    private long _findPaths(int m, int n, int maxMove, int startRow, int startColumn) {\n        // TODO Auto-generated method stub\n​\n        if (maxMove \u003c 0)\n            return 0;\n​\n        if (startRow == m || startColumn == n || startRow == -1 || startColumn == -1)\n            return 1;\n        \n        if (dp[startRow][startColumn][maxMove] != null)\n            return dp[startRow][startColumn][maxMove];\n        \n        long myways = 0;\n        \n        for(int k = 0; k \u003c 4; k++) {\n            long c = _findPaths(m, n, maxMove-1, startRow + dx[k], startColumn + dy[k]);\n            myways = (myways + c) % mod;\n        }\n        \n        dp[startRow][startColumn][maxMove] = myways;\n        return myways;\n    }\n​\n}\n"},{"id":"103","name":" Binary Tree Zigzag Level Order Traversal","language":"js","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar zigzagLevelOrder = function(root) {\n     let result = [];\n​\n    const loot = (root, level) =\u003e {\n        if(!root) {return ; }\n        \n        if(result[level]){\n            result[level].push(root.val);\n        } else {\n            result[level] = [root.val] ;\n        }\n​\n        loot(root.left, level+1);\n        loot(root.right, level+1);\n    } \n    loot(root, 0);\n​\n    results = result.map((arr, index) =\u003e {\n        (index%2 === 1) ? arr.reverse() : arr;\n    });\n​\n    return result; \n};\n"},{"id":"138","name":" Copy List with Random Pointer","language":"cpp","code":"/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n​\nclass Solution {\npublic:\n   Node* copyRandomList(Node* head) {\n   unordered_map\u003cNode*, Node*\u003e cache;\n    Node* r = head;\n    while(r) {\n        cache[r] = new Node(r-\u003eval);\n        r = r-\u003enext ;\n    }\n    r = head;\n    while(r){\n        cache[r]-\u003enext = cache[r-\u003enext];\n        cache[r]-\u003erandom = cache[r-\u003erandom];\n        r = r -\u003e next;\n    }\n    return cache[head];\n    }\n};\n"},{"id":"172","name":" Factorial Trailing Zeroes","language":"py","code":"import math\n​\nclass Solution:\n    def trailingZeroes(self, n: int) -\u003e int:\n        if n \u003c 5:\n            return 0\n        ans = 0\n        while n \u003e 4:\n            ans+=int(n/5)\n            n = n / 5\n            \n        return ans\n"},{"id":"1658","name":" Minimum Operations to Reduce X to Zero","language":"cpp","code":"class Solution {\n    const int inf = 2e9+88;\npublic:\n    int minOperations(vector\u003cint\u003e\u0026 nums, int x) {\n       int sum = -x;\n       for (int z : nums)\n            sum += z;\n       if(sum==0){\n           return (int) nums.size();\n       }\n        if (sum \u003c 0)\n            return -1;\n        int ans = -1, pref = 0, lo=0;\n        for (int i = 0; i \u003c (int) nums.size(); i++) {\n            pref+=nums[i];\n            while (pref \u003e sum) {\n                pref = pref - nums[lo++];\n            }\n            if (pref == sum) {\n                // got ans\n                ans = max(ans, i - lo + 1);\n            }\n        }\n        return ans==-1 ? -1 : (int) nums.size() - ans;\n    }\n};\n"},{"id":"1110","name":" Delete Nodes And Return Forest","language":"java","code":"class Solution {\n    public List\u003cTreeNode\u003e delNodes(TreeNode root, int[] to_delete) {\n        Set\u003cInteger\u003e deleteSet = new HashSet\u003c\u003e();\n        for (int node : to_delete)\n            deleteSet.add(node);\n        List\u003cTreeNode\u003e forestNodes = new ArrayList\u003c\u003e();\n        TreeNode somenode = solve(root, deleteSet, forestNodes);\n        if (somenode != null)\n            forestNodes.add(root);\n        return forestNodes;\n    }\n​\n    private TreeNode solve(TreeNode root, Set\u003cInteger\u003e deleteSet, List\u003cTreeNode\u003e forestNodes) {\n        // TODO Auto-generated method stub\n        if (root == null)\n            return null;\n​\n        root.left = solve(root.left, deleteSet, forestNodes);\n        root.right = solve(root.right, deleteSet, forestNodes);\n​\n        if (deleteSet.contains(root.val)) {\n            if (root.left != null) {\n                forestNodes.add(root.left);\n            }\n            if (root.right != null) {\n                forestNodes.add(root.right);\n            }\n            return null;\n        }\n​\n        return root;\n    }\n}\n​\n"},{"id":"350","name":" Intersection of Two Arrays II","language":"cpp","code":"class Solution {\npublic:\n    vector\u003cint\u003e intersect(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2) {\n       vector\u003cint\u003e ans;\n        map\u003cint, int\u003e cache;\n        for(auto \u0026\u0026 x : nums1){cache[x]++ ;}\n        for(auto \u0026\u0026x  : nums2){\n            if(cache.find(x) != cache.end()){\n                if(cache[x] == 0){continue;}\n                else {ans.push_back(x);}\n                cache[x]--;\n            }\n        }\n        return ans;\n    }\n};\n"},{"id":"1921","name":" Eliminate Maximum Number of Monsters","language":"java","code":"class Solution {\n    public int eliminateMaximum(int[] dist, int[] speed) {\n        final int n = dist.length;\n        \n        double[] times = new double[n];\n        for (int i = 0; i \u003c n; i++) {\n            times[i] = ((1.0 * dist[i]) / (1.0 * speed[i]) );  // t = d / v;\n        }\n​\n        Arrays.sort(times); // asc\n​\n        int tm = 0, killedMonesters = 0;\n        for (double t : times) {\n            if (t \u003c= tm) {\n                return killedMonesters;\n            }\n            killedMonesters++;\n            tm++;\n        }\n        return killedMonesters;\n​\n        // int killedMonesters = 1;\n​\n        // for (int i = 1; i \u003c dist.length; i++) {\n        //     int d = dist[i];\n        //     int s = speed[i];\n            \n        //     int ld = d - s;\n        //     if (ld \u003c 0) {\n        //         return killedMonesters;\n        //     }\n        //     dist[i] = ld;\n        //     killedMonesters++;\n        // }\n​\n        // return killedMonesters;\n    }\n}\n​\n"},{"id":"104","name":" Maximum Depth of Binary Tree","language":"cpp","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == NULL)   {\n            return 0;\n        }\n        return max( maxDepth(root-\u003eleft), maxDepth(root-\u003eright)) + 1 ;\n    }\n};\n"},{"id":"138","name":" Copy List with Random Pointer","language":"java","code":"class Node {\n    int val;\n    Node next;\n    Node random;\n​\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\n​\nclass Solution {\n    public Node copyRandomList(Node head) {\n        // create a duplicate LL\n        Node current = head;\n        \n        while (current != null) {\n            Node nextnode = current.next;\n            Node newnode = new Node(current.val);\n            current.next = newnode;\n            newnode.next = nextnode;\n            current = nextnode;\n        }\n        \n        current = head;\n        // set the random pointers\n        while (current != null) {\n            current.next.random = current.random != null ? current.random.next : null;\n            current = current.next.next;\n        }\n        \n        // connect wisely\n        current = head;\n        Node dummy = new Node(-1);\n        Node temp = dummy;\n        \n        while (current!=null) {\n            temp.next = current.next;\n            temp = current.next;\n            current.next = current.next.next;\n            current = current.next;\n        }\n        return dummy.next;\n    }\n    \n    public Node copyRandomListBruteForce(Node head) {\n        Map\u003cNode, Node\u003e nodeMap = new HashMap\u003c\u003e();\n        Node current = head;\n        while (current!=null) {\n            nodeMap.put(current, new Node(current.val));\n            current = current.next;\n        }\n​\n        current = head;\n        while (current!=null) {\n            Node node = nodeMap.get(current);\n            node.next = nodeMap.get(current.next);\n            node.random = nodeMap.get(current.random);\n            current = current.next;\n        }\n​\n        return nodeMap.get(head);\n    }\n}\n"},{"id":"173","name":" Binary Search Tree Iterator","language":"cpp","code":" *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass BSTIterator {\n    int index = 0;\n    vector\u003cint\u003e nodes;\n    stack \u003cTreeNode*\u003e cache;\npublic:\n    BSTIterator(TreeNode* root) {\n        // inorder(root) ;\n        dfs(root) ;\n    }\n    \n    void dfs(TreeNode* root) {\n       while(root) {\n           cache.push(root) ;\n           root = root -\u003e left ;\n       }\n    }\n    \n    int next() {\n        // return nodes[index++] ;\n        TreeNode* top = cache.top();\n        cache.pop(); // delete from stack\n        dfs(top-\u003e right) ;\n        return top -\u003e val ;\n    }\n    \n    bool hasNext() {\n        // return index \u003c (int) nodes.size( ) ;\n        \n        return !cache.empty();\n    }\n};\n​\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator* obj = new BSTIterator(root);\n * int param_1 = obj-\u003enext();\n * bool param_2 = obj-\u003ehasNext();\n */\n"},{"id":"1048","name":" Longest String Chain","language":"java","code":"class Solution {\n    public int longestStrChain(String[] words) {\n        Arrays.sort(words, new Comparator\u003cString\u003e() {\n            @Override\n            public int compare(String o1, String o2) {\n                return o1.length() - o2.length();\n            }\n        });\n        Map\u003cString,Integer\u003e map=new HashMap\u003c\u003e(); // \u003cword, word_length\u003e\n        int result=0;\n        for (String word : words) {\n            // generate the substrings\n            for (int j = 0; j \u003c word.length(); j++) {\n                String sub_word = word.substring(0, j) + word.substring(j + 1);\n                map.put(word, Math.max(map.getOrDefault(word, 0), map.getOrDefault(sub_word,0) + 1));\n            }\n            result=Math.max(result, map.get(word));\n        }\n        return result;\n    }\n}\n"},{"id":"1662","name":" Check If Two String Arrays are Equivalent","language":"cpp","code":"class Solution {\npublic:\n    bool arrayStringsAreEqual(vector\u003cstring\u003e\u0026 word1, vector\u003cstring\u003e\u0026 word2) {\n        string s = \"\", t = \"\";\n        for (string x : word1)\n            s += x;\n        \n        for (string x : word2)\n            t += x;\n        \n        return s==t; \n    }\n};\n"},{"id":"1122","name":" Relative Sort Array","language":"java","code":"class Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        Map\u003cInteger, Integer\u003e map = new TreeMap\u003cInteger, Integer\u003e();\n        for (int num : arr1) {\n            map.putIfAbsent(num, 0);\n            map.put(num, map.get(num) + 1);\n        }\n​\n        int index = 0;\n        for (int key : arr2) {\n            // if key in map then populate in arr1\n            if (map.containsKey(key)) {\n                // insert the freq x times in arr1\n                int times = map.get(key);\n                while (times \u003e 0) {\n                    arr1[index] = key;\n                    index++;\n                    times--;\n                }\n                map.remove(key);\n            }\n        }\n​\n        for (Map.Entry\u003cInteger, Integer\u003e kv : map.entrySet()) {\n            int key = kv.getKey();\n            int times = kv.getValue();\n            while (times \u003e 0) {\n                arr1[index] = key;\n                index++;\n                times--;\n            }\n        }\n​\n        return arr1;\n    }\n}\n​\n"},{"id":"1383","name":" Maximum Performance of a Team","language":"java","code":"class Solution {\n    public int maxPerformance(int n, int[] speed, int[] efficiency, int k) {\n         int[][] players = new int[n][2];\n            for (int i=0; i\u003cn; i++) {\n                players[i][0] = efficiency[i];\n                players[i][1] = speed[i];\n            }\n            Arrays.sort(players, (p1, p2) -\u003e (p2[0] - p1[0]));\n            PriorityQueue\u003cInteger\u003e q= new PriorityQueue\u003c\u003e(k);\n            long count = 0, s = 0;\n​\n            for (int i=0; i\u003cn; i++) {\n                if (q.size() \u003e= k) {\n                   s -= q.remove();\n                }\n                q.add(players[i][1]);\n                s += players[i][1];\n​\n                count = Math.max(count,s * players[i][0]);\n            }\n            return (int) (count % 1000000007);\n    }\n}\n"},{"id":"583","name":" Delete Operation for Two Strings","language":"java","code":"class Solution {\n    private int[][] memo = new int [600][600];\n    public int minDistance(String word1, String word2) {\n        /*\n            == very easy and self explanatory ==\n            * just find longest common subsequence and \n            * (word1.length + word2.length - 2 * lcslength) = GET The Job DONE!\n        */\n        for (int i = 0; i \u003c memo.length; i++) \n            Arrays.fill(memo[i], -1);\n        \n        int n = word1.length(), m = word2.length();\n        int lcsLength = longestCommonSubsequence(word1, word2, n - 1, m - 1);\n        return (word1.length() + word2.length() - 2 * (lcsLength));\n    }\n​\n    private int longestCommonSubsequence(String a, String b, int n, int m) {\n        if (n \u003c 0 || m \u003c 0) return 0;\n        if (memo[n][m] != -1) return memo[n][m];\n        if (a.charAt(n) == b.charAt(m)) {\n            return memo[n][m] = 1 + longestCommonSubsequence(a, b, n-1, m-1);\n        }\n        // faith\n        int p = longestCommonSubsequence(a, b, n-1, m);\n        int q = longestCommonSubsequence(a, b, n, m-1);\n        return memo[n][m] = Math.max(p, q);\n    }\n}\n"},{"id":"1662","name":" Check If Two String Arrays are Equivalent","language":"java","code":"class Solution {\n    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {\n        StringBuilder sb1 = new StringBuilder();\n        for (String w : word1) {\n            sb1.append(w);\n        }\n        \n        StringBuilder sb2 = new StringBuilder();\n        for (String w : word2) {\n            sb2.append(w);\n        }\n        \n        return sb1.toString().equals(sb2.toString());\n    }\n}\n"},{"id":"179","name":" Largest Number","language":"cpp","code":"class Solution {\npublic:\n    string largestNumber(vector\u003cint\u003e\u0026 nums) {\n        sort(nums.begin(), nums.end(), [\u0026](const int a, const int b) {\n        string x = to_string(a) + to_string(b) ;\n        string y = to_string(b) + to_string(a);\n        return (x \u003e y) ? 1 : 0 ;\n    });\n        if(nums[0] == 0){ return \"0\" ; }\n        string s = \"\";\n        for(auto \u0026\u0026x : nums) { s += to_string(x) ; }\n        return s ;\n    }\n};\n"},{"id":"1123","name":" Lowest Common Ancestor of Deepest Leaves","language":"cpp","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* answer = nullptr; \n    int maxDepthNode = -1;\n    TreeNode* lcaDeepestLeaves(TreeNode* root) {\n        TreeNode *tmp = root ;\n        dfs(tmp,0);\n        return answer ;\n    }\n    \n    int dfs(TreeNode* root, int curDepth) {\n        if(!root) {\n            return curDepth;\n        }\n        int leftside = dfs(root-\u003eleft, curDepth+1);\n        int rightside = dfs(root-\u003eright, curDepth+1);\n​\n        if(leftside == rightside) {\n            maxDepthNode = max(maxDepthNode, leftside);\n            if(maxDepthNode == leftside) {\n                answer = root;\n            }\n        }\n​\n        return max(leftside, rightside) ;\n    }\n​\n};\n"},{"id":"105","name":" Construct Binary Tree from Preorder and Inorder Traversal","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private final Map\u003cInteger, Integer\u003e inorderRoots = new HashMap\u003c\u003e();\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return _buildTree(preorder, inorder);\n    }\n    \n    private TreeNode _buildTree(int[] preorder, int[] inorder) {\n        processInorderNodes(inorder);\n        TreeNode root = constructFromPreoderInorder(preorder, 0, 0, inorder.length - 1);\n        return root;\n    }\n​\n    private  void processInorderNodes(int[] inorder) {\n        for (int index = 0; index \u003c inorder.length; index++) inorderRoots.put(inorder[index], index);\n    }\n​\n    private TreeNode constructFromPreoderInorder(int[] preorder, int currentIndex, int lo, int hi) {\n        if (lo \u003e hi) return null;\n​\n        TreeNode root = new TreeNode(preorder[currentIndex]);\n        if (root == null || lo == hi) return root;\n​\n        currentIndex++;\n        int rootIndex = inorderRoots.get(root.val);\n​\n        root.left = constructFromPreoderInorder(preorder, currentIndex, lo, rootIndex - 1);\n        root.right = constructFromPreoderInorder(preorder, currentIndex, rootIndex + 1, hi);\n​\n        return root;\n    }\n​\n}\n"},{"id":"352","name":" Data Stream as Disjoint Intervals","language":"java","code":"class SummaryRanges {\n    private Set\u003cInteger\u003e values;\n​\n    public SummaryRanges() {\n        values = new TreeSet\u003c\u003e();\n    }\n    \n    public void addNum(int value) {\n       values.add(value);\n    }\n    \n    public int[][] getIntervals() {\n        if (values.isEmpty()) {\n            return new int[0][2];\n        }\n        List\u003cint[]\u003e intervals = new ArrayList\u003c\u003e();\n        int left = -1, right = -1;\n        for (Integer value : values) {\n            if (left \u003c 0) {\n                left = right = value;\n            } else if (value == right + 1) {\n                right = value;\n            } else {\n                intervals.add(new int[] {left, right});\n                left = right = value;\n            } \n        }\n        intervals.add(new int[] {left, right});\n        return intervals.toArray(new int[0][]); \n    }\n}\n"},{"id":"1922","name":" Count Good Numbers","language":"java","code":"class Solution {\n    private long odd;\n    private long even;\n    private int inf = (int) 1_000_000_007;\n​\n    long m = (int)1e9+7;\n    public int countGoodNumbers(long n) {\n        return (int)(helper(5, (n + 1) / 2) * helper(4, n / 2) % m);    \n    }\n    long helper(long x,long y){\n        if(y == 0)return 1;\n        if(y%2 == 0)return helper((x*x) % m,y/2);\n        else return (x * helper((x*x) % m,(y-1)/2)) % m;\n    }\n    \n    // wrong solution\n    public int countGoodNumbers2(long n) {\n        int count = 0;\n        for (long i = 1; i \u003c= n; i++) {\n            if (isGoodNumber(i)) {\n                count = count++ % (1_000_000_007 + 7);\n            }\n        }\n        return count;\n    }\n​\n    private boolean isGoodNumber(long i) {\n        int length = (int) Math.log10(i) + 1;\n        int[] digits = new int[length];\n        int count = 0;\n        for (int j = 0; j \u003c length; j++) {\n            digits[j] = (int) (i % 10);\n            i /= 10;\n            if (digits[j] % 2 == 0) {\n                count++;\n            }\n            if (digits[j] == 2 || digits[j] == 3 || digits[j] == 5 || digits[j] == 7) {\n                count++;\n            }\n        }\n        return count % 2 == 0;\n    }\n}\n"},{"id":"1832","name":" Check if the Sentence Is Pangram","language":"java","code":"class Solution {\n    public boolean checkIfPangram(String sentence) {\n        Set\u003cCharacter\u003e set = new HashSet\u003c\u003e();   \n        for (char c : sentence.toCharArray()) set.add(c);\n        return set.size() == ( (int) ('z') -  (int)('a') + 1);\n    }\n}\n"},{"id":"1137","name":" N-th Tribonacci Number","language":"java","code":"class Solution {\n    Map\u003cInteger,Integer\u003e memo = new HashMap\u003c\u003e();\n    public Solution(){\n        memo.put(0,0);\n        memo.put(1,1);\n        memo.put(2,1);\n        memo.put(3,2);\n    }\n    public int tribonacci(int n) {  \n        if(memo.containsKey(n)){\n            return memo.get(n);\n        }\n        int s= tribonacci(n-3)+tribonacci(n-2)+tribonacci(n-1); \n        memo.put(n,s);\n        return s;\n    }\n​\n}\n"},{"id":"1679","name":" Max Number of K-Sum Pairs","language":"cpp","code":"class Solution {\npublic:\n    int maxOperations(vector\u003cint\u003e\u0026 nums, int k) {\n        unordered_map\u003cint, int\u003e cache;\n        for (int x : nums)\n           cache[x]++;\n        \n        int ans=0;\n        for(pair\u003cint, int\u003e const \u0026pp : cache) {\n            int key = pp.first;\n            int compp = k - key;\n            if (cache.count(key) \u0026\u0026 cache.count(compp)) {\n                // 1 4\n                if(key != compp) { // meaning they are distinct\n                    ans += min(cache[key], cache[compp]); // pair\u003c\u003e found!\n                    cache[key]=0, cache[compp]=0;\n                } else {\n                    ans += floor(cache[key]/2);\n                    cache[key]=0;\n                }\n            }\n        }\n        return ans;\n    }\n};\n"},{"id":"594","name":" Longest Harmonious Subsequence","language":"cpp","code":"class Solution {\npublic:\n    int findLHS(vector\u003cint\u003e\u0026 nums) {\n        sort(nums.begin(), nums.end());\n        int left = 0, right = 1, ans=0;\n        while(right \u003c (int) nums.size()) {\n            int diff = nums[right]-nums[left];\n            if(diff == 1) {\n                ans = max(ans, right-left+1);\n            }\n            // 2 2 3\n            if(diff \u003c= 1) {right++;}else{left++;}\n        }\n        return ans;\n    }\n};\n"},{"id":"14","name":" Longest Common Prefix","language":"cpp","code":"class Solution {\npublic:\n    string longestCommonPrefix(vector\u003cstring\u003e\u0026 strs) {\n        if(strs.size() == 0)   {\n            return \"\";\n        }\n        string prefix = strs[0];\n        for(int i = 1; i \u003c (int) strs.size(); i++){\n            while(strs[i].find_first_of(prefix) == string::npos){\n                prefix = string(prefix.substr(0, prefix.length() - 1));\n            }\n        }\n        return prefix;\n    }\n};\n"},{"id":"1833","name":" Maximum Ice Cream Bars","language":"java","code":"class Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        // Store ice cream costs in increasing order.\n        Arrays.sort(costs);\n​\n        int n = costs.length;\n        int icecream = 0;\n​\n        // Pick ice creams till we can.\n        while (icecream \u003c n \u0026\u0026 costs[icecream] \u003c= coins) {\n            // We can buy this icecream, reduce the cost from the coins. \n            coins -= costs[icecream];\n            icecream += 1;\n        }\n​\n        return icecream;\n    }\n}\n"},{"id":"1051","name":" Height Checker","language":"java","code":"class Solution {\n    public int heightChecker(int[] heights) {\n        int[] copy = heights.clone();\n        Arrays.sort(copy);\n        int count = 0;\n        for(int i = 0; i \u003c copy.length; i++){\n            if(heights[i]!=copy[i])count++;\n        }\n        return count;\n    }\n}\n"},{"id":"1926","name":" Nearest Exit from Entrance in Maze","language":"java","code":"class Solution {\n    public int nearestExit(char[][] maze, int[] entrance) {\n        int[][] directions = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};\n        int m = maze.length;\n        int n = maze[0].length;\n      \n        int count =0;\n        Queue\u003cint[]\u003e queue = new LinkedList\u003c\u003e();\n        boolean[][] visited = new boolean[m][n];\n        visited[entrance[0]][entrance[1]]=true;\n        queue.offer(entrance);\n        while(!queue.isEmpty()){\n            int size = queue.size();\n            count++;\n            for(int i =0; i\u003csize;i++){\n                int[] temp = queue.poll();\n                \n           \n                for(int[] dir:directions){\n                    int x = temp[0]+dir[0];\n                    int y = temp[1]+dir[1];\n                    if(x\u003e=0\u0026\u0026x\u003cm \u0026\u0026y\u003e=0\u0026\u0026y\u003cn\u0026\u0026visited[x][y]==false\u0026\u0026maze[x][y]=='.'){\n                        queue.offer(new int[]{x,y});\n                        if(x==0||y==0||x==m-1||y==n-1){\n                            return count;\n                        }\n                        \n                        visited[x][y]=true;\n                   }\n                }\n            }            \n        }\n        return -1;             \n        \n    }\n}\n"},{"id":"114","name":" Flatten Binary Tree to Linked List","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private boolean isleafnode(TreeNode root) {return (root.left == null \u0026\u0026 root.right == null) ; }\n    private boolean hasLeft(TreeNode root) {return (root.left != null) ; }\n    \n    public void flatten(TreeNode root) {\n        if (root == null || isleafnode(root)) {\n            return ;\n        }\n        \n        // self\n        if (hasLeft(root)) {\n            TreeNode rootright = root.right;\n            root.right = root.left;\n            root.left = null;\n            \n            TreeNode temp = root.right;\n            while (temp.right != null) temp = temp.right;\n            temp.right = rootright;\n        }\n        \n        // faith\n        flatten(root.right);\n        \n    }\n}\n"},{"id":"14","name":" Longest Common Prefix","language":"java","code":"class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs.length == 0) return \"\";\n        if (strs.length == 1) return strs[0];\n        String prefix = strs[0];\n        for (int i = 1; i \u003c strs.length; i++) {\n            while (strs[i].indexOf(prefix) != 0) {\n                prefix = prefix.substring(0, prefix.length() - 1);\n                if (prefix.length() == 0) return \"\";\n            }\n        }\n        return prefix;\n    }\n}\n​\n"},{"id":"354","name":" Russian Doll Envelopes","language":"java","code":"class Solution {\n    public int maxEnvelopes(int[][] envelopes) {\n        int n = envelopes.length;\n        class Env {\n            int w;\n            int h;\n            int area;\n            Env(int w, int h, int a) {\n                this.w = w;\n                this.h = h;\n                this.area = a;\n            }\n        }\n        \n        Env[] arr = new Env[n];\n        int i = 0;\n        for(int[] envelop : envelopes) {\n            arr[i++] = new Env(envelop[0], envelop[1], envelop[0]*envelop[1]);\n        }\n        \n        Arrays.sort(arr, new Comparator\u003cEnv\u003e() {\n​\n            @Override\n            public int compare(Env a, Env b) {\n                // TODO Auto-generated method stub\n                if (a.area \u003c b.area) {\n                    return 1;\n                }\n                return -1;\n            }\n        });\n        \n        int lis[] = new int[n];\n        Arrays.fill(lis, 1);\n        i = 0;\n        for (int j = 1; j \u003c n; j++) {\n            while(i \u003c j) {\n                if (arr[i].w \u003e arr[j].w \u0026\u0026 arr[i].h \u003e arr[j].h) {\n                    lis[j] = Math.max(lis[j], lis[i] + 1);\n                }\n                i++;\n            }\n            i=0;\n        }\n        int mx = -1;\n        for (int a : lis)\n            mx = Math.max(mx, a);\n        \n        return mx;\n    }\n}\n"},{"id":"1680","name":" Concatenation of Consecutive Binary Numbers","language":"py","code":"class Solution:\n    def concatenatedBinary(self, n: int) -\u003e int:\n        result = \"\"\n        for i in range(1,n+1):\n            result += bin(i)[2:]\n​\n        return int(result, 2) % ((10**9)+7)\n"},{"id":"1834","name":" Single-Threaded CPU","language":"java","code":"class Solution {\n    public int[] getOrder(int[][] tasks) {\n        int n=tasks.length;\n        int[] ans=new int[n];\n        Task[] extTasks=new Task[n];  //extTasks : exist Tasks\n        \n        for(int i=0;i\u003cn;i++){\n            Task nt=new Task(tasks[i][0],tasks[i][1],i);  //nt:new task\n            extTasks[i]=nt;\n        }\n        Arrays.sort(extTasks,new StartTime());\n        \n        PriorityQueue\u003cTask\u003e pq=new PriorityQueue\u003c\u003e(new Duration());\n        \n        int ai=0;  //ai : answer index [will help to fill answer array]\n        int ti=0;  //ti : task index [ iterate over existing tasks,will help to know tasks pending]\n        int currentTime=0;\n        \n        while(ai\u003cn){\n            while(ti\u003cn \u0026\u0026 extTasks[ti].startTime\u003c=currentTime){\n                pq.add(extTasks[ti++]);\n            }\n            \n            if(pq.size()==0){\n                currentTime=extTasks[ti].startTime;\n                continue;\n            }\n            \n            Task bestFit=pq.remove();\n            ans[ai++]=bestFit.index;\n            currentTime+=bestFit.processTime;\n        }\n        return ans;\n    }\n    \n    // will use this to sort on the basis of start time\n    public class StartTime implements Comparator\u003cTask\u003e{\n        @Override\n        public int compare(Task one,Task two){\n            return one.startTime-two.startTime;\n        }\n    }\n    \n    //will use this in priorityQueue\n    public class Duration implements Comparator\u003cTask\u003e{\n        @Override\n        public int compare(Task one,Task two){\n            if(one.processTime==two.processTime) return one.index-two.index;\n            return one.processTime-two.processTime;\n        }\n    }\n    \n    public class Task{\n        int startTime;\n        int processTime;\n        int index;\n        \n        Task(int startTime,int processTime,int index){\n            this.startTime=startTime;\n            this.processTime=processTime;\n            this.index=index;\n        }\n    }\n}\n"},{"id":"6","name":" ZigZag Conversion","language":"py","code":"class Solution:\n    def convert(self, s: str, numRows: int) -\u003e str:\n        if numRows \u003c= 1:\n            return s\n        \n        rows = [[] for i in range(numRows)]\n        currow = 0\n        delta  = -1\n        for ch in s:\n            rows[currow].append(ch)\n            if (currow == 0 or currow == (numRows - 1)):\n                delta = delta * -1\n            currow += delta\n            \n        for i in range(len(rows)):\n            rows[i] = ''.join(rows[i])\n            \n        return ''.join(rows)\n    \n        \n"},{"id":"1143","name":" Longest Common Subsequence","language":"java","code":"class Solution {\n    public int longestCommonSubsequence(String s, String t) {\n        int n = s.length();\n        int m = t.length();\n        int[][] dp = new int[n + 1][m + 1];\n        for (int i = 0; i \u003c dp.length; i++) {\n            for (int j = 0; j \u003c dp[i].length; j++) {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = 0;\n                } else {\n                    char sc = s.charAt(i - 1);\n                    char tc = t.charAt(j - 1);\n                    if (sc == tc) {\n                        dp[i][j] = 1 + dp[i - 1][j - 1];\n                    } else {\n                        int tkn = dp[i][j - 1];\n                        int ntkn = dp[i - 1][j];\n                        dp[i][j] = Math.max(tkn, ntkn);\n                    }\n                }\n            }\n        }\n        return dp[n][m];\n    }\n}\n"},{"id":"106","name":" Construct Binary Tree from Inorder and Postorder Traversal","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int idx;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        idx = inorder.length-1;\n        return constructTree(0, postorder.length-1, inorder, postorder);\n    }\n    public TreeNode constructTree(int start, int end, int[] inorder, int[] postorder) {\n        if (start\u003eend) return null;\n        TreeNode root = new TreeNode(postorder[idx--]);\n        int i;\n        for (i = start; i \u003c= end; i++) {\n            if (root.val==inorder[i]) {\n                break;\n            }\n        }\n        root.right = constructTree(i+1, end, inorder, postorder);\n        root.left = constructTree(start, i-1, inorder, postorder);\n        return root;\n    }\n}\n"},{"id":"140","name":" Word Break II","language":"java","code":"class Solution {\n    public static class Trie {↔}\n​\n    public List\u003cString\u003e wordBreak(String s, List\u003cString\u003e wordDict) {\n        Trie trie = new Trie();\n        for (String b : wordDict)\n            trie.insertWord(b);\n​\n        Map\u003cString, List\u003cString\u003e\u003e map = new HashMap\u003c\u003e();\n        return wordBreak(s, trie, map);\n    }\n​\n    private List\u003cString\u003e wordBreak(String s, Trie trie, Map\u003cString, List\u003cString\u003e\u003e map) {\n        List\u003cString\u003e ans = new ArrayList\u003c\u003e();\n​\n        if (map.containsKey(s)) {\n            return map.get(s);\n        }\n​\n        if (trie.search(s)) {\n            ans.add(s);\n        }\n​\n        for (int i = 1; i \u003c s.length(); i++) {\n            String fpart = s.substring(0, i);\n            if (trie.search(fpart)) {\n                String ros = s.substring(i, s.length());\n                List\u003cString\u003e bbres = wordBreak(ros, trie, map);\n​\n                for (String r : bbres)\n                    ans.add(fpart + \" \" + r);\n            }\n        }\n​\n        map.putIfAbsent(s, ans);\n        return ans;\n    }\n}\n"},{"id":"1689","name":" Partitioning Into Minimum Number Of Deci-Binary Numbers","language":"java","code":"class Solution {\n    public int minPartitions(String n) {\n        /*\n            1) If the input has multiple digits, then you can solve for each digit independently, and merge the answers to form numbers that add up to that input.\n            \n            2) Thus the answer is equal to the max digit.\n        */\n        int ans = n.charAt(0) - '0';\n        for (int i = 1; i \u003c n.length(); i++) {\n            int x = n.charAt(i) - '0';\n            ans = Math.max(ans, x);\n        }\n        return ans;\n    }\n}\n"},{"id":"188","name":" Best Time to Buy and Sell Stock IV","language":"java","code":"class Solution {\n    public int maxProfit(int k, int[] prices) {\n        int n = prices.length;\n        if(k==0||n==0) return 0;\n        if(k \u003e= n/2){\n            //it same as infinite tries\n            int maxProfit = 0;\n            for(int i=0;i\u003cn-1;i++){\n                //means either we dont buy or sell or buy today sell Tomorrow\n                maxProfit = maxProfit + Math.max(0,prices[i+1]-prices[i]);\n            }\n            return maxProfit;\n        }\n        \n        int[] buy = new int[k];\n        int[] sell = new int[k];\n        Arrays.fill(buy,Integer.MIN_VALUE);\n        \n        for(int i=0;i\u003cn;i++){\n            for(int j=0;j\u003ck;j++){\n                //j==0 sybolises that this is our fisrst txn\n                //sell[j-1] - prices[j]: means the money we have from last txn - prices of stock today\n                buy[j] = Math.max(buy[j],j==0?0-prices[i]:sell[j-1]-prices[i]);\n                sell[j] = Math.max(sell[j],buy[j]+prices[i]);\n                //Max of either we don't do any thing or we make profit today\n            }\n        }\n        return sell[k-1];   \n    }\n}\n"},{"id":"141","name":" Linked List Cycle","language":"cpp","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        set\u003cListNode*\u003e cache ;\n        while(head){\n            if(cache.count(head)){\n                return true;\n            }\n            cache.insert(head);\n            head = head-\u003e next;\n        }\n        return false;\n    }\n};\n"},{"id":"1962","name":" Remove Stones to Minimize the Total","language":"java","code":"class Solution {\n    public int minStoneSum(int[] stones, int k) {\n        // minimize and K === PQ question\n        PriorityQueue\u003cInteger\u003e priorityQueue = new PriorityQueue\u003c\u003e(Collections.reverseOrder());\n        for (int stone : stones)\n            priorityQueue.add(stone);\n        int totalSum = Arrays.stream(stones).sum();\n​\n        while (k\u003e0 \u0026\u0026 !priorityQueue.isEmpty()) {\n            int peek = priorityQueue.poll();\n            int peakhalf = Math.floorDiv(peek, 2);\n            totalSum -= peakhalf;\n            priorityQueue.add(peek-peakhalf);\n            k--;\n        }\n​\n        return totalSum;\n    }\n}\n​\n"},{"id":"1061","name":" Lexicographically Smallest Equivalent String","language":"java","code":"class Solution {\n    private static class UnionFind {\n        private int[] parent = new int[27];\n​\n        UnionFind() {\n            for (int u = 0; u \u003c parent.length; u++)\n                parent[u] = u;\n        }\n​\n        public void union(int u, int v) {\n            int pa = find(u);\n            int pb = find(v);\n            // finds the smaller character as parent\n            if (pa \u003e pb) {\n                parent[pa] = pb;\n            } else {\n                parent[pb] = pa;\n            }\n        }\n​\n        public int getparent(int u) {\n            return find(u);\n        }\n​\n        private int find(int u) {\n            if (parent[u] != u) {\n                parent[u] = find(parent[u]);\n            }\n            return parent[u];\n        }\n    }\n​\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\n        UnionFind unionFind = new UnionFind();\n        for (int i = 0; i \u003c s1.length(); i++) {\n            int u = (int) (s1.toCharArray()[i] - 'a');\n            int v = (int) (s2.toCharArray()[i] - 'a');\n            unionFind.union(u, v);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (char bchar : baseStr.toCharArray()) {\n            int code = (int) (bchar - 'a');\n            char ccode = (char) ((int) 'a' + unionFind.getparent(code));\n            sb.append(ccode);\n        }\n        return sb.toString();\n    }\n}\n"},{"id":"1155","name":" Number of Dice Rolls With Target Sum","language":"java","code":"class Solution {\n    public int numRollsToTarget(int d, int f, int target) {\n        int MOD = (int)Math.pow(10, 9) + 7;\n        long[][] dp = new long[d + 1][target + 1];\n        dp[0][0] = 1;\n        for (int i = 1; i \u003c= d; i++) {\n            for (int j = 0; j \u003c= target; j++) {\n                for (int k = 1; k \u003c= f; k++) {\n                    if (j \u003e= k) {\n                        dp[i][j] = (dp[i][j] + dp[i - 1][j - k]) % MOD;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n        return (int)dp[d][target];\n    }\n}\n"},{"id":"36","name":" Valid Sudoku","language":"java","code":"class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        Set\u003cString\u003e set = new HashSet\u003c\u003e();\n        for (int row = 0; row \u003c 9; row++) {\n            for (int column = 0; column \u003c 9; column++) {\n                char number = board[row][column];\n                if (number != '.') {\n                    if (!set.add(number + \" in row \" + row) ||\n                            !set.add(number + \" in column \" + column) ||\n                            !set.add(number + \" in block \" + (row / 3) + \",\" + (column / 3)))\n                        return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n"},{"id":"169","name":" Majority Element","language":"cpp","code":"class Solution {\npublic:\n    int majorityElement(vector\u003cint\u003e\u0026 nums) {\n        int n = nums.size();\n        unordered_map\u003cint, int\u003e cache ;\n        for(auto \u0026\u0026x : nums ){\n            cache[x]++;\n        }\n        int ans= 0;\n        for(int x : nums){\n            if(ans \u003c= cache[x] \u0026\u0026 (n / 2) \u003c cache[x] ){\n                ans = x;\n            }\n        }\n        return ans;\n    }\n};\n"},{"id":"189","name":" Rotate Array","language":"cpp","code":"class Solution {\npublic:\n    void rotate(vector\u003cint\u003e\u0026 nums, int k) { \n       if(k == 0 or nums.size() == 0)\n           return;\n        \n         if(k\u003enums.size())\n            k=k%nums.size();\n        \n        reverse(nums.begin(), nums.end());\n        reverse(nums.begin(), nums.begin()+k);\n        reverse(nums.begin()+k, nums.end());\n        return;\n    }\n};\n"},{"id":"141","name":" Linked List Cycle","language":"java","code":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow = head,fast = head;\n        \n        if(head == null || head.next == null)return false;\n        \n        while(fast != null \u0026\u0026 fast.next != null)\n        {\n            slow = slow.next;\n            fast = fast.next.next;\n            if(slow == fast)\n                return true;\n        }\n        return false;\n    }\n}\n"},{"id":"107","name":" Binary Tree Level Order Traversal II","language":"js","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrderBottom = function (root) {\n  let result = [];\n​\n  const dfs = (root, level) =\u003e {\n    if (!root) return;\n​\n    dfs(root.left, level + 1);\n​\n    if (result[level]) {\n      result[level].push(root.val);\n    } else {\n      result[level] = [root.val];\n    }\n​\n    dfs(root.right, level + 1);\n  };\n​\n  dfs(root, 0);\n  return result.reverse();\n};\n​\n"},{"id":"605","name":" Can Place Flowers","language":"cpp","code":"class Solution {\npublic:\n    bool canPlaceFlowers(vector\u003cint\u003e\u0026 fruits, int n) {\n        int l = (int) fruits.size();\n        int count=0;\n        for(int i = 0; i \u003c l; i++) {\n           if(fruits[i] == 0) {\n                int prev= (i==0 || fruits[i-1] == 0) ? 0 : 1 ;\n                int next= (i==l-1 || fruits[i+1] == 0) ? 0 : 1 ;\n                if(prev==0 \u0026\u0026 next==0) {\n                    fruits[i]=1;\n                    count++;\n                }\n           }\n        }\n        return (count \u003e= n);\n    }\n};\n"},{"id":"1162","name":" As Far from Land as Possible","language":"java","code":"class Solution {\n​\n    class Point {\n        int x;\n        int y;\n        int level;\n​\n        Point(int x, int y, int level) {\n            this.x = x;\n            this.y = y;\n            this.level = level;\n        }\n    }\n​\n    public int maxDistance(int[][] grid) {\n        int R = grid.length;\n        int C = grid[0].length;\n        boolean[][] visited = new boolean[R][C];\n​\n        Queue\u003cPoint\u003e queue = new LinkedList\u003cPoint\u003e();\n​\n        for (int row = 0; row \u003c R; row++) {\n            for (int col = 0; col \u003c C; col++) {\n                // if land\n                if (grid[row][col] == 1) {\n                    queue.offer(new Point(row, col, 0));\n                    visited[row][col] = true;\n                }\n            }\n        }\n​\n        int[] dx = new int[] { 1, -1, 0, 0 };\n        int[] dy = new int[] { 0, 0, -1, 1 };\n​\n        int maxLevel = -1;\n​\n        // process each land\n        while (queue.isEmpty() == false) {\n            Point land = queue.remove();\n​\n            maxLevel = Math.max(land.level, maxLevel);\n​\n            for (int k = 0; k \u003c 4; k++) {\n                int nrow = land.x + dx[k];\n                int ncol = land.y + dy[k];\n​\n                if (nrow \u003e= 0 \u0026\u0026 nrow \u003c R \u0026\u0026 ncol \u003e= 0 \u0026\u0026 ncol \u003c C \u0026\u0026 visited[nrow][ncol] == false) {\n                    visited[nrow][ncol] = true;\n                    queue.add(new Point(nrow, ncol, land.level + 1));\n                }\n            }\n        }\n​\n        return maxLevel \u003e 0 ? maxLevel : -1; // why 0 becase if no land / water no solution can be found!\n    }\n}\n"},{"id":"1971","name":" Find if Path Exists in Graph","language":"java","code":"class Solution {\n\tprivate static class UnionFind {\n\t\tprivate int[] parents;\n\t\tprivate int vertices;\n\n\t\tpublic UnionFind(int vertices) {\n\t\t\tsuper();\n\t\t\tthis.vertices = vertices;\n\t\t\tthis.parents = new int[vertices + 1];\n\t\t\tfor (int i = 0; i \u003c vertices; i++)\n\t\t\t\tparents[i] = i;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"UnionFind [parents=\" + Arrays.toString(parents) + \", vertices=\" + vertices + \"]\";\n\t\t}\n\n\t\tpublic void union(int u, int v) {\n\t\t\tif (u != v) {\n\t\t\t\tint pa = find(u);\n\t\t\t\tint pb = find(v);\n\t\t\t\tparents[pb] = pa;\n\t\t\t}\n\t\t}\n\n\t\tprivate int find(int u) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tint x = u;\n\t\t\twhile (x != parents[x]) {\n\t\t\t\tx = parents[x];\n\t\t\t}\n\t\t\tparents[u] = x;\n\t\t\treturn x;\n\t\t}\n\n\t\tpublic boolean areConnected(int u, int v) {\n\t\t\treturn find(u) == find(v);\n\t\t}\n\t}\n\n\tpublic boolean validPath(int n, int[][] edges, int source, int destination) {\n//\t\t\treturn DFSTraversalMethod(n, edges, source, destination);\n\t\tUnionFind uf = new UnionFind(n);\n\t\tfor (int[] edge : edges) {\n\t\t\tint u = edge[0];\n\t\t\tint v = edge[1];\n\t\t\tuf.union(u, v);\n\t\t}\n\t\treturn uf.areConnected(source, destination);\n\t}\n\n\tprivate boolean DFSTraversalMethod(int n, int[][] edges, int source, int destination) {\n\t\ttry {\n\t\t\tMap\u003cInteger, List\u003cInteger\u003e\u003e graph = buildGraph(edges);\n\n\t\t\tboolean[] visitedVertices = new boolean[n];\n\t\t\tStack\u003cInteger\u003e stack = new Stack\u003c\u003e();\n\n\t\t\tmarkAsVisited(source, visitedVertices, stack);\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tint node = stack.pop();\n\t\t\t\tfor (int neighbour : graph.get(node)) {\n\t\t\t\t\tif (neighbour == destination)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif (!visitedVertices[neighbour]) {\n\t\t\t\t\t\tmarkAsVisited(neighbour, visitedVertices, stack);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate Map\u003cInteger, List\u003cInteger\u003e\u003e buildGraph(int[][] edges) {\n\t\tMap\u003cInteger, List\u003cInteger\u003e\u003e graph = new HashMap\u003c\u003e();\n\t\tfor (int[] edge : edges) {\n\t\t\tint u = edge[0];\n\t\t\tint v = edge[1];\n\n\t\t\tgraph.putIfAbsent(u, new ArrayList\u003c\u003e());\n\t\t\tgraph.putIfAbsent(v, new ArrayList\u003c\u003e());\n\n\t\t\tgraph.get(u).add(v);\n\t\t\tgraph.get(v).add(u);\n\t\t}\n\t\treturn graph;\n\t}\n\n\tprivate void markAsVisited(int source, boolean[] visitedVertices, Stack\u003cInteger\u003e stack) {\n\t\tvisitedVertices[source] = true;\n\t\tstack.add(source);\n\t}\n}\n"},{"id":"19","name":" Remove Nth Node From End of List","language":"cpp","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int k) {\n        ListNode* root = new ListNode() ;\n        root-\u003enext = head;\n        ListNode* f = root, *s = root;\n        for(int i = 1; i \u003c= k+1; i++)\n            f = f -\u003e next;\n        \n        while(f){\n            f = f -\u003e next;\n            s = s -\u003e next;\n        }\n        ListNode* d = s-\u003enext;\n        s-\u003enext = s-\u003enext-\u003enext;\n        delete d;\n        return root-\u003enext;\n    }\n};\n"},{"id":"198","name":" House Robber","language":"cpp","code":"class Solution {\npublic:\n    int rob(vector\u003cint\u003e\u0026 nums) {\n        if(nums.empty() or nums.size() == 0){\n            return 0;\n        }\n        if(nums.size() == 1){\n            return nums[0];\n        }\n        if(nums.size() == 0){\n            return max(nums[0], nums[1]);\n        }\n        int n = nums.size();\n        vector\u003cint\u003e dp(n);\n        dp[0] = nums[0];\n        dp[1] = max(nums[0], nums[1]);\n        for(int i = 2; i \u003c n; i++){\n            dp[i] = max(nums[i] + dp[i-2], dp[i-1]);\n        }\n        return dp[n-1];\n    }\n};\n"},{"id":"38","name":" Count and Say","language":"cs","code":"public class Solution \n{\n  public string CountAndSay(int n) \n  {\n    var result = \"1\";\n    \n    if (n == 1) return result;\n    \n    var i = 1;\n    var countSay = 1;\n    while (i \u003c n)\n    {\n      var temp = result;\n      result = string.Empty;\n      for (var j = 0; j \u003c temp.Length - 1; j++)\n      {\n        if (temp[j] == temp[j + 1])\n        {\n          countSay++;\n        }\n        else\n        {\n          result += countSay;\n          result += temp[j];\n          countSay = 1;\n        }\n      }\n      result += countSay;\n      result += temp[temp.Length - 1];\n      countSay = 1;\n      i++;\n    }\n    return result;\n  }\n}\n"},{"id":"1690","name":" Stone Game VII","language":"java","code":"class Solution {\n    public int stoneGameVII(int[] stones) {\n        final int n = stones.length;\n        int[] dp = new int[n];\n​\n        for (int i = n-1; i \u003e= 0; i--) {\n            int temp = 0;\n            int sumSoFar = stones[i];\n            for (int j = i; j \u003c n; j++) {\n                if (i != j) {\n                    sumSoFar += stones[j];\n                    int a = sumSoFar - stones[j];\n                    int b = sumSoFar - stones[i];\n                    dp[j] = Math.max(a - temp, b-dp[j]);\n                }\n                temp = dp[j];\n            }\n        }\n        return dp[n-1];\n    }\n}\n"},{"id":"142","name":" Linked List Cycle II","language":"java","code":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        // return optimized(head);\n        ListNode slow = head;\n        ListNode fast = head;\n​\n        boolean hasLoop = false;\n        while (fast != null \u0026\u0026 fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                hasLoop = true;\n                break;\n            }\n        }\n​\n        if (!hasLoop)\n            return null;\n​\n        fast = head;\n        while (fast != slow) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n​\n    private ListNode optimized(ListNode head) {\n        if (head == null || head.next == null) return null;\n        // use of two pointer technique\n        ListNode slow = head;\n        ListNode fast = head;\n        boolean found=false;\n        while (fast.next != null \u0026\u0026 fast.next.next != null) {\n            slow = slow.next;\n            fast=fast.next.next;\n            if (fast == slow) {\n                found=true;\n                break;\n            }\n        }\n        if (!found) return null;\n        fast = head;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n"},{"id":"605","name":" Can Place Flowers","language":"java","code":"// \"\"\"\n// # _* coding: utf8 *_\n​\n// filename: Solution.java\n​\n// @author: sounishnath\n// createdAt: 2023-03-23 07:02:33\n// \"\"\"\n​\nclass Solution {\n    public boolean canPlaceFlowers(int[] flowerbed, int flowers) {\n        int length = flowerbed.length;\n        int unoccupiedPlace = 0;\n        for (int i = 0; i \u003c length; i++) {\n            if (isEmpty(flowerbed[i])) {\n                int previous = (i == 0 || isEmpty(flowerbed[i - 1])) ? 0 : 1;\n                int next = (i == length - 1 || isEmpty(flowerbed[i + 1])) ? 0 : 1;\n                if (isEmpty(previous) \u0026\u0026 isEmpty(next)) {\n                    unoccupiedPlace++;\n                    flowerbed[i]=1;\n                }\n            }\n        }\n​\n        return unoccupiedPlace \u003e= flowers;\n    }\n​\n    private boolean isEmpty(int i) {\n        return i == 0;\n    }\n}\n"},{"id":"118","name":" Pascal's Triangle","language":"cpp","code":"class Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e generate(int numRows) {\n        vector\u003cvector\u003cint\u003e\u003e ans;\n        \n        for(int row = 0 ; row \u003c numRows; row++) \n        { \n            vector\u003cint\u003e t;\n            for(int space = 0; space \u003c (numRows - row); space++)\n            { \n                // cout \u003c\u003c \" \" ; \n            \n            } \n            int n = 1 ; \n            for(int col = 0; col \u003c= row; col++)\n            { \n                t.push_back(n); \n                n = n * (row - col) / (col + 1) ;\n            } \n            ans.push_back(t);\n        }\n        return ans;\n    }\n};\n"},{"id":"19","name":" Remove Nth Node From End of List","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        // if (head.next == null) return null;\n        // if (head.next.next == null) return head.next;\n​\n        ListNode slow = head;\n        ListNode fast = head;\n​\n        for (int i = 0; i \u003c n; i++) {\n            fast = fast.next;\n        }\n​\n        if (fast == null) return slow.next;\n​\n        while (fast.next != null) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n​\n        slow.next = slow.next.next;\n        \n        return head;\n    }\n}\n"},{"id":"1695","name":" Maximum Erasure Value","language":"java","code":"class Solution {\n    public int maximumUniqueSubarray(int[] nums) {\n        \n        Set\u003cInteger\u003e set =  new HashSet();\n        \n      int sum =0, ans =0;\n        int j = 0;\n        \n        int i = 0;\n        \n        while(i\u003cnums.length \u0026\u0026 j\u003cnums.length){\n            \n            if(!set.contains(nums[j])){\n                \n                sum+=nums[j];\n                ans = Math.max(sum,ans);\n                set.add(nums[j++]);\n            }else{\n                \n                sum = sum-nums[i];\n                set.remove(nums[i++]);\n            }\n        }\n​\n        return ans;\n    }\n}\n"},{"id":"380","name":" Insert Delete GetRandom O(1)","language":"java","code":"class RandomizedSet {\n    private Set\u003cInteger\u003e set;\n    private List\u003cInteger\u003e list;\n    private Random random;\n​\n    public RandomizedSet() {\n        this.set = new HashSet\u003c\u003e();\n        this.list = new ArrayList\u003c\u003e();\n        this.random = new Random();\n    }\n​\n    public boolean insert(int val) {\n        if (this.set.contains(val))\n            return false;\n        this.set.add(val);\n        list.add(val);\n        return true;\n    }\n​\n    public boolean remove(int val) {\n        if (this.set.contains(val)) {\n            this.set.remove(val);\n            this.list.remove(Integer.valueOf(val));\n            return true;\n        }\n        return false;\n    }\n​\n    public int getRandom() {\n        int id = this.random.nextInt(this.set.size());\n        return this.list.get(id);\n    }\n}\n​\n/**\n    * Your RandomizedSet object will be instantiated and called as such:\n    * RandomizedSet obj = new RandomizedSet(); boolean param_1 = obj.insert(val);\n    * boolean param_2 = obj.remove(val); int param_3 = obj.getRandom();\n*/\n​\n"},{"id":"108","name":" Convert Sorted Array to Binary Search Tree","language":"cpp","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    \n    TreeNode* f(vector\u003cint\u003e \u0026nums, int lo, int hi){\n        if(lo \u003e hi){\n            return nullptr;\n        }\n        int mid = (lo + hi) \u003e\u003e 1;\n        TreeNode* root = new TreeNode(nums[mid]);\n        root-\u003eleft = f(nums, lo, mid-1);\n        root-\u003eright = f(nums, mid + 1, hi);\n        return root;\n    }\n    \n    TreeNode* sortedArrayToBST(vector\u003cint\u003e\u0026 nums) {\n       if(nums.empty()){\n           return nullptr;\n       }\n        return f(nums, 0, nums.size() - 1);\n    }\n};\n"},{"id":"198","name":" House Robber","language":"java","code":"class Solution {\n    public int rob(int[] nums) {\n        /*\n         * dp[i] = maxof(dp[i-1], profit[i]+d[i-2])\n         */\n        int MIN_LIMIT = (Integer.MIN_VALUE - 1);\n        int n = nums.length;\n        if (n \u003c= 2) {\n            if (n == 1)\n                return nums[0];\n            return maxof(nums[0], nums[1]);\n        }\n​\n        int[] dp = new int[n];\n        dp[0] = nums[0];\n        dp[1] = maxof(nums[0], nums[1]);\n        for (int i = 2; i \u003c n; i++) {\n            int consider = dp[i - 2] + nums[i];\n            int notconsider = dp[i - 1];\n            dp[i] = maxof(consider, notconsider);\n        }\n        System.out.println(Arrays.toString(dp));\n        return dp[n - 1];\n    }\n​\n    private int maxof(int... arr) {\n        // TODO Auto-generated method stub\n        return Arrays.stream(arr).max().getAsInt();\n    }\n}\n​\n"},{"id":"190","name":" Reverse Bits","language":"cpp","code":"class Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n          // you need treat n as an unsigned value\n   int res = 0;\n        int x = 31;\n        while(x \u003e= 0){\n            res = res ^ ((n \u0026 0x1) \u003c\u003c (x--));\n            n \u003e\u003e= 0x1;\n        }\n​\n        return res;\n    }\n};\n"},{"id":"118","name":" Pascal's Triangle","language":"java","code":"class Solution {\n    public List\u003cList\u003cInteger\u003e\u003e generate(int numRows) {\n        return generatePascalsTrianle(numRows);\n    }\n    \n    private static List\u003cList\u003cInteger\u003e\u003e generatePascalsTrianle(int numRows) {\n        // TODO Auto-generated method stub\n        List\u003cList\u003cInteger\u003e\u003e finalSet = new ArrayList\u003cList\u003cInteger\u003e\u003e();\n​\n        int curRow = 1;\n        List\u003cInteger\u003e sublist = new ArrayList\u003cInteger\u003e();\n        sublist.add(1);\n​\n        // generating 1st row of triangle\n        finalSet.add(sublist);\n​\n        while(curRow \u003c numRows) {\n            // get the prev. row\n            // create new row \n            // 0...curRow\n                // get leftNum, get rightNum\n                // simply add in new row\n​\n            List\u003cInteger\u003e prevRow = finalSet.get( curRow - 1 );\n            List\u003cInteger\u003e newRow = new ArrayList\u003cInteger\u003e();\n​\n            for (int i = 0; i \u003c= curRow; i++) {\n                int leftElem = i \u003e= 1 ? prevRow.get(i-1) : 0;\n                int rightElem = i \u003c curRow ? prevRow.get(i) : 0;\n                int sum = leftElem + rightElem;\n                newRow.add(sum);\n            }\n​\n            finalSet.add(newRow);\n            curRow++;\n        }\n​\n        return finalSet;\n    }\n}\n"},{"id":"382","name":" Linked List Random Node","language":"cpp","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    /** @param head The linked list's head.\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\n    ListNode* root1 = nullptr;\n    Solution(ListNode* head) {\n        root1 = head;\n    }\n    \n    /** Returns a random node's value. */\n    int getRandom() {\n        ListNode* root = root1;\n        int i = 1, ans = 0;\n        while(root) {\n            if((float)(rand() / RAND_MAX) \u003c 1.0/i ) {\n                ans = root -\u003e val;\n            }\n            i++;\n            root = root -\u003e next;\n        }\n        return ans;\n    }\n};\n​\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(head);\n * int param_1 = obj-\u003egetRandom();\n */\n"},{"id":"1996","name":" The Number of Weak Characters in the Game","language":"java","code":"class Solution {\n    private static class Pair {\n        int attack;\n        int defense;\n​\n        public Pair(int attack, int defense) {\n            this.attack = attack;\n            this.defense = defense;\n        }\n​\n        @Override\n        public String toString() {\n            return \"Pair [attack=\" + attack + \", defense=\" + defense + \"]\";\n        }\n    }\n​\n    public int numberOfWeakCharacters(int[][] properties) {\n        int n = properties.length;\n        Pair[] characters = new Pair[n];\n        for (int i = 0; i \u003c n; i++) {\n            characters[i] = new Pair(properties[i][0], properties[i][1]);\n        }\n        int weak_characters = 0;\n        Arrays.sort(characters, new Comparator\u003cPair\u003e() {\n            @Override\n            public int compare(Pair a, Pair b) {\n                if (a.attack == b.attack) {\n                    return a.defense - b.defense;\n                }\n                return b.attack - a.attack;\n            }\n        });\n        int current_max_defence = 0;\n        for (Pair pair : characters) {\n            if (current_max_defence \u003e pair.defense)\n                weak_characters++;\n            current_max_defence = Math.max(current_max_defence, pair.defense);\n        }\n​\n        return weak_characters;\n    }\n}\n"},{"id":"1423","name":" Maximum Points You Can Obtain from Cards","language":"java","code":"class Solution {\n    public int maxScore(int[] cardPoints, int k) {\n        int currScore = 0;\n        for (int i = 0; i \u003c k; i++) currScore += cardPoints[i];\n        int bestScore = currScore;\n        for (int i = k - 1, j = cardPoints.length - 1; i \u003e= 0 \u0026\u0026 j \u003e= 0; i--, j--) {\n            currScore += cardPoints[j] - cardPoints[i];\n            bestScore = Math.max(currScore, bestScore);\n        }\n        return bestScore;\n    }\n    // not fully accepted question : Lagging Corner cases!\n    public int maxScore2(int[] cardPoints, int k) {\n        Deque\u003cInteger\u003e dequeue = new LinkedList\u003c\u003e();\n        for (int x : cardPoints) dequeue.add(x);\n        int score = 0;\n        if (k == cardPoints.length) {\n            for (int x : cardPoints) score += x;\n            return score;\n        }\n        while(dequeue.size() \u003e 0 \u0026\u0026 k-- \u003e 0) {\n            int currScore1 = 0;\n            int currScore2 = 0;\n            currScore1 += dequeue.peekFirst();\n            currScore2 += dequeue.size() \u003e 1 ? dequeue.peekLast() : 0;\n            currScore1 += score;\n            currScore2 += score;\n            if (currScore1 \u003e currScore2) {\n                score = currScore1;\n                dequeue.pollFirst();\n            } else {\n                score = currScore2;\n                dequeue.pollLast();\n            }\n        }\n        return score;\n    }\n}\n"},{"id":"1192","name":" Critical Connections in a Network","language":"java","code":"class Solution {\n    // Thankfully noe works !!\n    private int time = 0;\n\n    private void dfsArticulation(ArrayList\u003cArrayList\u003cInteger\u003e\u003e graph, \n    int src, boolean[] vis, int[] parent, int[] disc, int[] low, boolean[] arti,\n    List\u003cList\u003cInteger\u003e\u003e res) {\n        disc[src] = low[src] = time;\n        time++;\n        vis[src] = true;\n        int count = 0; // count for finding original source status about articulation\n        for(int nbr : graph.get(src)) {\n            if(vis[nbr] == true \u0026\u0026 parent[src] != nbr) {\n                // visited but not parent\n                low[src] = Math.min(low[src], disc[nbr]);\n            } else if(vis[nbr] == false) {\n                // unvisited neighbour\n                parent[nbr] = src;\n                dfsArticulation(graph, nbr, vis, parent, disc, low, arti, res);\n                low[src] = Math.min(low[src], low[nbr]);\n                count++; // increment in count if we are making call to nbr\n                if(disc[src] \u003c low[nbr]) {\n                    List\u003cInteger\u003e edge = new ArrayList\u003c\u003e();\n                    edge.add(src);\n                    edge.add(nbr);\n                    res.add(edge);\n                    arti[src] = true;\n                }\n            }\n        }\n    }\n\n\n    private List\u003cList\u003cInteger\u003e\u003e articulationBridge(ArrayList\u003cArrayList\u003cInteger\u003e\u003e graph) {\n        int count = 0;\n        int n = graph.size();\n        int[] parent = new int[n];\n        int[] disc = new int[n];\n        int[] low = new int[n];\n        boolean[] vis = new boolean[n];\n        boolean[] arti = new boolean[n];\n        parent[0] = -1; // parent of starting point is -1\n        time = 0;\n        List\u003cList\u003cInteger\u003e\u003e res = new ArrayList\u003c\u003e();\n        dfsArticulation(graph,  0, vis, parent, disc, low, arti, res); \n        return res;\n    }\n\n    public List\u003cList\u003cInteger\u003e\u003e criticalConnections(int n, List\u003cList\u003cInteger\u003e\u003e connections) {\n        ArrayList\u003cArrayList\u003cInteger\u003e\u003e graph = new ArrayList\u003c\u003e();\n        for(int i = 0; i \u003c n; i++) {\n            graph.add(new ArrayList\u003c\u003e());\n        }\n\n        for(List\u003cInteger\u003e edge : connections) {\n            int v1 = edge.get(0);\n            int v2 = edge.get(1);\n\n            graph.get(v1).add(v2);\n            graph.get(v2).add(v1);\n        }\n        List\u003cList\u003cInteger\u003e\u003e res = articulationBridge(graph);\n        return res;\n    }\n\n}\n"},{"id":"1696","name":" Jump Game VI","language":"java","code":"class Solution {\n    \n    class Pair {\n        int cost;\n        int index;\n​\n        Pair(int cost, int index) {\n            this.cost = cost;\n            this.index = index;\n        }\n    }\n​\n    public int maxResult(int[] nums, int k) {\n            final int n = nums.length;\n            int result = nums[0];\n​\n            PriorityQueue\u003cPair\u003e priorityQueue = new PriorityQueue\u003c\u003e((a, b) -\u003e b.cost - a.cost);\n            priorityQueue.add(new Pair(nums[0], 0));\n​\n            for (int i = 1; i \u003c n; i++) {\n                while (priorityQueue.isEmpty() == false \u0026\u0026 priorityQueue.peek().index \u003c i - k)\n                    priorityQueue.remove();\n​\n                result = priorityQueue.peek().cost + nums[i];\n                priorityQueue.add(new Pair(result, i));\n            }\n​\n            return result;\n        }\n}\n"},{"id":"382","name":" Linked List Random Node","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n​\n    /** @param head The linked list's head.\n        Note that the head is guaranteed to be not null, so it contains at least one node. */\n    ListNode root = null;\n    public Solution(ListNode head) {\n        this.root = head;\n    }\n    \n    /** Returns a random node's value. */\n    public int getRandom() {\n        int i =1, ans = 0;\n        ListNode tmp = this.root;\n        while(tmp != null) {\n            if(Math.random() \u003c 1.0/i ) {\n                ans = tmp.val;\n            }\n            i++;\n            tmp = tmp.next;\n        }\n        return ans;\n    }\n}\n​\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(head);\n * int param_1 = obj.getRandom();\n */\n"},{"id":"108","name":" Convert Sorted Array to Binary Search Tree","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        int lo = 0;\n        int hi = nums.length - 1;\n​\n        TreeNode root = this.sortedArrayToBST(nums, lo, hi);\n        return root;\n    }\n​\n    private TreeNode sortedArrayToBST(int[] nums, int lo, int hi) {\n        if (lo \u003e hi) return null;\n        \n        if (lo == hi) return new TreeNode(nums[lo]);\n​\n        int mid = (lo + hi) / 2;\n        TreeNode node = new TreeNode(nums[mid]);\n​\n        // faith\n        node.left = this.sortedArrayToBST(nums, lo, mid - 1);\n        node.right = this.sortedArrayToBST(nums, mid + 1, hi);\n​\n        return node;\n    }\n}\n"},{"id":"143","name":" Reorder List","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public void reorderList(ListNode head) {\n        fold(head);    \n    }\n    \n    public void fold(ListNode head) {\n        /*\n            1: Segregate the 1 and 2 halves\n            2: Reverse 2nd Half\n            3: Make Connections using proper logic\n            4: Match Output using PrintList\n         */\n​\n        ListNode middle_node = getMiddleNode(head);\n        ListNode th = middle_node.next;\n        ListNode head2 = reverse(th);\n        middle_node.next = null;\n​\n        ListNode t1 = head;\n        ListNode t2 = head2;\n​\n        while (t1 != null \u0026\u0026 t2 != null){\n            ListNode n1 = t1.next;\n            ListNode n2 = t2.next;\n​\n            t1.next = t2;\n            t2.next = n1;\n​\n            t1 = n1;\n            t2 = n2;\n        }\n    }\n​\n    private ListNode reverse(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n​\n        while (curr != null) {\n            ListNode next = curr.next;\n​\n            curr.next = prev;\n            prev = curr;\n​\n            curr = next;\n        }\n​\n        return prev;\n    }\n​\n    private ListNode getMiddleNode(ListNode head) {\n        ListNode slow_pointer = head;\n        ListNode fast_pointer = head;\n​\n        while (fast_pointer.next != null \u0026\u0026 fast_pointer.next.next != null) {\n            slow_pointer = slow_pointer.next;\n            fast_pointer = fast_pointer.next.next;\n        }\n​\n        return slow_pointer;\n    }\n​\n}\n"},{"id":"2","name":" Add Two Numbers","language":"cpp","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* root1, ListNode* root2) {\n        if(!root1) {\n            return root2;\n        }\n        if(!root2) {\n            return root1 ;\n        }\n        ListNode *answer = NULL, *t, *prev(NULL) ;\n        int cursum = 0, carry = 0 ;\n        while(root1 or root2) {\n            cursum = carry + ( root1 ? root1-\u003eval : 0 ) + ( root2 ? root2-\u003eval : 0 ) ;\n            carry = (cursum \u003e 9) ? 1 : 0 ;\n            cursum %= 10 ;\n            t = new ListNode(cursum) ;\n            if(!answer) { answer = t ; }\n            else {\n                prev-\u003enext = t ;\n            }\n            prev = t ;\n            if(root1) { root1 = root1-\u003enext ; }\n            if(root2) { root2 = root2-\u003enext ; }\n        }\n        if(carry \u003e 0) {\n"},{"id":"609","name":" Find Duplicate File in System","language":"java","code":"class Solution {\n    public List\u003cList\u003cString\u003e\u003e findDuplicate(String[] paths) {\n        Map\u003cString, List\u003cString\u003e\u003e contMap = new HashMap\u003c\u003e();\n        StringBuilder pathfile = new StringBuilder();\n        for (String pStr : paths) {\n            int i = 0;\n            pathfile.setLength(0);\n            while (pStr.charAt(i) != ' ') i++;\n            pathfile.append(pStr.substring(0,i)).append('/');\n            int pLen = ++i;\n            for (int j = i, k = 0; i \u003c pStr.length(); i++)\n                if (pStr.charAt(i) == '(') {\n                    pathfile.append(pStr.substring(j,i));\n                    k = i + 1;\n                } else if (pStr.charAt(i) == ')') {\n                    String cont = pStr.substring(k, i);\n                    if (!contMap.containsKey(cont))\n                        contMap.put(cont, new ArrayList\u003c\u003e());\n                    contMap.get(cont).add(pathfile.toString());\n                    j = i + 2;\n                    pathfile.setLength(pLen);\n                }\n        }\n        List\u003cList\u003cString\u003e\u003e ans = new ArrayList\u003c\u003e();\n        for (List\u003cString\u003e v : contMap.values())\n            if (v.size() \u003e 1) ans.add(v);\n        return ans;\n    }\n}\n"},{"id":"384","name":" Shuffle an Array","language":"cpp","code":"class Solution {\nprivate:\n    std::vector\u003cint\u003e array;\n    std::vector\u003cint\u003e arr_copy;\n    \npublic:\n    Solution(std::vector\u003cint\u003e\u0026 nums):\n        array(std::move(nums)),\n        arr_copy(std::vector\u003cint\u003e { array.begin(), array.end() }) {}\n    \n    /** Resets the array to its original configuration and return it. */\n    std::vector\u003cint\u003e reset() {\n        array = arr_copy;\n        arr_copy = std::vector\u003cint\u003e { arr_copy.begin(), arr_copy.end() };\n        return arr_copy;\n    }\n    \n    /** Returns a random shuffling of the array. */\n    std::vector\u003cint\u003e shuffle() {\n        std::mt19937 rng { std::random_device{}() };\n        std::shuffle(begin(array), end(array), rng);\n        return array;\n    }\n};\n​\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution* obj = new Solution(nums);\n * vector\u003cint\u003e param_1 = obj-\u003ereset();\n * vector\u003cint\u003e param_2 = obj-\u003eshuffle();\n */\n"},{"id":"109","name":" Convert Sorted List to Binary Search Tree","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    \n     public TreeNode sortedListToBST(ListNode head) {\n         if(head == null) return null;\n         return _sortedListToBST(head, null);\n    }\n​\n    private TreeNode _sortedListToBST(ListNode head, ListNode tailNode) {\n        if (head == tailNode) return null;\n        // find middle of the linekdList\n        // 2 pointer approch\n        ListNode fast = head;\n        ListNode slow = head;        \n        while (fast != tailNode \u0026\u0026 fast.next != tailNode){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        TreeNode root = new TreeNode(slow.val);\n        root.left = _sortedListToBST(head, slow);\n        root.right = _sortedListToBST(slow.next, tailNode);\n        return root;\n    }\n}\n"},{"id":"1437","name":" Check If All 1's Are at Least Length K Places Away","language":"cpp","code":"class Solution {\npublic:\n    bool kLengthApart(vector\u003cint\u003e\u0026 nums, int k) {\n        if(nums.empty()) { return false; }\n        int oneIndex = -1; bool assume=true;\n        for(int i = 0; i \u003c nums.size(); i++) {\n            int one = nums[i];\n            if(one==1){\n                if(oneIndex==-1)\n                    oneIndex=i;\n                else {\n                    int dist = i - oneIndex - 1 ;\n                    if(dist \u003c k) {\n                        assume = false;\n                        break;\n                    }\n                    oneIndex=i;\n                }\n            }\n        }\n        return assume;\n    }\n};\n"},{"id":"12","name":" Integer to Roman","language":"java","code":"class Solution {\n    public String intToRoman(int num) {\n        /**\n         * XIV --\u003e 14\n         * X I V\n         * i i+1\n         * 1 \u003c 5 ----\u003e (-) ---\u003e 4\n         * i i+1\n         * 10 \u003e 1 --------\u003e (+) ---\u003e 10\n         * --------------------------------\n         * (+) ---\u003e 14\n         */\n​\n        final Map\u003cInteger, String\u003e map = prepareRomanTableMapper();\n        System.out.println(map);\n        final int[] value = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };\n        final String[] roman = { \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" };\n​\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i \u003c value.length; i++) {\n            while (num \u003e= value[i]) {\n                sb.append(roman[i]);\n                num = num - value[i];\n            }\n        }\n​\n        return sb.toString();\n    }\n​\n    final private Map\u003cInteger, String\u003e prepareRomanTableMapper() {\n        Map\u003cInteger, String\u003e map = new HashMap\u003c\u003e();\n        map.put(1, \"I\");\n        map.put(5, \"V\");\n        map.put(10, \"X\");\n        map.put(50, \"L\");\n        map.put(100, \"C\");\n        map.put(500, \"D\");\n        map.put(1000, \"M\");\n        return map;\n    }\n}\n"},{"id":"20","name":" Valid Parentheses","language":"cpp","code":"class Solution {\npublic:\n   bool isValid(string s) {\n        \n        map\u003cchar,char\u003e closing; // the set of closing parenthesis\n        closing[')'] = '('; // the opening parenthesis of the closing parenthesis\n        closing[']'] = '[';\n        closing['}'] = '{';\n        \n        stack\u003cchar\u003e stack;\n        map\u003cchar,char\u003e::iterator it;\n        for (int i = 0; i \u003c s.size(); i++)  {\n            it = closing.find(s[i]);\n            if (it != closing.end())     // if s[i] is found in closing\n                if (!stack.empty() \u0026\u0026 it-\u003esecond == stack.top())    // if stack is not empty and its top element is the opening parenthesis of the closing parenthesis s[i]\n                    stack.pop();\n                else\n                    return false;\n            else\n                stack.push(s[i]);   // add the opening s[i] to stack\n        }\n                \n        if (stack.empty())\n            return true;\n        else\n            return false;\n    }\n};\n"},{"id":"1901","name":" Find a Peak Element II","language":"java","code":"class Solution {\n​\n    public int[] findPeakGrid(int[][] grid) {\n        int R = grid.length;\n        int C = grid[0].length;\n​\n        for (int row = 0; row \u003c R; row++) {\n            int startCol = 0;\n            int endCol = C - 1;\n​\n            while (startCol \u003c= endCol) {\n                int midColumn = startCol + (endCol - startCol) / 2;\n                int element = grid[row][midColumn];\n                int left = 1, right = 1, top = 1, bottom = 1;\n                if (midColumn - 1 \u003e 0) {\n                    left = grid[row][midColumn - 1];\n                }\n                if (midColumn + 1 \u003c C) {\n                    right = grid[row][midColumn + 1];\n                }\n                if (row - 1 \u003e 0) {\n                    top = grid[row - 1][midColumn];\n                }\n                if (row + 1 \u003c R) {\n                    top = grid[row + 1][midColumn];\n                }\n​\n                if (element \u003e left \u0026\u0026 element \u003e right \u0026\u0026 element \u003e top \u0026\u0026 element \u003e bottom) {\n                    return new int[] { row, midColumn };\n                }\n​\n                if (Math.max(left, grid[row][0]) \u003c Math.max(right, grid[row][C - 1])) {\n                    startCol = midColumn + 1;\n                } else {\n                    endCol = midColumn - 1;\n                }\n            }\n        }\n​\n        return null;\n    }\n}\n"},{"id":"384","name":" Shuffle an Array","language":"java","code":"class Solution {\n​\n    private int[] originalArray;\n    private int[] temp;\n    private Random random;\n    public Solution(int[] nums) {\n        this.originalArray = nums.clone();\n        this.temp = nums.clone();\n        this.random = new Random();\n    }\n    \n    /** Resets the array to its original configuration and return it. */\n    public int[] reset() {\n        this.temp = this.originalArray.clone(); // .clone() is the fucking hell. to use otherwize object will shallow copy.\n        // this deeply copies\n        return this.temp;\n    }\n    \n    /** Returns a random shuffling of the array. */\n    public int[] shuffle() {\n        for (int i = this.temp.length - 1; i \u003e= 0; i--) {\n            int randomIndex = this.randomIndexGenerator(i+1);\n            this.swap(i, randomIndex);\n        }\n        \n        return this.temp;\n    }\n    \n    private void swap(int i, int j) {\n        int t = this.temp[i];\n        this.temp[i] = this.temp[j];\n        this.temp[j] = t;\n    }\n    \n    private int randomIndexGenerator(int rangei) { return this.random.nextInt(rangei) ; }\n}\n​\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(nums);\n * int[] param_1 = obj.reset();\n * int[] param_2 = obj.shuffle();\n */\n"},{"id":"17","name":" Letter Combinations of a Phone Number","language":"cpp","code":"class Solution {\npublic:\n    vector\u003cstring\u003e mapps = {\n            \"0\",\n            \"1\",\n            \"abc\",\n            \"def\",\n            \"ghi\",\n            \"jkl\",\n            \"mno\",\n            \"pqrs\",\n            \"tuv\",\n            \"wxyz\"\n        };\n    \n    vector\u003cstring\u003e letterCombinations(string digits) {\n        vector\u003cstring\u003e answers;\n        if(digits.length() == 0 || digits.empty()) {\n            return answers;\n        }\n        dfs(answers, digits, \"\", 0);\n        return answers;\n    }\n    \n    void dfs(vector\u003cstring\u003e\u0026 answers, string digits, string curr, int index) {\n        if(digits.length() == index) {\n            answers.push_back(curr);\n            return ;\n        }\n        string letters = mapps[digits[index] - '0'];\n        for(auto letter : letters) {\n            f(answers, digits, curr+letter, index+1);\n        }\n    }\n};\n"},{"id":"61","name":" Rotate List","language":"java","code":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k==0||head==null||head.next==null) return head;\n        ListNode current = head;\n        int length = 1;\n        while (current.next != null) {\n            current = current.next;\n            length++;\n        }\n​\n        current.next = head;\n        k = k % length;\n        int diff = length - k;\n​\n        while (diff \u003e 0) {\n            diff--;\n            current = current.next;\n        }\n​\n        head = current.next;\n        current.next = null;\n        \n        return head;\n    }\n​\n    private int getLength(ListNode head) {\n        if (head == null) return 0;\n​\n        int count = 1;\n        while (head != null) {\n            head = head.next;\n            count++;\n        }\n        return count;\n    }\n​\n    private ListNode getLastNode(ListNode head) {\n        ListNode current = head;\n        while (current.next != null)\n            current = current.next;\n​\n        return current;\n    }\n}\n"},{"id":"200","name":" Number of Islands","language":"cpp","code":"class Solution {\npublic:\n    int numIslands(vector\u003cvector\u003cchar\u003e\u003e\u0026 grid) {\n        \n        if(grid.empty()) {\n            return 0;\n        }\n        \n        int H = grid.size(),\n            W = grid[0].size();\n        \n        int ans = 0;\n        for(int row = 0; row \u003c H; row++) {\n            for(int col = 0; col \u003c W; col++) {\n                if(grid[row][col] == '1') {\n                    ans += dfs(grid, row, col, H, W);\n                }\n            }\n        }\n        return ans;\n    }\n    \n    int dfs(vector\u003cvector\u003cchar\u003e\u003e\u0026 grid, int row, int col, int H, int W) {\n        \n        if(row \u003c 0 or row \u003e= H || col \u003c 0 or col \u003e= W || grid[row][col] != '1' ) {\n            return 0;\n        }\n        \n        grid[row][col] = '0';\n        \n        dfs(grid, row+1, col, H, W);\n        dfs(grid, row-1, col, H, W);\n        dfs(grid, row, col+1, H, W);\n        dfs(grid, row, col-1, H, W);\n        \n        return 1;\n    }\n};\n"},{"id":"121","name":" Best Time to Buy and Sell Stock","language":"cpp","code":"class Solution {\npublic:\n    int maxProfit(vector\u003cint\u003e\u0026 prices) {\n        int ans = 0, minimal = 2e9+81;\n        for(auto \u0026\u0026 x : prices){\n            minimal = min(x, minimal);\n            ans = max(ans, x - minimal);\n        }\n        return ans;\n    }\n};\n"},{"id":"144","name":" Binary Tree Preorder Traversal","language":"java","code":"class Solution {\n    public List\u003cInteger\u003e preorderTraversal(TreeNode root) {\n        return morrisTraversal(root);\n    }\n    \n    private List\u003cInteger\u003e morrisTraversal(TreeNode root) {\n        List\u003cInteger\u003e result = new ArrayList\u003c\u003e();\n        if (root == null) return result;\n        \n        TreeNode current = root;\n        while (current != null) {\n            result.add(current.val);\n            // check if left not null;\n            if (current.left != null) {\n                // goto rightmost child of current.left\n                TreeNode temp = current.left;\n                while (temp.right != null) {\n                    temp = temp.right;\n                }\n                // point temp.right to current.right to explore the right part\n                temp.right = current.right;\n                current.right = null; // to clear the references to duplicate remove\n                current = current.left;\n            } else {\n                // means left is null, new current is current right\n                current = current.right;\n            }\n        }\n        \n        \n        return result;\n    }\n}\n"},{"id":"387","name":" First Unique Character in a String","language":"cpp","code":"class Solution {\npublic:\n    int firstUniqChar(string s) {\n//         map\u003cchar, int\u003e cache;\n        \n//         for(auto \u0026\u0026 x : s){\n//             cache[x]++;\n//         }\n        \n//         for(auto \u0026\u0026 x : s){\n//             if(cache[x] == 1){\n//                 return distance(s.begin(), find(s.begin(), s.end(), x));\n//             }\n//         }\n//         return -1;\n        \n        // -1 indicates that there are no occurences of char.\n        int count_chars[26] = {[0 ... 25] = -1};\n        for (int i=0; i\u003cs.size(); i++) {\n            char c = s[i];\n            int val = count_chars[s[i] - 'a'];\n            if (val == -1) count_chars[c - 'a'] = i;\n            // -2 indicates that there are more than one occurence of char.\n            else if (val != -2) count_chars[c - 'a'] = -2;\n        }\n        int return_index = INT_MAX;\n        for (int i=0; i\u003c26; i++) {\n            if (count_chars[i] \u003e= 0) {\n                // Get the lowest index for a char that occurs only once.\n                return_index = min(return_index, count_chars[i]);\n            }\n        }\n        if (return_index != INT_MAX) return return_index;\n        return -1;\n    }\n        \n    }\n};\n"},{"id":"1704","name":" Determine if String Halves Are Alike","language":"java","code":"class Solution {\n    public boolean halvesAreAlike(String s) {\n        s=s.toLowerCase();\n        int n=s.length();\n        int mid=n/2;\n        String part1=s.substring(0, mid);\n        String part2=s.substring(mid, n);\n        System.out.println(\"p=\" + part1 + \", q=\" + part2);\n        return (isAlike(part1, part2));\n    }\n​\n    private boolean isAlike(String part1, String part2) {\n        // TODO Auto-generated method stub\n        if (part1.length() != part2.length())\n            return false;\n        int avowelscount = countVowels(part1);\n        int bvowelscount = countVowels(part2);\n        return avowelscount == bvowelscount;\n    }\n​\n    private int countVowels(String s) {\n        // TODO Auto-generated method stub\n        char[] letters = s.toCharArray();\n        int count = 0;\n        for (char letter : letters) {\n            if (letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u') {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n​\n"},{"id":"122","name":" Best Time to Buy and Sell Stock II","language":"cpp","code":"class Solution {\npublic:\n    int maxProfit(vector\u003cint\u003e\u0026 prices) {\n        if (prices.size() == 0)\n            return 0;\n​\n        int sum = 0, prev = 0;\n        for (int i = 0; i \u003c prices.size(); i++)\n        {\n            if (i == prices.size() - 1)\n            {\n                sum += prices[i] - prices[prev];\n            }\n​\n            else if (prices[i] \u003e prices[i + 1])\n            {\n                sum += prices[i] - prices[prev];\n                prev = i + 1;\n            }\n        }\n​\n        return sum;\n    }\n};\n"},{"id":"39","name":" Combination Sum","language":"java","code":"class Solution {\n    public List\u003cList\u003cInteger\u003e\u003e combinationSum(int[] arr, int target) {\n        List\u003cList\u003cInteger\u003e\u003e result = new ArrayList\u003c\u003e();\n        comboSum(arr, target, 0, new ArrayList\u003cInteger\u003e(), result);\n        return result;\n    }\n    \n    private static void comboSum(int[] arr, int target, int curindex, List\u003cInteger\u003e store, List\u003cList\u003cInteger\u003e\u003e result) {\n​\n        if (curindex == arr.length) {\n            if (target == 0) {\n                result.add(new ArrayList\u003c\u003e(store));\n            }\n            return ;\n        }\n​\n        int sum = target - arr[curindex] ;\n        if (sum \u003e= 0) {\n            store.add(arr[curindex]);\n            comboSum(arr, sum, curindex, store, result);\n            store.remove(store.size() - 1);\n        }\n        comboSum(arr, target, curindex + 1, store, result);\n    }\n}\n"},{"id":"200","name":" Number of Islands","language":"java","code":"class Solution {\n        static int[] xdir = {-1, 0, 1, 0};\n    static int[] ydir = {0, -1, 0, 1};\n​\n    // leetcode 200. https://leetcode.com/problems/number-of-islands/\n    private static void islands_dfs(char[][] graph, int x, int y) {\n        graph[x][y] = '0';\n        for(int d = 0; d \u003c 4; d++) {\n            int r = x + xdir[d];\n            int c = y + ydir[d];\n            if(r \u003e= 0 \u0026\u0026 r \u003c graph.length \u0026\u0026 c \u003e= 0 \u0026\u0026 c \u003c graph[0].length \u0026\u0026 graph[r][c] != '0') {\n                islands_dfs(graph, r, c);\n            }\n        }\n    }\n​\n    public int numIslands(char[][] grid) {\n        int islands = 0;\n        for(int i = 0; i \u003c grid.length; i++) {\n            for(int j = 0; j \u003c grid[0].length; j++) {\n                if(grid[i][j] == '1') {\n                    islands_dfs(grid, i, j);\n                    islands++;\n                }\n            }\n        }\n        return islands;\n    }\n}\n"},{"id":"1443","name":" Minimum Time to Collect All Apples in a Tree","language":"java","code":"class Solution {\n    public int minTime(int n, int[][] edges, List\u003cBoolean\u003e hasApple) {\n        List\u003cList\u003cInteger\u003e\u003e graph = buildGraph(edges, n);\n        return dfs(graph, 0, -1, hasApple);\n    }\n​\n    private int dfs(List\u003cList\u003cInteger\u003e\u003e graph, int node, int parent, List\u003cBoolean\u003e hasApple) {\n        // TODO Auto-generated method stub\n        int time = 0;\n        for (int neighbor : graph.get(node)) {\n            if (neighbor == parent)\n                continue;\n            int timeForChild = dfs(graph, neighbor, node, hasApple);\n            if (timeForChild \u003e 0 || hasApple.get(neighbor)) time += timeForChild + 2;\n        }\n​\n        return time;\n    }\n​\n    private List\u003cList\u003cInteger\u003e\u003e buildGraph(int[][] edges, int n) {\n        // TODO Auto-generated method stub\n        List\u003cList\u003cInteger\u003e\u003e graph = new ArrayList\u003c\u003e();\n        for (int v = 0; v \u003c n; v++)\n            graph.add(new ArrayList\u003c\u003e());\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n        return graph;\n    }\n}\n​\n"},{"id":"1706","name":" Where Will the Ball Fall","language":"java","code":"class Solution {\n    public int[] findBall(int[][] grid) {\n        int result[] = new int[grid[0].length];\n        for (int i = 0; i \u003c grid[0].length; i++) {\n            result[i] = findBallDropColumn(0, i, grid);\n        }\n        return result;\n    }\n​\n    public int findBallDropColumn(int row, int col, int[][] grid) {\n        // base case; ball reached the last row\n        if (row == grid.length)\n            return col;\n        int nextColumn = col + grid[row][col];\n        if (nextColumn \u003c 0 ||\n                nextColumn \u003e grid[0].length - 1 ||\n                grid[row][col] != grid[row][nextColumn]) {\n            return -1;\n        }\n        return findBallDropColumn(row + 1, nextColumn, grid);\n    }\n}\n"},{"id":"392","name":" Is Subsequence","language":"java","code":"class Solution {\n    public boolean isSubsequence(String s, String t) {\n        // s ki t er subsequence\n        \n        // checking if any string is a subsequence of another string\n        // in O(N)\n        \n        int prevIdx = 0;\n        for (char c : s.toCharArray()) {\n            int foundIndex = t.indexOf(c, prevIdx);\n            if (foundIndex == -1) return false;\n            prevIdx = foundIndex + 1;\n        }\n        \n        return true;\n    }\n}\n"},{"id":"2007","name":" Find Original Array From Doubled Array","language":"java","code":"class Solution {\n    public int[] findOriginalArray(int[] changed) {\n        List\u003cInteger\u003e result = new ArrayList\u003c\u003e();\n        Arrays.sort(changed);\n        int n = changed.length;\n        if (n%2==1) return new int[]{};\n​\n        Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e();\n​\n        for (int i = n - 1; i \u003e= 0; i--) {\n            int elem = changed[i];\n            int doubled = elem * 2;\n            if (map.containsKey(doubled)) {\n                if (map.get(doubled) == 1) {\n                    map.remove(doubled);\n                } else {\n                    map.put(doubled, map.get(doubled) - 1);\n                }\n​\n                result.add(elem);\n            } else {\n                map.put(elem, map.getOrDefault(elem, 0) + 1);\n            }\n        }\n​\n        return result.size() == n / 2 ? result.stream().mapToInt(Integer::intValue).toArray() : new int[] {};\n    }\n}\n"},{"id":"611","name":" Valid Triangle Number","language":"java","code":"class Solution {\n    public int triangleNumber(int[] nums) {\n        /*\n         * Method 1: Sort the array in ascending order. For each element, we check if\n         * there are two other elements that can form a triangle. If yes, then we\n         * increment the count. Time Complexity: O(n^2) Space Complexity: O(1)\n         * \n         * Method 2: Sort the array in ascending order. For each element, we check if\n         * there are two other elements that can form a triangle. If yes, then we\n         * increment the count. Time Complexity: O(nlogn) Space Complexity: O(1)\n         */\n​\n        Arrays.sort(nums);\n        int count = 0;\n​\n        // lovely tweaked BinarySearch problem.\n        // we can use BinarySearch to find the index of the first element that is\n        // greater than the sum of the two other elements.\n​\n        for (int i = nums.length - 1; i \u003e -1; i--) {\n            int lo = 0;\n            int r = i-1;\n​\n            while (lo \u003c r) {\n                int sumOfTwoSide = nums[lo] + nums[r];\n                if (sumOfTwoSide \u003e nums[i]) { // ami bhebhechilam == hoy, kintu strictly greater than hobe!\n                    count += r - lo;\n                    r--;\n                } else {\n                    lo++;\n                }\n            }\n        }\n​\n        return count;\n    }\n}\n"},{"id":"1094","name":" Car Pooling","language":"java","code":"class Solution {\n    public boolean carPooling(int[][] trips, int capacity) {\n        int[] passengersByStops = new int[100000];\n        for (int[] trip : trips) {\n            int passengers = trip[0]; // passengers\n            int sourceIndex = trip[1]; // sourceId\n            int destinationIndex = trip[2]; // sourceId\n            \n            passengersByStops[sourceIndex] += passengers;\n            passengersByStops[destinationIndex] -= passengers;\n        }\n        \n        int totalPassengers = 0;\n        for (int i = 0; i \u003c passengersByStops.length; i++) {\n            totalPassengers += passengersByStops[i];\n            if (totalPassengers \u003e capacity) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n"},{"id":"171","name":" Excel Sheet Column Number","language":"cpp","code":"class Solution {\npublic:\n    int titleToNumber(string s) {\n        long long int n=0;\n        for(auto c: s){\n            n = (n * 26) + (int)(c - 'A' + 1);\n        }\n        return n;\n    }\n};\n"},{"id":"191","name":" Number of 1 Bits","language":"cpp","code":"class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n       int ans = 0 ;\n        while(n){\n           ans += (n \u0026 1);\n            n = n \u003e\u003e 1;\n        }\n        return ans;\n    }\n};\n"},{"id":"395","name":" Longest Substring with At Least K Repeating Characters","language":"cpp","code":"class Solution {\npublic:\nint f(string \u0026s, int lo, int hi, int k){\n        if(hi-lo \u003c k){\n            return 0;\n        }\n        vector\u003cint\u003e count(26);\n        for(int i = lo; i\u003c hi; i++){\n            count[s[i]-'a']++;\n        }\n        for(int i = lo; i \u003c hi; i++){\n            if(count[s[i]-'a'] \u003c k ){\n                int j = i+1;\n​\n                while(j\u003chi \u0026\u0026 count[s[j] -'a'] \u003c k){\n                    j++;\n                }\n                return max( f(s, lo, i, k), f(s, j, hi, k) );\n            }\n        }\n        return hi-lo;\n}\n    \n    int longestSubstring(string s, int k) {\n        \n        return f(s, 0, s.length(), k);\n    }\n};\n"},{"id":"122","name":" Best Time to Buy and Sell Stock II","language":"java","code":"class Solution {\n    public int maxProfit(int[] arr) {\n        final int n = arr.length;\n        int overrallProfit = 0;\n​\n        for (int i = 1; i \u003c n; i++) {\n            int profit = arr[i] - arr[i-1];\n            if (profit \u003e 0) {\n                overrallProfit += profit;\n            }\n        }\n        \n        return overrallProfit;\n    }\n}\n"},{"id":"1448","name":" Count Good Nodes in Binary Tree","language":"java","code":"class Solution {\n    public int goodNodes(TreeNode root) {\n        return f(root,root.val);\n    }\n    \n    public int f(TreeNode root,int max) {\n        if(root==null) return 0;\n        \n        int ans=0;\n        if(max\u003c=root.val) {\n            max=root.val;\n            ans++;\n        }\n        \n        int l1 = f(root.left,max);\n        int r1 = f(root.right,max);\n        \n        return ans+l1+r1;\n    }\n}\n"},{"id":"171","name":" Excel Sheet Column Number","language":"java","code":"class Solution {\n    public int titleToNumber(String columnTitle) {\n        // sum of (26 * X + newCharY) thats the essence of the problem\n        \n        int sum = 0;\n        for (char x : columnTitle.toCharArray())\n            sum = (sum * 26) + ( x - 'A' + 1 );\n        \n        return sum;\n    }\n}\n"},{"id":"62","name":" Unique Paths","language":"java","code":"class Solution {\n    private Map\u003cString, Integer\u003e dp = new HashMap\u003c\u003e();\n    public int uniquePaths(int m, int n) {\n        // return find_paths(0,0,m,n);\n        int[][] dp = new int[m+1][n+1];\n​\n        for (int col=0; col \u003c n; col++) dp[0][col]=1;\n        for (int row=0; row\u003cm; row++) dp[row][0]=1;\n​\n        for (int row=1; row \u003c m; row++) {\n            for (int col=1; col \u003c n; col++) {\n                dp[row][col] += dp[row-1][col] + dp[row][col-1];\n            }\n        }\n        return dp[m-1][n-1];\n    }\n​\n    private int find_paths(int i, int j, int m, int n) {\n        if (i \u003e= m || j \u003e= n) return 0;\n        if (dp.containsKey(\"\" + i + '@' + j)) return dp.get(\"\"+i+'@'+j);\n        if (i==m-1 \u0026\u0026 j==n-1) {\n            return 1;\n        }\n        int go_down=find_paths(i+1, j, m, n);\n        int go_right=find_paths(i, j+1, m, n);\n        dp.put(\"\"+i+'@'+j, go_down+go_right);\n        return go_down+go_right;\n    }\n}\n"},{"id":"202","name":" Happy Number","language":"cpp","code":"class Solution {\npublic:\n    bool isHappy(int n) {\n        set\u003cint\u003e cache;\n        while(!cache.count(n)){\n            cache.insert(n);\n            n = f(n);\n            if(n == 1){\n                return true;\n            }\n        }\n        return false;\n    }\n    int f(int n) {\n        int sum = 0;\n        while(n \u003e 0){\n            sum += (n % 10) * (n % 10);\n            n = n / 10;\n        }\n        return sum;\n    }\n};\n"},{"id":"21","name":" Merge Two Sorted Lists","language":"cpp","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        ListNode fake(-1);\n        ListNode* last = \u0026fake;\n        \n        while(l1 != NULL \u0026\u0026 l2 != NULL){\n            if(l1-\u003eval \u003c l2-\u003eval){\n                last-\u003enext = l1;\n                last = l1;\n                l1 = l1-\u003enext;\n            }else{\n                last-\u003enext = l2;\n                last = l2;\n                l2 = l2-\u003enext;\n            }\n        }\n        \n        if(l1 != NULL){\n            last-\u003enext = l1;\n        }\n        if(l2 != NULL){\n            last-\u003enext = l2;\n        }\n        return fake.next;\n    }\n};\n"},{"id":"4","name":" Median of Two Sorted Arrays","language":"java","code":"class Solution {\n    public double findMedianSortedArrays(int[] a, int[] b) {\n       int n = a.length;\n        int m = b.length;\n        int i = 0, j = 0, k = 0;\n        \n        int[] combo = new int[n+m];\n        // feed all elems into ONE\n        while(i \u003c n \u0026\u0026 j \u003c m) {\n            combo[k++] = (a[i] \u003e b[j]) ? b[j++] : a[i++];\n        }\n        // if any elem left in a[]\n        while(i \u003c n) {\n            combo[k++] = a[i++];\n        }\n        // if any elem left in b[]\n        while(j \u003c m)\n            combo[k++] = b[j++];\n        \n        int hf = (int) ((n + m) / 2);\n​\n        if (combo.length % 2 == 0) {\n            // if even\n            return (double) (combo[hf - 1] + combo[hf]) / 2;\n        }\n        return (double) combo[hf] ;\n    }\n}\n"},{"id":"145","name":" Binary Tree Postorder Traversal","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List\u003cInteger\u003e postorderTraversal(TreeNode root) {\n        List\u003cInteger\u003e nodes = new ArrayList\u003c\u003e();\n        func (root, nodes);\n        return nodes;\n    }\n    \n    private void func (TreeNode node, List\u003cInteger\u003e nodes) {\n        if (node != null) {\n            func (node.left, nodes);\n            func (node.right, nodes);\n            nodes.add (node.val);\n        }\n    }\n}\n"},{"id":"217","name":" Contains Duplicate","language":"cpp","code":"class Solution {\npublic:\n    bool containsDuplicate(vector\u003cint\u003e\u0026 nums) {\n        set\u003cint\u003e cache ;\n        for(auto \u0026\u0026 x : nums ){\n            if(cache.count(x)){\n                return true;\n            }\n                cache.insert(x);\n        }\n        return false;\n    }\n};\n"},{"id":"204","name":" Count Primes","language":"cpp","code":"class Solution {\npublic:\n    int countPrimes(int n) {\n        if(n \u003c 2){\n            return 0;\n        }\n        \n        vector\u003cbool\u003e primee(n + 1) ;\n        for(long long int i = 2; i \u003c n + 1; i++){\n            if(!primee[i]){\n                for(long long int j = i * i; j \u003c n + 1; j += i){\n                    primee[j] = true;\n                }\n            }\n        }\n        \n        int ans = 0;\n        for(int i = 2; i \u003c n ; i++){\n            if(primee[i] == false){\n                ans++;\n            }\n        }\n        \n        return ans;\n    }\n};\n"},{"id":"621","name":" Task Scheduler","language":"cpp","code":"class Solution {\npublic:\n    int leastInterval(vector\u003cchar\u003e\u0026 tasks, int n) {\n        map\u003cchar, int\u003e  cache ;\n        for (char x : tasks)\n            cache[x]++;\n        \n        priority_queue\u003cint\u003e pq;\n        for (pair\u003cint, int\u003e v : cache)\n            pq.push(v.second);\n        \n        int cycles = 0;\n        while (!pq.empty()) {\n            vector\u003cint\u003e temp; // ith clock cycle in CPU\n            for (int cooler = 0; cooler \u003c n + 1; cooler++) {\n                if (!pq.empty()){\n                    temp.push_back(pq.top());\n                    pq.pop();    \n                }\n            }\n            // run again for any task occurs more \u003e 1\n            for (int task : temp) {\n                if(--task \u003e 0) {\n                    pq.push(task);\n                }\n            }\n            \n            cycles += (pq.empty()) ? temp.size() : n+1 ;\n        }\n        \n        return cycles;\n    }\n};\n"},{"id":"2279","name":" Maximum Bags With Full Capacity of Rocks","language":"java","code":"package src;\n\nimport java.util.Arrays;\n\n// 2279. https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/\npublic class MaximumBagsWithCapacity2279 {\n\tpublic static void main(String[] args) {\n\t\tint[] capacity = new int[] {91,54,63,99,24,45,78};\n\t\tint[] rocks = new int[] { 35,32,45,98,6,1,25 };\n\t\tint additionalRocks = 17;\n\n\t\tSystem.out.println(new Solution().maximumBags(capacity, rocks, additionalRocks));\n\t}\n\n\tstatic class Solution {\n\t\tprivate class RockBag implements Comparable\u003cRockBag\u003e {\n\t\t\tint capacity;\n\t\t\tint presentRocks;\n\t\t\tint extraRequired;\n\n\t\t\tpublic RockBag(int capacity, int presentRocks) {\n\t\t\t\tsuper();\n\t\t\t\tthis.capacity = capacity;\n\t\t\t\tthis.presentRocks = presentRocks;\n\t\t\t\tthis.extraRequired = (capacity - presentRocks);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"RockBag [capacity=\" + capacity + \", presentRocks=\" + presentRocks + \", extraRequired=\"\n\t\t\t\t\t\t+ extraRequired + \"]\";\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int compareTo(RockBag o) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\t// descending order sorting\n\t\t\t\treturn this.extraRequired - o.extraRequired;\n\t\t\t}\n\t\t}\n\n\t\tpublic int maximumBags(int[] capacity, int[] rocks, int additionalRocks) {\n\t\t\t/*\n\t\t\t * 1. try to fill the maximum rocks with the capacity 2. means sort the array by\n\t\t\t * the capacity and present rocks 3. try to fill the rocks with additional rocks\n\t\t\t * till its 0\n\t\t\t */\n\t\t\tRockBag[] bags = getRockBags(capacity, rocks);\n\t\t\tPrinter.log(Arrays.toString(bags));\n\t\t\tArrays.sort(bags);\n\t\t\tPrinter.log(Arrays.toString(bags));\n\n\t\t\tint target = 0;\n\t\t\tfor (int i = 0; i \u003c bags.length \u0026\u0026 additionalRocks \u003e 0; i++) {\n\t\t\t\tadditionalRocks = additionalRocks - bags[i].extraRequired;\n\t\t\t\tif (additionalRocks\u003e0) target++;\n\t\t\t}\n\t\t\treturn target;\n\t\t}\n\n\t\tprivate RockBag[] getRockBags(int[] capacity, int[] rocks) {\n\t\t\tRockBag[] bags = new RockBag[capacity.length];\n\t\t\tfor (int i = 0; i \u003c bags.length; i++)\n\t\t\t\tbags[i] = new RockBag(capacity[i], rocks[i]);\n\t\t\treturn bags;\n\t\t}\n\t}\n}\n"},{"id":"1457","name":" Pseudo-Palindromic Paths in a Binary Tree","language":"cpp","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    int cache[10];\n    int answer = 0;\npublic:\n    int pseudoPalindromicPaths (TreeNode* root) {\n        dfs (root);\n        return answer ;\n    }\n    \n    void dfs(TreeNode* root) {\n        if (root==nullptr) {\n            return ;\n        }\n        cache[root-\u003eval]++;\n        if (!root-\u003eleft \u0026\u0026 !root-\u003eright) {\n            if (isPaindome()) {\n                answer++;\n            }\n        }else {\n            dfs(root-\u003eleft);\n            dfs(root-\u003eright);\n        }\n        cache[root-\u003eval]-- ;\n    }\n​\n    bool isPaindome() {\n        int oddparity = 0;\n        for (int i = 1 ; i \u003c= 9; i++) {\n            int x = cache[i];\n            if(x\u00261){\n                oddparity++;\n            }\n        }\n        return oddparity \u003c 2 ;\n    }\n​\n​\n};\n"},{"id":"123","name":" Best Time to Buy and Sell Stock III","language":"java","code":"class Solution {\n    public int maxProfit(int[] prices) {\n        int buyAtFirst = Integer.MAX_VALUE;\n        int profitForFirstTransaction = 0;\n        \n        int buyAtSecond = Integer.MAX_VALUE;\n        int profitForSecondTransaction = 0;\n        \n        for (int i = 0; i \u003c prices.length; i++) {\n            // ------ FOR 1st Trans -------\n            int todayPrice = prices[i];\n            if (todayPrice \u003c buyAtFirst) {\n                buyAtFirst = todayPrice;\n            }\n            int profit = todayPrice - buyAtFirst;\n            profitForFirstTransaction = Math.max(profitForFirstTransaction, profit);\n            // ------ FOR 2nd Trans -------\n            int extraMoneyHaveToSpend = todayPrice - profitForFirstTransaction;\n            if (extraMoneyHaveToSpend \u003c buyAtSecond)\n                buyAtSecond = extraMoneyHaveToSpend;\n            \n            int anotherProfit = todayPrice - buyAtSecond;\n            if (anotherProfit \u003e profitForSecondTransaction)\n                profitForSecondTransaction = anotherProfit;\n        }\n        \n        return profitForSecondTransaction;\n    }\n}\n"},{"id":"40","name":" Combination Sum II","language":"java","code":"import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.logging.LogManager;\n​\nclass Solution {\n    public List\u003cList\u003cInteger\u003e\u003e combinationSum2(int[] candidates, int target) {\n        List\u003cList\u003cInteger\u003e\u003e answer = new ArrayList\u003c\u003e();\n        Arrays.sort(candidates);\n        combinationSum2(candidates, target, 0, answer, new ArrayList\u003c\u003e());\n        return answer;\n    }\n​\n    private void combinationSum2(int[] candidates, int target, int curIndex, List\u003cList\u003cInteger\u003e\u003e answer,\n            ArrayList\u003cInteger\u003e arrayList) {\n​\n        if (target \u003c 0)\n            return;\n​\n        if (target == 0) {\n            answer.add(new ArrayList\u003c\u003e(arrayList));\n            return;\n        }\n​\n        for (int index = curIndex; index \u003c candidates.length; index++) {\n            int value = candidates[index];\n​\n            if (value \u003e target)\n                break;\n            if (index \u003e curIndex \u0026\u0026 value == candidates[index - 1])\n                continue;\n​\n            arrayList.add(value);\n            combinationSum2(candidates, target - value, index + 1, answer, arrayList);\n            arrayList.remove(arrayList.size() - 1);\n        }\n​\n    }\n}\n"},{"id":"204","name":" Count Primes","language":"java","code":"class Solution {\n    public int countPrimes(int n) {\n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true);\n        for (int i = 2; i * i \u003c n; i++) {\n            if(isPrime[i]==false) continue;\n            else {\n                for (int j = i * i; j \u003c n; j +=i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        int count = 0;\n        for (boolean x : isPrime) {\n            if (x==true) count++;\n        }\n        return count-2;\n    }\n}\n"},{"id":"229","name":" Majority Element II","language":"java","code":"class Solution {\n    public List\u003cInteger\u003e majorityElement(int[] nums) {\n        int elem1 = -1;\n        int elem2 = -1;\n        int count1 = 0;\n        int count2 = 0;\n​\n        for (int elem : nums) {\n            if (elem == elem1)\n                count1++;\n            else if (elem == elem2)\n                count2++;\n            else if (count1 == 0) {\n                count1 = 1;\n                elem1 = elem;\n            } else if (count2 == 0) {\n                count2 = 1;\n                elem2 = elem;\n            } else {\n                count1--;\n                count2--;\n            }\n        }\n​\n        count1 = 0;\n        count2 = 0;\n        for (int num : nums) {\n            if (num == elem1)\n                count1++;\n            if (num == elem2)\n                count2++;\n        }\n​\n        int length = nums.length;\n        List\u003cInteger\u003e result = new ArrayList\u003c\u003e();\n​\n        if (count1 \u003e length / 3)\n            result.add(elem1);\n​\n        if (elem1 != elem2 \u0026\u0026 count2 \u003e length / 3)\n            result.add(elem2);\n​\n        return result;\n    }\n}\n"},{"id":"21","name":" Merge Two Sorted Lists","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode head1, ListNode head2) {\n            ListNode t1 = head1;\n            ListNode t2 = head2;\n​\n            ListNode dummy = new ListNode(-100);\n            ListNode temp = dummy;\n​\n            while(t1 != null \u0026\u0026 t2 != null){\n                if(t1.val \u003c t2.val) {\n                    temp.next = t1;\n                    t1 = t1.next;\n                } else {\n                    temp.next = t2;\n                    t2 = t2.next;    \n                }\n                temp = temp.next;\n            }\n            if(t1 != null) {\n                temp.next = t1;\n                // t1 = t1.next;\n            }\n​\n            if(t2 != null) {\n                temp.next = t2;\n                // t2 = t2.next;\n            }\n​\n            return dummy.next;\n    }\n}\n"},{"id":"1235","name":" Maximum Profit in Job Scheduling","language":"java","code":"class Solution {\n    private static class JobInfo implements Comparable\u003cJobInfo\u003e {\n        int starttime;\n        int endtime;\n        int profit;\n​\n        public JobInfo(int starttime, int endtime, int profit) {\n            super();\n            this.starttime = starttime;\n            this.endtime = endtime;\n            this.profit = profit;\n        }\n​\n        @Override\n        public String toString() {\n            return \"JobInfo [starttime=\" + starttime + \", endtime=\" + endtime + \", profit=\" + profit + \"]\";\n        }\n​\n        @Override\n        public int compareTo(JobInfo o) {\n            // TODO Auto-generated method stub\n            return this.endtime - o.endtime;\n        }\n    }\n​\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\n        int n = startTime.length;\n        List\u003cJobInfo\u003e jobs = new ArrayList();\n        for (int i = 0; i \u003c n; i++) {\n            jobs.add(new JobInfo(startTime[i], endTime[i], profit[i]));\n        }\n        Collections.sort(jobs);\n​\n        System.out.println(jobs);\n        int[] dp = new int[n + 1];\n        dp[0] = jobs.get(0).profit;\n        for (int i = 1; i \u003c n; i++) {\n            dp[i] = Math.max(dp[i - 1], jobs.get(i).profit);\n            for (int j = i - 1; j \u003e= 0; j--) {\n                if (jobs.get(j).endtime \u003c= jobs.get(i).starttime) {\n                    dp[i] = Math.max(dp[i], jobs.get(i).profit + dp[j]);\n                    break;\n                }\n            }\n        }\n        return dp[n - 1];\n    }\n}\n"},{"id":"219","name":" Contains Duplicate II","language":"java","code":"class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        return this.containsNearbyDuplicate(nums, k, 0);\n    }\n​\n    private boolean easyWithHashMap(int[] nums, int k) {\n        Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); // \u003cval, index\u003e\n        for (int i = 0; i \u003c nums.length; i++) {\n            int val = nums[i];\n            // check if val present in map\n            if (map.containsKey(val)) {\n                int diff = Math.abs(map.get(val) - i);\n                if (diff \u003c= k) {\n                    return true;\n                }\n            }\n​\n            map.put(val, i);\n        }\n        return false;\n    }\n​\n    private boolean containsNearbyDuplicate(int[] nums, int k, int curindex) {\n        if (curindex \u003e= nums.length)\n            return false;\n​\n        for (int i = curindex + 1; i \u003c curindex + k + 1; i++) {\n            if (i \u003e= nums.length) break;\n            int e1 = nums[curindex];\n            int e2 = nums[i];\n            if (e1 == e2)\n                return true;\n        }\n​\n        boolean rres = this.containsNearbyDuplicate(nums, k, curindex + 1);\n        if (rres)\n            return true;\n​\n        return false;\n    }\n}\n"},{"id":"205","name":" Isomorphic Strings","language":"java","code":"class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n​\n        // HashMap to store the mapping of characters from s to t\n        HashMap\u003cCharacter, Character\u003e map = new HashMap\u003c\u003e();\n        // HashSet to store the mapping of characters from t to s\n        HashSet\u003cCharacter\u003e set = new HashSet\u003c\u003e();\n​\n        for (int i = 0; i \u003c s.length(); i++) {\n            char sChar = s.charAt(i);\n            char tChar = t.charAt(i);\n            if (map.containsKey(sChar)) {\n                if (map.get(sChar) != tChar) {\n                    return false;\n                }\n            } else {\n                if (set.contains(tChar)) {\n                    return false;\n                }\n                map.put(sChar, tChar);\n                set.add(tChar);\n            }\n        }\n        return true;\n    }\n}\n"},{"id":"41","name":" First Missing Positive","language":"java","code":"class Solution {\n    // leetcode 41. https://leetcode.com/problems/first-missing-positive/\n    public int firstMissingPositive(int[] nums) {\n        int n = nums.length;\n        // step 1. find occurence of one and mark out of range element\n        boolean one = false;\n        for(int i = 0; i \u003c n; i++) {\n            if(nums[i] == 1) one = true;\n​\n            if(nums[i] \u003c 1 || n \u003c nums[i]) {\n                nums[i] = 1;\n            }\n        }\n        if(one == false) return 1;\n        // step 2. mark element in array\n        for(int i = 0; i \u003c n; i++) {\n            int val = Math.abs(nums[i]);\n            int indx = val - 1;\n            nums[indx] = -Math.abs(nums[indx]);\n        }\n​\n        // step 3. check first missing positive\n        for(int i = 0; i \u003c n; i++) {\n            if(nums[i] \u003e 0) {\n                return i + 1;\n            }\n        }\n        return n + 1;\n    }\n​\n}\n"},{"id":"146","name":" LRU Cache","language":"java","code":"class LRUCache {\n​\n    private HashMap\u003cInteger, Integer\u003e cache = null;\n    private int capacity = 0;\n    public LRUCache(int capacity) {\n            this.cache = new LinkedHashMap\u003c\u003e(capacity);\n            this.capacity = capacity;\n        }\n        \n        public int get(int key) {\n            if(this.cache.containsKey(key)) {\n                int val = cache.get(key);\n                this.cache.remove(key);\n                this.cache.put(key, val);\n                return val;\n            }\n            return -1;\n        }\n        \n        public void put(int key, int value) {\n            if (cache.containsKey(key)) {\n                this.cache.remove(key);\n            } else if(this.cache.size() == this.capacity) this.cache.remove(this.cache.keySet().iterator().next());\n            this.cache.put(key, value);\n        }\n}\n​\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n"},{"id":"2299","name":" Strong Password Checker II","language":"java","code":"class Solution {\n    public boolean strongPasswordCheckerII(String password) {\n        int n=password.length();\n        if (n\u003c8)\n            return false;\n        boolean lower=false, upper=false, digit=false,special=false;\n        String special_chars=\"!@#$%^\u0026*()-+\";\n        for (char c : password.toCharArray()) {\n            if (c \u003e= 'A' \u0026\u0026 c \u003c= 'Z') upper=true;\n            if (c \u003e= 'a' \u0026\u0026 c \u003c= 'z') lower=true;\n            if (c \u003e= '0' \u0026\u0026 c \u003c= '9') digit=true;\n            for (char sp : special_chars.toCharArray())\n                if (c == sp) {\n                    special = true;\n                    break;\n                }\n        }\n        if (!lower || !upper || !digit || !special) return false;\n        \n        for (int i=1;i\u003cn;i++){\n            if (password.charAt(i)==password.charAt(i-1)) return false;\n        }\n        return true;\n    }\n}\n"},{"id":"22","name":" Generate Parentheses","language":"java","code":"class Solution {\n    private List\u003cString\u003e lists = new ArrayList\u003cString\u003e();\n    public List\u003cString\u003e generateParenthesis(int n) {\n        _generateParenthesis(\"\",0,0,n);\n        return this.lists;\n    }\n    \n    private void _generateParenthesis(String s, int openCount, int closeCount, int n) {\n        \n        if (closeCount \u003e openCount)\n            return ;\n        \n        if (openCount == closeCount \u0026\u0026 s.length() == 2*n){\n            this.lists.add(s);\n            return ;\n        }\n        \n        // faith\n        if (openCount \u003c= n)\n            _generateParenthesis(s + \"(\", openCount + 1, closeCount, n);\n        \n        if (openCount \u003e closeCount)\n        _generateParenthesis(s + \")\" , openCount, closeCount + 1, n);\n    }\n}\n"},{"id":"1239","name":" Maximum Length of a Concatenated String with Unique Characters","language":"java","code":"class Solution {\n    private int globalMaxlength = 0;\n​\n    public int maxLength(List\u003cString\u003e arr) {\n        if (arr.size() == 0 || arr == null)\n            return 0;\n​\n        this._maxlength(arr, \"\", 0);\n        return globalMaxlength;\n    }\n​\n    private int _maxlength(List\u003cString\u003e arr, String asf, int curindex) {\n        boolean isUniq = this.isAllCharactersUniq(asf, \"\");\n        if (!isUniq) {\n            return 0;\n        }\n​\n        globalMaxlength = Math.max(globalMaxlength, asf.length());\n        for (int i = curindex; i \u003c arr.size(); i++) {\n            String t = arr.get(i);\n            this._maxlength(arr, asf + t, i + 1);\n        }\n​\n        return globalMaxlength;\n    }\n​\n    public int maxLength2(List\u003cString\u003e arr) {\n        if (arr.size() == 1) {\n            if (isAllCharactersUniq(arr.get(0), \"\")) {\n                return arr.get(0).length();\n            }\n        }\n​\n        int globalMaxlength = 0;\n        for (int i = 0; i \u003c arr.size(); i++) {\n            StringBuilder sb = new StringBuilder(arr.get(i));\n            if (isAllCharactersUniq(sb.toString(), \"\")) {\n                globalMaxlength = Math.max(globalMaxlength, sb.length());\n            }\n            for (int j = i + 1; j \u003c arr.size(); j++) {\n                String candidate = arr.get(j);\n                if (isAllCharactersUniq(sb.toString(), candidate)) {\n                    sb.append(candidate);\n                    System.out.println(sb.toString());\n                    globalMaxlength = Math.max(globalMaxlength, sb.length());\n                }\n            }\n        }\n        return globalMaxlength;\n    }\n​\n    private boolean isAllCharactersUniq(String s, String candidate) {\n        Set\u003cCharacter\u003e set = new HashSet\u003c\u003e();\n        for (char c : s.toCharArray())\n            set.add(c);\n        for (char c : candidate.toCharArray())\n            set.add(c);\n​\n        int finalStringLength = s.length() + candidate.length();\n​\n        return set.size() == finalStringLength;\n    }\n}\n​\n"},{"id":"622","name":" Design Circular Queue","language":"java","code":"class MyCircularQueue {\n​\n    int[] queue;\n    int size;\n    int used;\n    int front;\n    int rear;\n    \n    public MyCircularQueue(int k) {\n        queue = new int[k];\n        size = k;\n    }\n    \n    public boolean enQueue(int value) {\n        if(isFull())\n            return false;\n        queue[rear] = value;\n        rear = (rear+1)%size;\n        used++;\n        return true;\n    }\n    \n    public boolean deQueue()\n    {\n        if(isEmpty())\n            return false;\n        front = (front+1)%size;\n        used -- ;\n        return true;\n        \n    }\n    \n    public int Front() {\n        if(isEmpty())\n            return -1;\n        return queue[front];\n    }\n    \n    public int Rear() {\n        if(isEmpty())\n            return -1;\n        return queue[(rear-1+size)%size];\n    }\n    \n    public boolean isEmpty() {\n        return used ==0;\n    }\n    \n    public boolean isFull() {\n        return used == size;\n    }\n}\n"},{"id":"206","name":" Reverse Linked List","language":"cpp","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n​\nusing Node = ListNode;\n​\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* root) {\n        if(root == NULL or root-\u003enext == NULL){\n            return root;\n        }\n        Node* nroot = reverseList(root-\u003enext);\n        root-\u003enext-\u003enext = root;\n        root-\u003enext = NULL;\n        return nroot;\n    }\n};\n"},{"id":"1465","name":" Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts","language":"java","code":"class Solution {\n    private final int mod = (int) 1e9 + 7;\n​\n    public int maxArea(int h, int w, int[] horizontalCuts, int[] verticalCuts) {\n        Arrays.sort(horizontalCuts);\n        Arrays.sort(verticalCuts);\n​\n        final int hcn = horizontalCuts.length;\n        final int vcn = verticalCuts.length;\n​\n        int maxheight = Math.max(horizontalCuts[0], h - horizontalCuts[hcn - 1]);\n        int maxvertical = Math.max(verticalCuts[0], w - verticalCuts[vcn - 1]);\n​\n        for (int i = 1; i \u003c hcn; i++) {\n            maxheight = Math.max(maxheight, horizontalCuts[i] - horizontalCuts[i - 1]);\n        }\n​\n        for (int i = 1; i \u003c vcn; i++) {\n            maxvertical = Math.max(maxvertical, verticalCuts[i] - verticalCuts[i - 1]);\n        }\n​\n        int possibleMaxArea = (int) (1L * maxheight * maxvertical) % mod;\n        return possibleMaxArea;\n    }\n}\n​\n"},{"id":"124","name":" Binary Tree Maximum Path Sum","language":"java","code":"class Solution {\n    int sm = Integer.MIN_VALUE;;\n​\n    public int maxPathSum(TreeNode root) {\n        solver(root);\n        return sm;\n    }\n​\n    private int solver(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n​\n        int leftsum = Math.max(0,solver(root.left));\n        int rightsum = Math.max(0,solver(root.right));\n​\n        int mypathsum = leftsum + rightsum + root.val;\n        this.sm = Math.max(this.sm, mypathsum);\n        return Math.max(leftsum, rightsum) + root.val;\n    }\n}\n"},{"id":"210","name":" Course Schedule II","language":"java","code":"class Solution {\n    private enum NodeStatus {UNTOUCHED, IN_PROGRESS, COMPLETED};\n\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        List[] graph = getGraph(numCourses, prerequisites);\n        // System.out.println(Arrays.toString(graph));\n\n        /**\n         * if cycle in DAG return empty[],\n         * because pre-req cannot be completed\n         *\n         * it is impossible to finish all courses, return an empty array.\n         */\n\n        NodeStatus[] tracking = new NodeStatus[numCourses];\n        Arrays.fill(tracking, NodeStatus.UNTOUCHED);\n\n        for (int node = 0; node \u003c graph.length; node++) {\n            if (isCompletlyDiscovered(tracking[node], NodeStatus.UNTOUCHED)) {\n                if (isCyclic(graph, node, tracking)){\n                    return new int[]{};\n                }\n            }\n        }\n\n        /**\n         * find the dependency array\n         * by finding the topological ordering of nodes\n         */\n\n        Stack\u003cInteger\u003e topologicalOrdering = new Stack\u003c\u003e();\n        boolean[] visited = new boolean[numCourses];\n        for (int node = 0; node \u003c graph.length; node++) {\n            if (visited[node]==false) {\n                findTopologicalOrder(graph, node, visited, topologicalOrdering);\n            }\n        }\n        \n        int[] answer = new int[topologicalOrdering.size()];\n        \n        int index = 0;\n        while (topologicalOrdering.isEmpty()==false) {\n            int v = topologicalOrdering.pop();\n            answer[index] = v;\n            index++;\n        }\n        \n        return answer;\n    }\n\n    private void findTopologicalOrder(List\u003cInteger\u003e[] graph, int node, boolean[] visited, Stack\u003cInteger\u003e topologicalOrdering) {\n        visited[node] = true;\n        for (int v : graph[node]) {\n            if (!visited[v]) {\n                findTopologicalOrder(graph, v, visited, topologicalOrdering);\n            }\n        }\n        topologicalOrdering.add(node);\n    }\n\n    private boolean isCyclic(List\u003cInteger\u003e[] graph, int node, NodeStatus[] tracking) {\n        if (isCompletlyDiscovered(tracking[node], NodeStatus.COMPLETED)) return false;\n        if(isInProgress(tracking[node], NodeStatus.IN_PROGRESS)) return true;\n\n        tracking[node] = NodeStatus.IN_PROGRESS;\n        for (int adjNode : graph[node]) {\n            boolean rres = isCyclic(graph, adjNode, tracking);\n            if (rres) return true;\n        }\n        tracking[node] = NodeStatus.COMPLETED;\n        return false;\n    }\n\n    private boolean isInProgress(NodeStatus nodeStatus, NodeStatus inProgress) {\n        return nodeStatus == inProgress;\n    }\n\n    private boolean isCompletlyDiscovered(NodeStatus nodeStatus, NodeStatus completed) {\n        return nodeStatus == completed;\n    }\n\n    private List[] getGraph(int numCourses, int[][] prerequisites) {\n        List[] graph = new List[numCourses];\n        for (int i = 0; i \u003c graph.length; i++) {\n            graph[i] = new ArrayList\u003cInteger\u003e();\n        }\n\n        for (int[] nodes : prerequisites) {\n            int firstNode = nodes[0];\n            int secondNode = nodes[1];\n\n            // second --\u003e first\n            graph[secondNode].add(firstNode);\n        }\n        return graph;\n    }\n}\n"},{"id":"623","name":" Add One Row to Tree","language":"java","code":"class Solution {\n    public TreeNode addOneRow(TreeNode root, int val, int depth) {\n        \n         if(depth == 1)\n         {\n             TreeNode newRoot = new TreeNode(val, root, null);\n             return newRoot;\n         }\n        \n        helper(root, val, depth-1);\n        \n        return root;\n    }\n    \n    public void helper(TreeNode root, int val, int depth)\n    {\n        if(root == null)\n        {\n            return;\n        }\n        \n        if(depth == 1)\n        {\n            TreeNode newLeftTree = new TreeNode(val, root.left, null);\n            TreeNode newRightTree = new TreeNode(val, null, root.right);\n            root.left = newLeftTree;\n            root.right = newRightTree;\n             return;\n        }\n        \n        helper(root.left, val, depth-1);\n        helper(root.right, val, depth-1);\n    }\n}\n"},{"id":"23","name":" Merge k Sorted Lists","language":"cpp","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector\u003cListNode*\u003e\u0026 lists) {\n        if(lists.empty()) {\n            return nullptr;\n        }\n        ListNode* root = new ListNode(-1);\n        ListNode* temp = root;\n        while(1) {\n            int curr = 0;\n            for(int i = 0; i \u003c lists.size(); i++) {\n                if(lists[curr]==nullptr || (lists[i]!=nullptr \u0026\u0026 lists[curr]-\u003eval \u003e lists[i]-\u003eval)) {\n                    curr=i;\n                }\n            }\n            if(lists[curr]==nullptr)\n                break;\n            temp-\u003enext = lists[curr];\n            temp = temp-\u003enext;\n            lists[curr]=lists[curr]-\u003enext;\n        }\n        return root-\u003enext;\n    }\n};\n"},{"id":"1472","name":" Design Browser History","language":"cpp","code":"class BrowserHistory {\npublic:\n    stack\u003cstring\u003e history;\n    stack\u003cstring\u003e future;\n    \n    BrowserHistory(string homepage) {\n        history.push(homepage);\n        future = stack\u003cstring\u003e();           // Reset the forward stack.\n    }\n    \n    void visit(string url) {\n        history.push(url);\n        future = stack\u003cstring\u003e();           // Reset the forward stack.\n    }\n    \n    string back(int steps) {\n        while(steps \u003e 0 \u0026\u0026 history.size() \u003e 1) { // Always keep at least one element in the stack. \n            future.push(history.top());\n            history.pop();\n            steps--;\n        }\n        return history.top();\n    }\n    \n    string forward(int steps) {\n        while(steps \u003e 0 \u0026\u0026 future.size() \u003e 0) {\n            history.push(future.top());\n            future.pop();\n            steps--;\n        }\n        return history.top();\n    }\n};\n​\n/**\n * Your BrowserHistory object will be instantiated and called as such:\n * BrowserHistory* obj = new BrowserHistory(homepage);\n * obj-\u003evisit(url);\n * string param_2 = obj-\u003eback(steps);\n * string param_3 = obj-\u003eforward(steps);\n */\n"},{"id":"412","name":" Fizz Buzz","language":"cpp","code":"class Solution {\npublic:\n    vector\u003cstring\u003e fizzBuzz(int n) {\n        vector\u003cstring\u003e ans ;\n        \n        for(int i = 1; i \u003c n + 1; i++){\n            if(i % 3 == 0 \u0026\u0026 (i % 5 != 0) ){\n                ans.push_back(\"Fizz\");\n            }else if(i % 5 == 0 \u0026\u0026 (i % 3 != 0)){\n                ans.push_back(\"Buzz\");\n            }else if (i % 15 == 0) {\n                ans.push_back(\"FizzBuzz\");\n            }else{\n                ans.push_back(to_string(i));\n            }\n        }\n        return ans;\n    }\n};\n"},{"id":"2225","name":" Find Players With Zero or One Losses","language":"java","code":"class Solution {\n    private class MatchInfo {\n        int winner;\n        int losser;\n\n        public MatchInfo(int winner, int losser) {\n            super();\n            this.winner = winner;\n            this.losser = losser;\n        }\n\n        @Override\n        public String toString() {\n            return \"MatchInfo [winner=\" + winner + \", losser=\" + losser + \"]\";\n        }\n    }\n\n    private class MatchResult {\n        public List\u003cInteger\u003e allWinners;\n        public List\u003cInteger\u003e oneLosses;\n\n        public MatchResult() {\n            // TODO Auto-generated constructor stub\n            this.allWinners = new ArrayList\u003c\u003e();\n            this.oneLosses = new ArrayList\u003c\u003e();\n        }\n\n        public List\u003cList\u003cInteger\u003e\u003e toList() {\n            List\u003cList\u003cInteger\u003e\u003e arr = new ArrayList\u003c\u003e();\n            arr.add(new ArrayList\u003c\u003e(this.allWinners));\n            arr.add(new ArrayList\u003c\u003e(this.oneLosses));\n            return arr;\n        }\n    }\n\n    private class DependencyGraph {\n        public Vertex[] vertices;\n\n        public DependencyGraph(int N) {\n            // TODO Auto-generated constructor stub\n            this.vertices = new Vertex[N];\n        }\n    }\n\n    private class Vertex {\n        public int value;\n        public int losses;\n\n        public Vertex(int value, int losses) {\n            super();\n            this.value = value;\n            this.losses = losses;\n        }\n    }\n\n    public List\u003cList\u003cInteger\u003e\u003e findWinners(int[][] m) {\n        List\u003cMatchInfo\u003e matches = new ArrayList\u003c\u003e();\n        for (int[] mm : m) {\n            matches.add(new MatchInfo(mm[0], mm[1]));\n        }\n        DependencyGraph graph = buildDependencyGraph(matches);\n        MatchResult matchResult = new MatchResult();\n        for (Vertex node : graph.vertices) {\n            if (node.losses == 0) {\n                matchResult.allWinners.add(node.value);\n            } else if (node.losses == 1) {\n                matchResult.oneLosses.add(node.value);\n            }\n        }\n\n        List\u003cList\u003cInteger\u003e\u003e result = matchResult.toList();\n        return result;\n    }\n\n    private DependencyGraph buildDependencyGraph(List\u003cMatchInfo\u003e matches) {\n        // TODO Auto-generated method stub\n        Map\u003cInteger, Integer\u003e map = new TreeMap\u003c\u003e(); // \u003cnode, loss\u003e\n        for (MatchInfo matchInfo : matches) {\n            map.putIfAbsent(matchInfo.winner, 0);\n            map.putIfAbsent(matchInfo.losser, 0);\n            map.put(matchInfo.losser, map.get(matchInfo.losser) + 1);\n        }\n        DependencyGraph dp = new DependencyGraph(map.size());\n        int index = 0;\n        for (Map.Entry\u003cInteger, Integer\u003e kv : map.entrySet()) {\n            dp.vertices[index] = new Vertex(kv.getKey(), kv.getValue());\n            index++;\n        }\n        return dp;\n    }\n}\n"},{"id":"211","name":" Design Add and Search Words Data Structure","language":"java","code":"import java.util.Arrays;\n\nclass WordDictionary {\n\n    private static class TrieNode {\n        char character;\n        TrieNode[] children;\n        boolean isEndofWord;\n\n        public TrieNode(char c) {\n            this.character = c;\n            this.children = new TrieNode[26];\n            this.isEndofWord = false;\n\n            Arrays.fill(children, null);\n        }\n    }\n\n    private static class Trie {\n        private TrieNode trieRootNode;\n\n        public Trie() {\n            this.trieRootNode = new TrieNode('\\0');\n        }\n\n        public void add(String word) {\n            char[] letters = word.toCharArray();\n            TrieNode current = this.trieRootNode;\n            for (char letter : letters) {\n                int index = letter - 'a';\n                if (current.children[index] == null) {\n                    current.children[index] = new TrieNode(letter);\n                }\n                current = current.children[index];\n            }\n            current.isEndofWord = true;\n        }\n\n        public boolean search(TrieNode trieRootNode, String word) {\n            TrieNode current = trieRootNode;\n            if (current == null)\n                return false;\n            char[] letters = word.toCharArray();\n            for (int index = 0; index \u003c letters.length; index++) {\n                char letter = letters[index];\n                if (letter == '.') {\n                    for (int ci = 0; ci \u003c current.children.length; ci++) {\n                        if (current.children[ci] == null)\n                            continue;\n\n                        if (search(current.children[ci], word.substring(index + 1)))\n                            return true;\n                    }\n                } else {\n                    int cindex = letter - 'a';\n                    if (current.children[cindex] == null)\n                        return false;\n                    current = current.children[cindex];\n                }\n            }\n\n            return (current != null) \u0026\u0026 current.isEndofWord;\n        }\n\n        private boolean searchUtil(WordDictionary.TrieNode current, String word) {\n            return (word != null \u0026\u0026 word.length() \u003e 0 \u0026\u0026 current != null) \u0026\u0026 search(current, word)\n                    \u0026\u0026 current.isEndofWord;\n        }\n    }\n\n    private Trie trie;\n\n    public WordDictionary() {\n        trie = new Trie();\n    }\n\n    public void addWord(String word) {\n        trie.add(word);\n    }\n\n    public boolean search(String word) {\n        return trie.search(trie.trieRootNode, word);\n    }\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */\n"},{"id":"628","name":" Maximum Product of Three Numbers","language":"java","code":"class Solution {\n    public int maximumProduct(int[] nums) {\n        return _maximumProduct(nums);\n    }\n    public int _maximumProduct(int[] nums) {\n        int min1 = Integer.MAX_VALUE;\n        int min2 = Integer.MAX_VALUE;\n​\n        int max1 = Integer.MIN_VALUE;\n        int max2 = Integer.MIN_VALUE;\n        int max3 = Integer.MIN_VALUE;\n​\n        for(int val : nums) {\n            if(val \u003e max1) {\n                max3 = max2;\n                max2 = max1;\n                max1 = val;\n            } else if(val \u003e max2) {\n                max3 = max2;\n                max2 = val;\n            } else if(val \u003e max3) {\n                max3 = val;\n            }\n            if(val \u003c min1) {\n                min2 = min1;\n                min1 = val;\n            } else if(val \u003c min2) {\n                min2 = val;\n            }\n        }\n        return Math.max(max1 * min1 * min2, max1 * max2 * max3);\n    }\n}\n"},{"id":"206","name":" Reverse Linked List","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null) return head;\n        return iterativeReverse(head);\n    }\n    public ListNode iterativeReverse(ListNode node) {\n        ListNode previous = null;\n        ListNode current = node;\n        while (current != null) {\n            ListNode nextnode = current.next;\n            current.next = previous;\n            previous = current;\n            current = nextnode;\n        }\n        return previous;\n    }\n    public ListNode recursiveReverse(ListNode node) {\n        if (node.next==null)\n            return node;\n\n        ListNode newhead = recursiveReverse(node.next);\n        node.next.next = node;\n        node.next = null;\n\n        return newhead;\n    }\n}\n"},{"id":"415","name":" Add Strings","language":"java","code":"class Solution {\n    public String addStrings(String num1, String num2) {\n        char[] arr1 = reverse(num1.toCharArray());\n        char[] arr2 = reverse(num2.toCharArray());\n​\n        int n = (arr1.length \u003e arr2.length) ? arr1.length : arr2.length;\n        StringBuilder sb = new StringBuilder();\n        int carry = 0;\n​\n        for (int i = 0; i \u003c n; i++) {\n            int elem1 = (i \u003c arr1.length) ? toNumber(arr1[i]) : 0;\n            int elem2 = (i \u003c arr2.length) ? toNumber(arr2[i]) : 0;\n            int total = elem1 + elem2 + carry;\n​\n            if (total \u003e= 10) {\n                carry = 1;\n                total = total - 10;\n            } else {\n                carry = 0;\n            }\n​\n            sb.append(total);\n        }\n        if (carry \u003e 0)\n            sb.append(carry);\n        return sb.reverse().toString();\n    }\n​\n    private char[] reverse(char[] arr) {\n        // TODO Auto-generated method stub\n        int lo = 0;\n        int hi = arr.length - 1;\n        while (lo \u003c hi) {\n            char c = arr[lo];\n            arr[lo] = arr[hi];\n            arr[hi] = c;\n            lo++;\n            hi--;\n        }\n        return arr;\n    }\n​\n    private int toNumber(char x) {\n        return (int) (x - '0');\n    }\n}\n​\n"},{"id":"125","name":" Valid Palindrome","language":"py","code":"class Solution:\n    def isPalindrome(self, s: str) -\u003e bool:\n        punc = '''!()-[]{};`:'\"\\, \u003c\u003e./?@#$%^\u0026*_~'''\n        s = s.lower()\n        s.replace(\" \", '')\n        for x in s:\n            if x in punc:\n                s = s.replace(x, \"\")\n        return s[::-1] == s\n"},{"id":"224","name":" Basic Calculator","language":"py","code":"class Solution:\n    def calculate(self, s: str) -\u003e int:\n        sums = 0\n        i = 0\n        sign = 1\n        stack = []\n        length = len(s)\n        while i\u003clength:\n            char = s[i]\n            if char.isdigit():\n                val = 0\n                while i\u003clength and s[i].isdigit():\n                    val = val*10 + int(s[i])\n                    i+=1\n                i-=1\n                sums+=val*sign\n                sign = 1\n            elif char == '(':\n                stack.append(sums)\n                stack.append(sign)\n                sums,sign = 0,1\n            elif char == ')':\n                sums*=stack.pop()\n                sums+=stack.pop()\n            elif char =='-':\n                sign*=-1\n            i+=1\n            \n        return sums\n"},{"id":"213","name":" House Robber II","language":"java","code":"class Solution {\n    public int rob(int[] nums) {\n        if (nums.length==1) return nums[0];\n        return Math.max(func(nums, 1, nums.length), func(nums, 0, nums.length - 1));\n    }\n​\n    private int func(int[] nums, int i, int length) {\n        // TODO Auto-generated method stub\n        int[] arr = Arrays.copyOfRange(nums, i, length);\n        // System.out.println(Arrays.toString(arr));\n        return rob2(arr);\n    }\n​\n    private int rob2(int[] nums) {\n        int n = nums.length;\n        if (n \u003c= 2) {\n            if (n == 1)\n                return nums[0];\n            return Math.max(nums[0], nums[1]);\n        }\n​\n        int MIN_LIMIT = (Integer.MIN_VALUE + 1);\n        int[] dp = new int[n];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n        for (int i = 2; i \u003c n; i++) {\n            int consider = dp[i - 2] + nums[i];\n            int nonconsider = MIN_LIMIT;\n            for (int j = 0; j \u003c i; j++) {\n                nonconsider = Math.max(nonconsider, dp[j]);\n            }\n            dp[i] = Math.max(consider, nonconsider);\n        }\n        System.out.println(Arrays.toString(dp));\n        return dp[n - 1];\n    }\n​\n}\n​\n"},{"id":"207","name":" Course Schedule","language":"java","code":"class Solution {\n    private enum NodeStatus {UNTOUCHED, IN_PROGRESS, COMPLETED};\n\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        List[] graph = getGraph(numCourses, prerequisites);\n        // System.out.println(Arrays.toString(graph));\n\n        /**\n         * if cycle in DAG return empty[],\n         * because pre-req cannot be completed\n         *\n         * it is impossible to finish all courses, return an empty array.\n         */\n\n        NodeStatus[] tracking = new NodeStatus[numCourses];\n        Arrays.fill(tracking, NodeStatus.UNTOUCHED);\n\n        for (int node = 0; node \u003c graph.length; node++) {\n            if (isCompletlyDiscovered(tracking[node], NodeStatus.UNTOUCHED)) {\n                if (isCyclic(graph, node, tracking)){\n                    return new int[]{};\n                }\n            }\n        }\n\n        /**\n         * find the dependency array\n         * by finding the topological ordering of nodes\n         */\n\n        Stack\u003cInteger\u003e topologicalOrdering = new Stack\u003c\u003e();\n        boolean[] visited = new boolean[numCourses];\n        for (int node = 0; node \u003c graph.length; node++) {\n            if (visited[node]==false) {\n                findTopologicalOrder(graph, node, visited, topologicalOrdering);\n            }\n        }\n        \n        int[] answer = new int[topologicalOrdering.size()];\n        \n        int index = 0;\n        while (topologicalOrdering.isEmpty()==false) {\n            int v = topologicalOrdering.pop();\n            answer[index] = v;\n            index++;\n        }\n        \n        return answer;\n    }\n\n    private void findTopologicalOrder(List\u003cInteger\u003e[] graph, int node, boolean[] visited, Stack\u003cInteger\u003e topologicalOrdering) {\n        visited[node] = true;\n        for (int v : graph[node]) {\n            if (!visited[v]) {\n                findTopologicalOrder(graph, v, visited, topologicalOrdering);\n            }\n        }\n        topologicalOrdering.add(node);\n    }\n\n    private boolean isCyclic(List\u003cInteger\u003e[] graph, int node, NodeStatus[] tracking) {\n        if (isCompletlyDiscovered(tracking[node], NodeStatus.COMPLETED)) return false;\n        if(isInProgress(tracking[node], NodeStatus.IN_PROGRESS)) return true;\n\n        tracking[node] = NodeStatus.IN_PROGRESS;\n        for (int adjNode : graph[node]) {\n            boolean rres = isCyclic(graph, adjNode, tracking);\n            if (rres) return true;\n        }\n        tracking[node] = NodeStatus.COMPLETED;\n        return false;\n    }\n\n    private boolean isInProgress(NodeStatus nodeStatus, NodeStatus inProgress) {\n        return nodeStatus == inProgress;\n    }\n\n    private boolean isCompletlyDiscovered(NodeStatus nodeStatus, NodeStatus completed) {\n        return nodeStatus == completed;\n    }\n\n    private List[] getGraph(int numCourses, int[][] prerequisites) {\n        List[] graph = new List[numCourses];\n        for (int i = 0; i \u003c graph.length; i++) {\n            graph[i] = new ArrayList\u003cInteger\u003e();\n        }\n\n        for (int[] nodes : prerequisites) {\n            int firstNode = nodes[0];\n            int secondNode = nodes[1];\n\n            // second --\u003e first\n            graph[secondNode].add(firstNode);\n        }\n        return graph;\n    }\n}\n"},{"id":"23","name":" Merge k Sorted Lists","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    \n    private ListNode mergeNodes(ListNode one, ListNode two) {\n        ListNode head1 = one;\n        ListNode head2 = two;\n        \n        ListNode dummy = new ListNode(-1);\n        ListNode temp = dummy;\n        \n        while(head1 != null \u0026\u0026 head2 !=null) {\n            int data1 = head1.val;\n            int data2 = head2.val;\n            \n            if (data1 \u003c data2) {\n                temp.next = head1;\n                temp = temp.next;\n                head1 = head1.next;\n            } else {\n                temp.next = head2;\n                temp = temp.next;\n                head2 = head2.next;\n            }\n        }\n        \n        if (head1 != null) temp.next = head1;\n        if (head2 != null) temp.next = head2;\n        \n        return dummy.next;\n    }\n    \n    public ListNode mergeKLists(ListNode[] lists) {\n        \n        // VERY BAD SOLUTION\n        // AMORTIZED COMPLEXITY ~ O(N * K^2) ~ O(N^3) [if K is really Huge]\n//         ListNode res = null;\n//         for (int i = 0; i \u003c lists.length; i++) {\n//             if (lists[i] != null)\n//                 res = this.mergeNodes(lists[i], res);\n//         }\n        \n//         return res;\n    \n       \n        // GOOD AND OPTIMIZED SOLUTION\n        // TIME - O(N * kLongK) []\n        // SPACE - O(K) [size of k nodes]\n        PriorityQueue\u003cListNode\u003e priorityQueue = new PriorityQueue\u003c\u003e((a,b) -\u003e a.val - b.val);\n        for (ListNode node : lists)\n            if (node != null)\n                priorityQueue.add(node);   \n        \n        ListNode dummy = new ListNode(-1);\n        ListNode temp = dummy;\n        \n        while(priorityQueue.isEmpty()==false) {\n            ListNode t = priorityQueue.poll();\n            \n            if (t.next != null) priorityQueue.add(t.next);\n            \n            temp.next = t;\n            temp = temp.next;\n        }\n        \n        return dummy.next;\n    }\n}\n"},{"id":"630","name":" Course Schedule III","language":"java","code":"class Solution {\n    /*\n    \n    This is one of the correct solution as of my 1st intution to approch the problem\n    however; it's getting `TLE`; which is obious.\n    ---\n    \n    \n    public int scheduleCourse(int[][] courseee) {\n        Arrays.sort(courseee, (a, b) -\u003e b[1] \u003c a[1] ? 1 : -1);\n        return f(courseee, 0, 0);\n    }\n​\n    private int f(int[][] courses, int curIndex, int timeSpend){\n        if(curIndex == courses.length) return 0;\n​\n        int[] course = courses[curIndex];\n        int alreadyDone = 0;\n        if(timeSpend + course[0] \u003c= course[1])\n            alreadyDone = 1 + f(courses, curIndex+1, timeSpend + course[0]);\n​\n        // if we don't take up that course\n        int otherMax = f(courses, curIndex+1, timeSpend);\n        return Math.max(otherMax, alreadyDone);\n    }\n    */\n    \n    class Course {\n        int duration;\n        int lastDay;\n        Course(int d, int l){\n            this.duration = d;\n            this.lastDay = l;\n        }\n    }\n    public int scheduleCourse(int[][] courseee) {\n    Comparator\u003cCourse\u003e comp = (a, b) -\u003e a.lastDay - b.lastDay;\n        PriorityQueue\u003cCourse\u003e courses = new PriorityQueue\u003cCourse\u003e(courseee.length + 1, comp);\n        for(int[] c : courseee) {\n            courses.add(new Course(c[0], c[1]));\n        }\n        PriorityQueue\u003cInteger\u003e alreadyTaken = new PriorityQueue\u003c\u003e((a, b) -\u003e (b-a));\n        int time = 0;\n        for(Course course : courses) {\n            if(time+course.duration \u003c= course.lastDay) {\n                alreadyTaken.add(course.duration);\n                time += course.duration;\n            } else {\n                if (alreadyTaken.isEmpty()==false \u0026\u0026 alreadyTaken.peek() \u003e course.duration) {\n                    int x = alreadyTaken.poll();\n    time -= x;\n                    time += course.duration;\n                    alreadyTaken.add(course.duration);\n                }\n            }\n        }\n        return alreadyTaken.size();\n    }\n}\n"},{"id":"1472","name":" Design Browser History","language":"java","code":"class BrowserHistory {\n​\n    private static class NodeHead {\n        String url;\n        NodeHead previous;\n        NodeHead next;\n​\n        public NodeHead(String url, NodeHead previous, NodeHead next) {\n            super();\n            this.url = url;\n            this.previous = previous;\n            this.next = next;\n        }\n​\n    }\n​\n    private NodeHead urlsQueue;\n​\n    public BrowserHistory(String homepage) {\n        NodeHead currentSite = new NodeHead(homepage, null, null);\n        urlsQueue = currentSite;\n    }\n​\n    public void visit(String url) {\n        NodeHead currentSite = new NodeHead(url, urlsQueue, null);\n        urlsQueue.next = currentSite;\n        urlsQueue = currentSite;\n    }\n​\n    public String back(int steps) {\n        NodeHead current = urlsQueue;\n        while (current.previous != null \u0026\u0026 steps \u003e 0) {\n            current = current.previous;\n            steps -= 1;\n        }\n        if (current==null) return null;\n        urlsQueue=current;\n        return current.url;\n    }\n​\n    public String forward(int steps) {\n        NodeHead current = urlsQueue;\n        while (current.next != null \u0026\u0026 steps \u003e 0) {\n            current = current.next;\n            steps -= 1;\n        }\n        if (current==null) return null;\n        urlsQueue=current;\n        return current.url;\n    }\n}\n​\n/**\n * Your BrowserHistory object will be instantiated and called as such:\n * BrowserHistory obj = new BrowserHistory(homepage);\n * obj.visit(url);\n * String param_2 = obj.back(steps);\n * String param_3 = obj.forward(steps);\n */\n"},{"id":"416","name":" Partition Equal Subset Sum","language":"cpp","code":"class Solution {\npublic:\n    bool canPartition(vector\u003cint\u003e\u0026 nums) {\n         int sum = (int) accumulate(nums.begin(), nums.end(),0);\n        if(sum\u00261){\n            return false;\n        }else {\n            sum = (int) sum/2;\n            vector\u003cbool\u003e dp(sum+1);\n            dp[0] = true;\n            for(auto \u0026\u0026x : nums) {\n                // if sumX is present that means sumX-(something) also present\n                for(int i = sum; i \u003e= x; i--){\n                    dp[i] = dp[i] || dp[i-x] ;\n                }\n            }\n            // debug() \u003c\u003c imie(dp);\n            return dp.back();\n        }   \n    }\n};\n"},{"id":"213","name":" House Robber II","language":"py","code":"class Solution(object):\n    def rob(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        def simple_rob(nums):\n            rob, not_rob = 0, 0\n            for num in nums:\n                rob, not_rob = not_rob + num, max(rob, not_rob)\n            return max(rob, not_rob)\n        \n        if not nums:\n            return 0\n        elif len(nums) == 1:\n            return nums[0]\n        else:\n            return max(simple_rob(nums[1:]), simple_rob(nums[:-1]))\n"},{"id":"230","name":" Kth Smallest Element in a BST","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int count = 0;\n    public int kthSmallest(TreeNode root, int k) {\n        TreeNode node = kth(root, k);\n        return node.val;\n    }\n    \n    // with Constant Space -- O(1), TC = O(height)\n    private TreeNode kth(TreeNode root, int k) {\n        \n        if (root == null) return null;\n        \n        // faith\n        TreeNode rl = kth(root.left, k);\n        if (rl != null) return rl;\n        \n        this.count++;\n        if (count == k) return root;\n        \n        TreeNode rr = kth(root.right, k);\n        if (rr != null) return rr;\n        \n        return null;\n    }\n    \n     /*\n        jekono BST te inorder traverse korlei to sorted order pawa jai.\n        question ta meaning less, but practice concepts of BST\n        \n        inorder traverse korbo - automatic asc order node pabo,\n        simply nodes.get(k-1) korlei asha kori hye jabe!\n    */\n    private static ArrayList\u003cInteger\u003e nodes = new ArrayList\u003c\u003e();\n    public int kthSmallest2(TreeNode root, int k) {\n        performInOrderTraversal(root);\n        return nodes.get(k-1); // 0 based indexing\n    }\n    \n    private static void performInOrderTraversal(TreeNode root) {\n        if (root == null) return;\n        performInOrderTraversal(root.left);\n        nodes.add(root.val);\n        performInOrderTraversal(root.right);\n    }\n}\n"},{"id":"208","name":" Implement Trie (Prefix Tree)","language":"java","code":"import java.util.Arrays;\n\nclass Trie {\n\n    static class TrieNode {\n        char character;\n        boolean isEndOfWord = false;\n        TrieNode[] childrens;\n\n        public TrieNode(char character, boolean isEndOfWord) {\n            this.character = character;\n            this.isEndOfWord = isEndOfWord;\n            this.childrens = new TrieNode[26];\n            Arrays.fill(this.childrens, null);\n        }\n\n        @Override\n        public String toString() {\n            return \"TrieNode [character=\" + character + \", isEndOfWord=\" + isEndOfWord + \", childrens=\"\n                    + Arrays.toString(childrens) + \"]\";\n        }\n\n    }\n\n    private TrieNode root;\n\n    public Trie() {\n        this.root = new TrieNode('\\r', false);\n    }\n\n    public void insert(String word) {\n        char[] letters = word.toCharArray();\n        TrieNode temporalRoot = this.root;\n\n        for (char letter : letters) {\n            int letterIndex = letter - 'a';\n            if (temporalRoot.childrens[letterIndex] == null) {\n                temporalRoot.childrens[letterIndex] = new TrieNode(letter, false);\n            }\n            temporalRoot = temporalRoot.childrens[letterIndex];\n        }\n\n        temporalRoot.isEndOfWord = true;\n    }\n\n    public boolean search(String word) {\n        char[] letters = word.toCharArray();\n        TrieNode temporalRoot = this.root;\n\n        for (char letter : letters) {\n            int letterIndex = letter - 'a';\n            if (temporalRoot.childrens[letterIndex] == null)\n                return false;\n            temporalRoot = temporalRoot.childrens[letterIndex];\n        }\n\n        return temporalRoot.isEndOfWord;\n    }\n\n    public boolean startsWith(String word) {\n        char[] letters = word.toCharArray();\n        TrieNode temporalRoot = this.root;\n\n        for (char letter : letters) {\n            int letterIndex = letter - 'a';\n            if (temporalRoot.childrens[letterIndex] == null)\n                return false;\n            temporalRoot = temporalRoot.childrens[letterIndex];\n        }\n\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Trie [root=\" + root + \"]\";\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */\n"},{"id":"148","name":" Sort List","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) return head;\n        \n        ListNode mid_node = getMidOf(head);\n        ListNode start = head;\n        ListNode end = mid_node.next;\n        mid_node.next = null;\n        \n        start = sortList(start);\n        end = sortList(end);\n        \n        ListNode merged_list = mergeList(start, end);\n        return  merged_list;\n    }\n​\n    private ListNode mergeList(ListNode start, ListNode end) {\n        ListNode t1 = start;\n        ListNode t2 = end;\n        \n        ListNode dummy = new ListNode(-1);\n        ListNode tmp = dummy;\n        \n        while (t1 != null \u0026\u0026 t2 != null) {\n            int a = t1.val;\n            int b = t2.val;\n            \n            if (a \u003c b) {\n                tmp.next = t1;\n                t1 = t1.next;\n            } else {\n                tmp.next = t2;\n                t2 = t2.next;\n            }\n            tmp = tmp.next;\n        }\n        \n        if (t1 != null) tmp.next = t1;\n        if (t2 != null) tmp.next = t2;\n        \n        return dummy.next;\n    }\n​\n    private ListNode getMidOf(ListNode head) {\n        ListNode slow_pointer = head;\n        ListNode fast_pointer = head;\n        \n        while (fast_pointer.next != null \u0026\u0026 fast_pointer.next.next != null) {\n            slow_pointer = slow_pointer.next;\n            fast_pointer = fast_pointer.next.next;\n        }\n        \n        return slow_pointer;\n    }\n}\n"},{"id":"2244","name":" Minimum Rounds to Complete All Tasks","language":"java","code":"class Solution {\n    public int minimumRounds(int[] tasks) {\n        int count = 0; HashMap\u003cInteger,Integer\u003e map = new HashMap\u003c\u003e();\n        for(int x : tasks)\n            map.put(x,map.getOrDefault(x,0)+1);\n        for(int x : map.keySet())\n            if(map.get(x)==1)return -1;\n            else{\n                count+=map.get(x)/3;\n                if(map.get(x)%3!=0)count++;\n            }\n        return count;\n    }\n}\n"},{"id":"637","name":" Average of Levels in Binary Tree","language":"java","code":"class Solution {\n    public List\u003cDouble\u003e averageOfLevels(TreeNode root) {\n        List\u003cDouble\u003e rslt = new ArrayList\u003cDouble\u003e();\n        \n        Queue\u003cTreeNode\u003e q = new LinkedList\u003c\u003e();\n        q.offer(root);\n        \n        while (!q.isEmpty()){\n            int sz = q.size();\n            long cursum = 0, numval = 0;\n            while (sz-- \u003e 0){\n                TreeNode cur = q.poll();\n                cursum += cur.val;\n                numval += 1;\n                \n                if (cur.left != null){\n                    q.offer(cur.left);\n                }\n                if (cur.right != null){\n                    q.offer(cur.right);\n                }\n            }\n            rslt.add( 1.0*cursum / numval);\n        }\n        return rslt;\n     }\n}\n"},{"id":"2136","name":" Earliest Possible Day of Full Bloom","language":"java","code":"class Solution {\n    private class PlantInfo implements Comparable\u003cPlantInfo\u003e {\n        int plantTime;\n        int growTime;\n​\n        public PlantInfo(int plantTime, int growTime) {\n            this.plantTime = plantTime;\n            this.growTime = growTime;\n        }\n​\n        @Override\n        public String toString() {\n            return \"PlantInfo [plantTime=\" + plantTime + \", growTime=\" + growTime + \"]\";\n        }\n​\n        @Override\n        public int compareTo(PlantInfo o) {\n            // TODO Auto-generated method stub\n            if (this.growTime == o.growTime) {\n                return o.plantTime - this.plantTime;\n            }\n            Integer pt = o.growTime;\n            return pt.compareTo(this.growTime);\n        }\n​\n    }\n​\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\n        List\u003cPlantInfo\u003e plants = new ArrayList\u003c\u003e();\n        for (int i = 0; i \u003c plantTime.length; i++) {\n            plants.add(new PlantInfo(plantTime[i], growTime[i]));\n        }\n​\n        int atleastDays = 0;\n        // Sort based on plattime and growtime\n        Collections.sort(plants);\n        // System.out.println(plants);\n​\n        for (int i = 0, plantsum = 0; i \u003c plants.size(); i++) {\n            PlantInfo plant = plants.get(i);\n            int elapsedTimeToBlossom = plant.plantTime + plant.growTime + plantsum;\n            atleastDays = Math.max(atleastDays, elapsedTimeToBlossom);\n            plantsum += plant.plantTime;\n        }\n​\n        return atleastDays;\n    }\n}\n"},{"id":"2300","name":" Successful Pairs of Spells and Potions","language":"java","code":"class Solution {\n    public int[] successfulPairs(int[] spells, int[] potions, long success) {\n        Arrays.sort(potions);\n        int n=potions.length;\n        int[] result=new int[spells.length];\n        for (int i=0;i\u003cspells.length;i++) {\n            int spell=spells[i];\n            int lo=0;\n            int hi=n-1;\n            int potion_index=n;\n            while (lo\u003c=hi){\n                int mid=(lo+hi)/2;\n                if ((long) spell * potions[mid] \u003e= success) {\n                    potion_index=mid;\n                    hi=mid-1;\n                }else {\n                    lo=mid+1;\n                }\n            }\n            int pair_count=n-potion_index;\n            result[i]=pair_count;\n        }\n        return result;\n    }\n}\n"},{"id":"1480","name":" Running Sum of 1d Array","language":"java","code":"class Solution {\n    public int[] runningSum(int[] nums) {\n        /*\n            Whatever it is -- running sum\n            The concept is only adding prefixSum[i-1] + currentElem of the array\n            and return the prefixSum[];\n        */\n        int[] prefixSum = new int[nums.length];\n        prefixSum[0] = nums[0];\n        for (int i = 1; i \u003c nums.length; i++)\n            prefixSum[i] += nums[i] + prefixSum[i-1];\n        return prefixSum;\n    }\n}\n"},{"id":"419","name":" Battleships in a Board","language":"cpp","code":"class Solution {\npublic:\n    \nvoid f(vector\u003cvector\u003cchar\u003e\u003e \u0026board, int row, int col) {\n    if(row \u003c 0 || col \u003c 0 || row \u003e= board.size() || col \u003e= board[row].size() || board[row][col] != 'X' ) {\n        return ;\n    }\n    \n    board[row][col] = '.';\n    f(board, row+1, col);\n    f(board, row-1, col);\n    f(board, row, col+1);\n    f(board, row, col-1);\n    \n    return ;\n}\n    \n    int countBattleships(vector\u003cvector\u003cchar\u003e\u003e\u0026 board) {\n        int ans = 0;\n        for(int row = 0; row \u003c (int) board.size(); row++) {\n            for(int col = 0; col \u003c (int) board[row].size(); col++) {\n                if(board[row][col] == 'X') {\n                    ans++;\n                    f(board, row, col);\n                }\n            }\n        }\n        return ans;\n    }\n};\n"},{"id":"226","name":" Invert Binary Tree","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n​\n// SIMPLE ALGO EXPERT ADVERTISEMENT PROBLEM. LOL \u003c3\n// XD\n​\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) return null ;\n        \n        TreeNode leftTree = invertTree(root.left);\n        TreeNode rightTree = invertTree(root.right);\n​\n        root.left = rightTree;\n        root.right = leftTree;\n        \n        return root;\n    }\n}\n"},{"id":"126","name":" Word Ladder II","language":"java","code":"// ## NOT Working Solution....\n// Really Hard. but how I can apply BFS Algorithm.\n// Getting No Clues ...........\n​\n​\nclass Solution {\n​\n    class Pair {\n        String value;\n        List\u003cString\u003e currentSeries;\n​\n        public Pair(String val, List\u003cString\u003e series) {\n            this.value = val;\n            this.currentSeries = new ArrayList\u003c\u003e(series);\n        }\n    }\n​\n    // Word Ladders - II\n    public List\u003cList\u003cString\u003e\u003e findLadders(String beginWord, String endWord, List\u003cString\u003e wordList) {\n        List\u003cList\u003cString\u003e\u003e result = new ArrayList\u003c\u003e();\n        if (wordList == null || wordList.size() == 0) {\n            return result;\n        }\n        HashMap\u003cString, HashSet\u003cString\u003e\u003e map = new HashMap\u003c\u003e();\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n        for (String word : wordList) {\n            map.put(word, set);\n        }\n        map.put(beginWord, set);\n        set.add(endWord);\n        HashMap\u003cString, HashSet\u003cString\u003e\u003e map2 = new HashMap\u003c\u003e();\n        HashSet\u003cString\u003e set2 = new HashSet\u003c\u003e();\n        for (String word : wordList) {\n            map2.put(word, set2);\n        }\n        map2.put(endWord, set2);\n        List\u003cString\u003e currentSeries = new ArrayList\u003c\u003e();\n        currentSeries.add(beginWord);\n        Pair pair = new Pair(beginWord, currentSeries);\n        List\u003cString\u003e nextSeries = new ArrayList\u003c\u003e();\n​\n        while (pair.currentSeries.size() \u003e 0) {\n            String word = pair.currentSeries.get(pair.currentSeries.size() - 1);\n            for (int i = 0; i \u003c word.length(); i++) {\n                for (char c = 'a'; c \u003c= 'z'; c++) {\n                    String newWord = word.substring(0, i) + c + word.substring(i + 1, word.length());\n                    if (map.containsKey(newWord)) {\n                        if (map.get(newWord).contains(endWord)) {\n                            List\u003cString\u003e list = new ArrayList\u003c\u003e(pair.currentSeries);\n                            list.add(newWord);\n                            result.add(list);\n                            return result;\n                        }\n                        map.get(newWord).add(endWord);\n                        map2.get(endWord).add(newWord);\n                        nextSeries.add(newWord);\n                    }\n                }\n            }\n            pair.currentSeries.remove(pair.currentSeries.size() - 1);\n            pair.currentSeries.addAll(nextSeries);\n            nextSeries.clear();\n        }\n        return result;\n    }\n}\n"},{"id":"209","name":" Minimum Size Subarray Sum","language":"java","code":"class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int left = 0;\n        int sum = 0;\n        int result_size = Integer.MAX_VALUE;\n​\n        for (int i = 0; i \u003c nums.length; i++) {\n            if (nums[i] \u003e= target) {\n                result_size = 1;\n                break;\n            } else {\n                sum += nums[i];\n                while (sum \u003e= target) {\n                    result_size = Math.min(result_size, i - left + 1);\n                    sum -= nums[left];\n                    left++;\n                }\n            }\n        }\n​\n        return result_size == Integer.MAX_VALUE ? 0 : result_size;\n    }\n}\n"},{"id":"2301","name":" Match Substring After Replacement","language":"java","code":"class Solution {\n    public boolean matchReplacement(String s, String sub, char[][] mappings) {\n        boolean[][] table=new boolean[256][256];\n        for (int i=0;i\u003c table.length;i++) table[i][i]=true;\n        for (char[] map:mappings){\n            int mapi=map[0];\n            int mapj=map[1];\n            table[mapi][mapj]=true;\n        }\n        \n        int n=s.length();\n        int m=sub.length();\n        for (int i=0;i\u003cn-m+1;i++){\n            // substring S[i:i+m+1]\n            String s_substring=s.substring(i,i+m);\n            boolean was_done=true;\n            for (int j=0;j\u003cm;j++){\n                int index_1=s_substring.charAt(j);\n                int index_2=sub.charAt(j);\n                if (!table[index_2][index_1]) {\n                    was_done=false;\n                    break;\n                }\n            }\n            if (was_done)\n                return true;\n        }\n        return false;\n    }\n}\n"},{"id":"227","name":" Basic Calculator II","language":"cpp","code":"            }\n             \n            values.push(val);\n             \n            // right now the i points to \n            // the character next to the digit,\n            // since the for loop also increases \n            // the i, we would skip one \n            //  token position; we need to \n            // decrease the value of i by 1 to\n            // correct the offset.\n              i--;\n        }\n         \n        // Closing brace encountered, solve \n        // entire brace.\n        else if(tokens[i] == ')')\n        {\n            while(!ops.empty() \u0026\u0026 ops.top() != '(')\n            {\n                int val2 = values.top();\n                values.pop();\n                 \n                int val1 = values.top();\n                values.pop();\n                 \n                char op = ops.top();\n                ops.pop();\n                 \n                values.push(applyOp(val1, val2, op));\n            }\n             \n            // pop opening brace.\n            if(!ops.empty())\n               ops.pop();\n        }\n         \n        // Current token is an operator.\n        else\n        {\n            // While top of 'ops' has same or greater \n            // precedence to current token, which\n            // is an operator. Apply operator on top \n            // of 'ops' to top two elements in values stack.\n            while(!ops.empty() \u0026\u0026 precedence(ops.top())\n                                \u003e= precedence(tokens[i])){\n"},{"id":"215","name":" Kth Largest Element in an Array","language":"cpp","code":"class Solution {\npublic:\n    int findKthLargest(vector\u003cint\u003e\u0026 nums, int k) {\n        priority_queue\u003cint, vector\u003cint\u003e\u003e q(nums.begin(), nums.end());\n        while(--k) {\n            q.pop();\n        }\n        return q.top();\n    }\n};\n"},{"id":"1268","name":" Search Suggestions System","language":"java","code":"class Solution {\n    // Time. O(NlogN + N * N) =\u003e O(N^2)\n    // Space. O(N)\n    public List\u003cList\u003cString\u003e\u003e suggestedProducts2(String[] products, String searchWord) {\n        Arrays.sort(products, String.CASE_INSENSITIVE_ORDER);\n​\n        List\u003cList\u003cString\u003e\u003e suggestedList = new ArrayList\u003c\u003e();\n​\n        for (int i = 0; i \u003c searchWord.length(); i++) {\n            String searchTerm = searchWord.substring(0, i + 1);\n​\n            List\u003cString\u003e matchedWords = Arrays.stream(products).filter(word -\u003e word.contains(searchTerm))\n                    .collect(Collectors.toList());\n​\n            if (matchedWords.size() \u003e 3)\n                suggestedList.add(matchedWords.subList(0, 3));\n            else\n                suggestedList.add(matchedWords);\n        }\n​\n        return suggestedList;\n    }\n​\n    // Time. O(NlogN + O(n`logn)) ~~\u003e O(n`log(n`)) ~~\u003e O(m^2)[I might -\u003e Java]\n    // Space. O(N)\n    public List\u003cList\u003cString\u003e\u003e suggestedProducts(String[] products, String searchWord) {\n        Arrays.sort(products, String.CASE_INSENSITIVE_ORDER);\n        \n        List\u003cList\u003cString\u003e\u003e suggestedList = new ArrayList\u003c\u003e();\n​\n        final int n = products.length;\n        int lo = 0;\n        int hi = n - 1;\n​\n        for (int i = 0; i \u003c searchWord.length(); i++) {\n            char currChar = searchWord.charAt(i);\n​\n            while ((lo \u003c= hi) \u0026\u0026 (products[lo].length() \u003c= i || products[lo].charAt(i) != currChar)) {\n                // word take consider korbo na!\n                lo++;\n            }\n​\n            while ((lo \u003c= hi) \u0026\u0026 (products[hi].length() \u003c= i || products[hi].charAt(i) != currChar)) {\n                // same hi word takeo consider korbo na\n                hi--;\n            }\n​\n            int min = Math.min(lo + 3, hi + 1);\n            List\u003cString\u003e curListAns = new ArrayList\u003c\u003e();\n            for (int j = lo; j \u003c min; j++) {\n                curListAns.add(products[j]);\n            }\n​\n            suggestedList.add(curListAns);\n        }\n​\n        return suggestedList;\n    }\n}\n"},{"id":"2095","name":" Delete the Middle Node of a Linked List","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteMiddle(ListNode head) {\n        if (head.next == null)\n            return null;\n        ListNode slow = head, fast = head.next.next;\n        while (fast != null \u0026\u0026 fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        slow.next = slow.next.next;\n        return head;\n    }\n}\n"},{"id":"232","name":" Implement Queue using Stacks","language":"java","code":"class MyQueue {\n    private Stack\u003cInteger\u003e primary;\n    private Stack\u003cInteger\u003e secondary;\n​\n    public MyQueue() {\n        primary = new Stack\u003c\u003e();\n        secondary = new Stack\u003c\u003e();\n    }\n​\n    public void push(int x) {\n        primary.push(x);\n    }\n​\n    public int pop() {\n        if (secondary.isEmpty()) {\n            while (!primary.isEmpty())\n                secondary.add(primary.pop());\n        }\n        return secondary.pop();\n    }\n​\n    public int peek() {\n        if (secondary.isEmpty()) {\n            while (!primary.isEmpty())\n                secondary.add(primary.pop());\n        }\n        return secondary.peek();\n    }\n​\n    public boolean empty() {\n        return primary.isEmpty() \u0026\u0026 secondary.isEmpty();\n    }\n}\n​\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n"},{"id":"1498","name":" Number of Subsequences That Satisfy the Given Sum Condition","language":"java","code":"import java.util.Arrays;\n​\nclass Solution {\n    private final int MOD = (int) (1e9 + 7);\n​\n    public int numSubseq(int[] nums, int target) {\n        // https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/\n        int n = nums.length;\n        Arrays.sort(nums);\n​\n        int left = 0;\n        int right = n - 1;\n​\n        int[] powers = new int[n+1];\n        for (int i = 0; i \u003c powers.length; i++) {\n            if (i==0) {\n                powers[i]=1;\n            } else {\n                powers[i] = (int) (powers[i-1] * 2) % MOD;\n            }\n        }\n​\n        int results = 0;\n​\n        while (left \u003c= right) {\n            int v1 = nums[left];\n            int v2 = nums[right];\n            int sum = v1 + v2;\n​\n            if (sum \u003c= target) {\n                int totalElems = (right - left);\n                results += (powers[totalElems] % MOD);\n                left++;\n            } else {\n                right--;\n            }\n        }\n​\n        return results;\n    }\n}\n"},{"id":"637","name":" Average of Levels in Binary Tree","language":"js","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar averageOfLevels = function (root) {\n  let result = [];\n​\n  const dfs = (root, level) =\u003e {\n    if (!root) return;\n​\n    dfs(root.left, level + 1);\n​\n    if (result[level]) {\n      result[level].push(root.val);\n    } else {\n      result[level] = [root.val];\n    }\n​\n    dfs(root.right, level + 1);\n  };\n​\n  dfs(root, 0);\n​\n  let avgs = result.map((arr, index) =\u003e {\n    let sum = 0;\n    arr.forEach((x) =\u003e (sum += x));\n    return sum / arr.length;\n  });\n  return avgs;\n};\n​\n"},{"id":"235","name":" Lowest Common Ancestor of a Binary Search Tree","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n​\nclass Solution {\n​\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null) {\n            return null;\n        }\n​\n        // to solve this problem we need to get the node to root path of both p and q\n        // if p and q are on the same side of root, then LCA is root\n​\n        // find the node p\n        List\u003cTreeNode\u003e nodepathP = find(root, p);\n        // find the node q\n        List\u003cTreeNode\u003e nodepathQ = find(root, q);\n​\n        TreeNode result = null;\n​\n        int i = nodepathP.size() - 1;\n        int j = nodepathQ.size() - 1;\n​\n        while (ensureNotOutOfBound(i, j) \u0026\u0026 matchBothNode(nodepathP, nodepathQ, i, j)) {\n            result = nodepathP.get(i);\n            i--;\n            j--;\n        }\n​\n        return result;\n    }\n​\n    private boolean matchBothNode(List\u003cTreeNode\u003e nodepathP, List\u003cTreeNode\u003e nodepathQ, int i, int j) {\n        return nodepathP.get(i) == nodepathQ.get(j);\n    }\n​\n    private boolean ensureNotOutOfBound(int i, int j) {\n        return i \u003e= 0 \u0026\u0026 j \u003e= 0;\n    }\n​\n    private List\u003cTreeNode\u003e find(TreeNode root, TreeNode node) {\n​\n        if (root == null)\n            return new ArrayList\u003c\u003e();\n​\n        if (root.val == node.val) {\n            List\u003cTreeNode\u003e bbres = new ArrayList\u003cTreeNode\u003e();\n            bbres.add(node);\n​\n            return bbres;\n        }\n​\n        List\u003cTreeNode\u003e nodepath = new ArrayList\u003cTreeNode\u003e();\n​\n        // faith\n        List\u003cTreeNode\u003e rresFromLeft = find(root.left, node);\n        if (rresFromLeft.size() \u003e 0) {\n            return addIfNodeFound(root, nodepath, rresFromLeft);\n        }\n​\n        List\u003cTreeNode\u003e rresFromRight = find(root.right, node);\n        if (rresFromRight.size() \u003e 0) {\n            return addIfNodeFound(root, nodepath, rresFromRight);\n        }\n​\n        return nodepath;\n    }\n​\n    private List\u003cTreeNode\u003e addIfNodeFound(TreeNode root, List\u003cTreeNode\u003e nodepath, List\u003cTreeNode\u003e rresFromLeft) {\n        nodepath.addAll(rresFromLeft);\n        nodepath.add(root);\n        return nodepath;\n    }\n}\n"},{"id":"42","name":" Trapping Rain Water","language":"java","code":"class Solution {\n    public int trap(int[] height) {\n        return this.easySolution(height);\n    }\n​\n    private int easySolution(int[] height) {\n        int n = height.length;\n        int[] leftwalls = new int[n];\n        leftwalls[0]=height[0];\n        for (int i = 1; i \u003c n; i++) leftwalls[i] = Math.max(height[i], leftwalls[i-1]);\n​\n        int[] rightWalls = new int[n];\n        rightWalls[n-1]=height[n-1];\n        for (int i=n-2; i\u003e= 0; i--) rightWalls[i] = Math.max(height[i], rightWalls[i+1]);\n​\n        int totalWater = 0;\n        for (int i = 0; i \u003c n; i++) {\n            int storedWater = Math.min(leftwalls[i], rightWalls[i]) - height[i];\n            totalWater += storedWater;\n        }\n​\n        return totalWater;\n    }\n​\n    private int optimized(int[] height) {\n        int n = height.length;\n        int leftwall = 0;\n        int rightwall = 0;\n        int left = 0;\n        int right = n - 1;\n        int water = 0;\n        while (left \u003c= right) {\n            if (height[left] \u003c= height[right]) {\n                if (leftwall \u003c height[left]) {\n                    leftwall = height[left];\n                } else {\n                    water += leftwall - height[left];\n                }\n                left++;\n            } else {\n                if (rightwall \u003c= height[right]) {\n                    rightwall = height[right];\n                } else {\n                    water += rightwall - height[right];\n                }\n                right--;\n            }\n        }\n        return water;\n    }\n}\n"},{"id":"234","name":" Palindrome Linked List","language":"cpp","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* r = NULL;\n    bool ans = true;\n    \n    void solve(ListNode* rt){\n        if(rt == NULL){\n            return ;\n        }\n        solve(rt-\u003enext);\n        \n        if(rt-\u003eval != r-\u003eval){\n            ans = false;\n            return;\n        }\n        r = r-\u003enext;\n    }\n    \n    bool isPalindrome(ListNode* head) {\n        // stack\u003cint\u003e cache;\n        // ListNode* r = head;\n        // while(r){\n        //     cache.push(r-\u003eval);\n        //     r = r-\u003enext;\n        // }\n        // r = head;\n        // while(r){\n        //     if(cache.top() != r-\u003eval){\n        //         return false;\n        //     }\n        //     r = r-\u003enext;\n        //     cache.pop();\n        // }\n        // return true;\n        \n        r = head;\n        solve(head);\n        return ans;\n    }\n};\n"},{"id":"15","name":" 3Sum","language":"java","code":"class Solution {\n    public List\u003cList\u003cInteger\u003e\u003e threeSum(int[] nums) {\n        return optimized(nums);\n    }\n​\n    private List\u003cList\u003cInteger\u003e\u003e optimized(int[] nums) {\n        // TC: O(NLogN+N**2) ; SC: O(M)\n        Arrays.sort(nums);\n        List\u003cList\u003cInteger\u003e\u003e result = new ArrayList\u003c\u003e();\n        for (int i = 0; i \u003c nums.length; i++) {\n            int target = -1 * nums[i];\n            int start = i+1;\n            int end = nums.length-1;\n            while (start \u003c end) {\n                int sm = nums[start] + nums[end];\n                if (sm == target) {\n                    result.add( Arrays.asList(nums[i], nums[start], nums[end]) );\n                    while (start+1 \u003c nums.length \u0026\u0026 nums[start+1] == nums[start]) start++;\n                    while (end-1 \u003e 0 \u0026\u0026 nums[end-1] == nums[end]) end--;\n                    start++;\n                    end--;\n                }\n                else if (sm \u003e target) {\n                    end--;\n                } else {\n                    start++;\n                }\n            }\n            while (i+1 \u003c nums.length \u0026\u0026 nums[i+1] == nums[i]) i++;\n        }\n        return result;\n    }\n​\n    private List\u003cList\u003cInteger\u003e\u003e bruteforce(int[] nums) {\n        // TC: O(N**3) ; SC: O(N)\n        Set\u003cList\u003cInteger\u003e\u003e result = new HashSet\u003c\u003e();\n        for (int i = 0; i \u003c nums.length; i++) {\n            for (int j = i+1; j \u003c nums.length; j++) {\n                for (int k = j+1; k \u003c nums.length; k++) {\n                    if (nums[i] + nums[j] + nums[k] == 0) {\n                        result.add(sorted(nums[i], nums[j], nums[k] ));\n                    }\n                }\n            }\n        }\n        return result.stream().toList();\n    }\n"},{"id":"1293","name":" Shortest Path in a Grid with Obstacles Elimination","language":"java","code":"class Solution {\n    private static final int[][] DIRS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n​\n    public int shortestPath(int[][] grid, int k) {\n        Queue\u003cint[]\u003e queue = new LinkedList\u003c\u003e();\n        queue.offer(new int[]{0, 0, 0, 0}); // [row, col, obstacle, level]\n        int[][] visited = new int[grid.length][grid[0].length];\n        for (int[] v : visited) Arrays.fill(v, Integer.MAX_VALUE);\n        visited[0][0] = 0;\n        while (!queue.isEmpty()) {\n            int[] entry = queue.poll();\n            if (entry[0] == grid.length - 1 \u0026\u0026 entry[1] == grid[0].length - 1) return entry[3];\n            for (int[] dir : DIRS) {\n                int row = entry[0] + dir[0], col = entry[1] + dir[1];\n                boolean inbound = row \u003e= 0 \u0026\u0026 row \u003c grid.length \u0026\u0026 col \u003e= 0 \u0026\u0026 col \u003c grid[0].length;\n                if (inbound) {\n                    int obstacle = entry[2] + grid[row][col];\n                    if (obstacle \u003c= k \u0026\u0026 obstacle \u003c visited[row][col]) {\n                        visited[row][col] = obstacle;\n                        queue.offer(new int[]{row, col, obstacle, entry[3] + 1});\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n"},{"id":"215","name":" Kth Largest Element in an Array","language":"java","code":"class Solution {\n    public int findKthLargest(int[] nums, int k) {\n        // PriorityQueue\u003cInteger\u003e minheap = new PriorityQueue\u003c\u003e(); // default: minheap\n        // for (int elem : nums) {\n        //     minheap.offer(elem);\n        //     if (minheap.size() \u003e k) {\n        //         minheap.remove();\n        //     }\n        // }\n        // return minheap.peek();\n        \n        return KthInArray(nums, k);\n    }\n    \n    // TC: O(N), SC: O(1)\n    public int KthInArray(int[] arr, int k) {\n        int start = 0;\n        int end = arr.length - 1;\n        int index = arr.length - k;\n​\n        while (start \u003c= end) {\n            int paritionIndex = parition(arr, start, end);\n            if (paritionIndex == index) {\n                return arr[paritionIndex];\n            } else if (paritionIndex \u003e index) {\n                end = paritionIndex - 1;\n            } else {\n                start = paritionIndex + 1;\n            }\n        }\n        return arr[start];\n    }\n    \n    private void swap(int[] arr, int i, int j) {\n        int t = arr[i];\n        arr[i] = arr[j];\n        arr[j] = t;\n    }\n​\n    private int parition(int[] arr, int start, int end) {\n        // TODO Auto-generated method stub\n        int pivot = end;\n        \n        int i = start;\n        int j = end;\n        \n        while (i \u003c j) {\n            while (i \u003c j \u0026\u0026 arr[i] \u003c= arr[pivot]) {\n                i++;\n            }\n            \n            while (i \u003c j \u0026\u0026 arr[j] \u003e= arr[pivot]) {\n                j--;\n            }\n            \n            swap(arr, i, j);\n        }\n        \n        swap(arr, i, pivot);\n        \n        return i;\n    }\n}\n"},{"id":"639","name":" Decode Ways II","language":"java","code":"class Solution {\n    private int inf = 1_000_000_007;\n​\n    public int numDecodings(String s) {\n        if (s.length() == 0 || s.charAt(0) == '0')\n            return 0;\n​\n        final int n = s.length();\n        int[] dp = new int[n + 1];\n​\n        dp[0] = 1;\n        dp[1] = s.charAt(0) == '*' ? 9 : 1;\n​\n        /*\n         * actually everytime I got 2 possiblities: to check if the next character is a\n         * valid number or not. ( num \u003e 0) or to check if the next character is a valid\n         * number or not. ( num == 0) so I can just use a single variable to represent\n         * the number.\n         * \n         * if curchar == '*' --\u003e 9 ways if curchar \u003e '0' ---\u003e 1 ways\n         * \n         * total curway would be multiple of (dp[i-1] + dp[i-2])\n         */\n​\n        for (int i = 2; i \u003c= n; i++) {\n            char first = s.charAt(i - 2);\n            char second = s.charAt(i - 1);\n​\n            if (second == '*') {\n                dp[i] += (9 * dp[i - 1]) % inf;\n            } else if (second \u003e '0') {\n                dp[i] += dp[i - 1];\n            }\n​\n            if (first == '1' \u0026\u0026 second == '*') {\n                dp[i] += (9 * dp[i - 2]) % inf;\n            } else if (first == '2' \u0026\u0026 second == '*') {\n                dp[i] += (6 * dp[i - 2]) % inf;\n            } else if ((first - '0') * 10 + (second - '0') \u003c= 26) {\n                dp[i] += dp[i - 2];\n            }\n​\n            if (first == '*') {\n                if (second == '*') {\n                    dp[i] += (15 * dp[i - 2]) % inf;\n                } else if (second \u003c= '6') {\n                    dp[i] += (2 * dp[i - 2]) % inf;\n                } else {\n                    dp[i] += dp[i - 2];\n                }\n            }\n​\n            dp[i] = dp[i] % inf;\n        }\n​\n        System.out.println(Arrays.toString(dp));\n        return dp[n] % inf;\n    }\n}\n"},{"id":"237","name":" Delete Node in a Linked List","language":"cpp","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        node-\u003eval = node-\u003enext-\u003eval;\n        node-\u003enext = node-\u003enext-\u003enext;\n    }\n};\n"},{"id":"429","name":" N-ary Tree Level Order Traversal","language":"java","code":"class Solution {\n    public List\u003cList\u003cInteger\u003e\u003e levelOrder(Node root) {\n        Queue\u003cNode\u003e queue = new LinkedList\u003c\u003e();\n        List\u003cList\u003cInteger\u003e\u003e result = new ArrayList\u003c\u003e();\n        if (root==null) return result;\n        queue.add(root);\n​\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            List\u003cInteger\u003e level_list = new ArrayList\u003c\u003e();\n            for (int i = 0; i \u003c size; i++) {\n                Node node = queue.poll();\n                if (node!=null) {\n                    level_list.add(node.val);\n                    // for all the childrens; push into queue\n                    node.children.forEach((e) -\u003e queue.add(e));\n                }\n            }\n            if (level_list.size()\u003e0)\n                result.add(new ArrayList\u003c\u003e(level_list));\n        }\n        return result;\n    }\n}\n"},{"id":"150","name":" Evaluate Reverse Polish Notation","language":"java","code":"class Solution {\n    public int evalRPN(String[] tokens) {\n        \n        int returnValue = 0;\n \n        String operators = \"+-*/\";\n \n        Stack\u003cString\u003e stack = new Stack\u003cString\u003e();\n \n        for(String t : tokens){\n            if(!operators.contains(t)){\n                stack.push(t);\n            }else{\n                int a = Integer.valueOf(stack.pop());\n                int b = Integer.valueOf(stack.pop());\n                int index = operators.indexOf(t);\n                switch(index){\n                    case 0:\n                        stack.push(String.valueOf(a+b));\n                        break;\n                    case 1:\n                        stack.push(String.valueOf(b-a));\n                        break;\n                    case 2:\n                        stack.push(String.valueOf(a*b));\n                        break;\n                    case 3:\n                        stack.push(String.valueOf(b/a));\n                        break;\n                }\n            }\n        }\n \n        returnValue = Integer.valueOf(stack.pop());\n \n        return returnValue;\n    }\n}\n"},{"id":"64","name":" Minimum Path Sum","language":"java","code":"class Solution {\n    public int minPathSum(int[][] grid) {\n        if (grid == null)\n            return 0;\n\n        int R = grid.length;\n        int C = grid[0].length;\n\n        for (int col = 1; col \u003c C; col++) {\n            grid[0][col] += grid[0][col - 1];\n        }\n\n        for (int row = 1; row \u003c R; row++) {\n            grid[row][0] += grid[row - 1][0];\n        }\n\n        for (int row = 1; row \u003c R; row++) {\n            for (int col = 1; col \u003c C; col++) {\n                if (row - 1 \u003c 0 || col - 1 \u003c 0)\n                    continue;\n                int cost = getCost(grid, row, col);\n                grid[row][col] = cost;\n            }\n        }\n\n        return grid[R - 1][C - 1];\n    }\n\n    private int getCost(int[][] grid, int row, int col) {\n        return Math.min(grid[row - 1][col], grid[row][col - 1]) + grid[row][col];\n    }\n}\n"},{"id":"234","name":" Palindrome Linked List","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    private ListNode curr = null;\n    public boolean isPalindrome(ListNode head) {\n        curr = head;\n        boolean result = _isPalindrome(head);\n        return result;\n    }\n​\n    private boolean _isPalindrome(ListNode head) {\n​\n        if (head == null) {\n            return true;\n        }\n​\n        // faith\n        boolean rres = _isPalindrome(head.next);\n        if (rres == false) return false;\n​\n        boolean my_status = head.val == curr.val;\n        curr = curr.next;\n​\n        return my_status;\n    }\n}\n"},{"id":"433","name":" Minimum Genetic Mutation","language":"java","code":"class Solution {\n    public int minMutation(String start, String end, String[] bank) {\n        int answer = 0;\n        Set\u003cString\u003e bankset = new HashSet\u003c\u003e(Arrays.stream(bank).toList());\n        Set\u003cString\u003e computed = new HashSet\u003c\u003e();\n        Queue\u003cString\u003e queue = new ConcurrentLinkedQueue\u003c\u003e();\n        char[] options = new char[] { 'A', 'C', 'G', 'T' };\n​\n        queue.offer(start);\n        computed.add(start);\n​\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            while (size \u003e 0) {\n                String current = queue.poll();\n                if (current.equals(end))\n                    return answer;\n​\n                for (char opt : options) {\n                    // all characters index in current\n                    for (int i = 0; i \u003c current.length(); i++) {\n                        StringBuilder neighbour = new StringBuilder(current);\n                        neighbour.setCharAt(i, opt);\n                        // is this new modified neighnboir in bankset or visited\n                        if (!computed.contains(neighbour.toString()) \u0026\u0026 bankset.contains(neighbour.toString())) {\n                            queue.offer(neighbour.toString());\n                            computed.add(neighbour.toString());\n                        }\n                    }\n                }\n                size--;\n            }\n            answer++;\n        }\n        return -1;\n    }\n}\n​\n"},{"id":"238","name":" Product of Array Except Self","language":"java","code":"class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n​\n        int[] leftwall = new int[n];\n        leftwall[0]=nums[0];\n        for (int i = 1; i \u003c n; i++) {\n            leftwall[i] = leftwall[i-1] * nums[i];\n        }\n​\n        int[] rightwall = new int[n];\n        rightwall[n-1]=nums[n-1];\n        for (int i = n-2; i \u003e= 0; i--) {\n            rightwall[i] = rightwall[i+1] * nums[i];\n        }\n​\n        // System.out.println(\"leftwall = \" + Arrays.toString(leftwall));\n        // System.out.println(\"rightwall = \" + Arrays.toString(rightwall));\n​\n        int[] result = new int[n];\n        for (int i = 0; i \u003c n; i++) {\n            if (i==0) {\n                result[i] = rightwall[i+1];\n            } else if (i == n-1) {\n                result[i] = leftwall[i-1];\n            } else {\n                int leftp = leftwall[i-1];\n                int rightp = rightwall[i+1];\n​\n                result[i] = leftp * rightp;\n            }\n        }\n​\n        return result;\n    }\n}\n"},{"id":"152","name":" Maximum Product Subarray","language":"cpp","code":"#define fo(i, k, n) for(int i = k; i \u003c n; i++)\nclass Solution {\npublic:\n    int maxProduct(vector\u003cint\u003e\u0026 nums) {\n        int n = nums.size();\n        int ans = nums[0], rmx = nums[0], rmn = nums[0];\n        fo(i, 1, n){\n            int cmax = rmx;\n            rmx = max({rmx*nums[i], nums[i], rmn*nums[i]});\n            rmn = min({cmax*nums[i], rmn*nums[i], nums[i]});\n            ans = max(rmx,ans);\n        }\n        return ans ;\n    }\n};\n"},{"id":"240","name":" Search a 2D Matrix II","language":"java","code":"class Solution {\n     public boolean searchMatrix(int[][] matrix, int target) {\n        int r = 0;\n       int c = matrix[0].length - 1;\n       while(r \u003c matrix.length \u0026\u0026 c \u003e= 0) {\n           if (matrix[r][c] == target)\n            return true;\n           else if (matrix[r][c] \u003e target) c--;\n           else r++;\n       }\n        return false;\n    }\n​\n    private boolean searchElem(int[] arr, int target) {\n        int lo = 0;\n        int hi = arr.length - 1;\n        while(lo \u003c= hi) {\n            int mid = (lo+hi) / 2;\n            if (arr[mid] == target)\n                return true;\n            else if (arr[mid] \u003e target)\n                lo = mid + 1;\n            else hi = mid - 1;\n        }\n        return false;\n    }\n}\n"},{"id":"13","name":" Roman to Integer","language":"cpp","code":"class Solution {\npublic:\n    int value(char r)\n{\n    if (r == 'I')\n        return 1;\n    if (r == 'V')\n        return 5;\n    if (r == 'X')\n        return 10;\n    if (r == 'L')\n        return 50;\n    if (r == 'C')\n        return 100;\n    if (r == 'D')\n        return 500;\n    if (r == 'M')\n        return 1000;\n \n    return -1;\n}\n    int romanToInt(string str) {\n        // Initialize result\n    int res = 0;\n \n    // Traverse given input\n    for (int i = 0; i \u003c str.length(); i++) \n    {\n        // Getting value of symbol s[i]\n        int s1 = value(str[i]);\n \n        if (i + 1 \u003c str.length()) \n        {\n            // Getting value of symbol s[i+1]\n            int s2 = value(str[i + 1]);\n \n            // Comparing both values\n            if (s1 \u003e= s2) \n            {\n                // Value of current symbol\n                // is greater or equal to\n                // the next symbol\n                res = res + s1;\n            }\n            else\n            {\n                // Value of current symbol is\n                // less than the next symbol\n                res = res + s2 - s1;\n                i++;\n            }\n        }\n        else {\n            res = res + s1;\n        }\n    }\n    return res;\n    }\n};\n"},{"id":"2156","name":" Find Substring With Given Hash Value","language":"java","code":"/**\n * @author sounishnath\n *\n */\nclass Solution {\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\n        // sliding window with k\n        \n        long hashcode = 0;\n        long powerk = 1;\n        int result = 0;\n        int n = s.length();\n        \n        for (int i = n - 1; i \u003e= 0; i--) {\n            hashcode = (hashcode  * power + s.charAt(i) - 'a' + 1 ) % modulo;\n            if (i + k \u003e= n) {\n                powerk = powerk * power % modulo;\n            } else {\n                hashcode =  (hashcode - (s.charAt(i + k) - 'a' + 1) * powerk % modulo + modulo) % modulo;\n            }\n            \n            if (hashcode == hashValue) {\n                result = i;\n            }\n        }\n        \n        return s.substring(result, result + k);\n    }\n​\n    private int computeHash(String s, int power, int modulo) {\n        int code = 0;\n        for (int i = 0; i \u003c s.length(); i++) {\n            int charcode = (s.charAt(i) - 'a') + 1;\n            int value = (charcode * (int) Math.pow(power, i));\n            code += value;\n            code = code % modulo;\n        }\n​\n        return code;\n    }\n​\n}\n"},{"id":"643","name":" Maximum Average Subarray I","language":"java","code":"class Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        int n = nums.length;\n        int[] sums = new int[n];\n        sums[0] = nums[0];\n​\n        for (int i = 1; i \u003c n; i++) {\n            sums[i] = sums[i - 1] + nums[i];\n        }\n​\n        double res = sums[k - 1] * 1.0 / k;\n        for (int i = k; i \u003c nums.length; i++) {\n            res = Math.max(res, (sums[i] - sums[i - k]) * 1.0 / k);\n        }\n​\n        return res;\n        // int n = nums.length;\n        // double max_avg = Double.MIN_VALUE;\n​\n        // for (int i = 0; i \u003c= n - k; i++) {\n        //     int[] temp = Arrays.copyOfRange(nums, i, i + k);\n        //     int sum = 0;\n        //     for (int elem : temp)\n        //         sum += elem;\n​\n        //     double avg = sum / (k * 1.0);\n        //     max_avg = Math.max(max_avg, avg);\n        // }\n​\n        // return max_avg;\n    }\n}\n"},{"id":"152","name":" Maximum Product Subarray","language":"java","code":"class Solution {\npublic int maxProduct(int[] nums) {\n    return brainiestapproach(nums);\n}\n​\nprivate int brainiestapproach(int[] nums) {\n    // TODO Auto-generated method stub\n            int leftprod = 1;\n            int rightprod = 1;\n            \n            int result=nums[0];\n            \n            for(int i = 0; i \u003c nums.length; i++) {\n                int elem1 = nums[i];\n                int elem2 = nums[nums.length-1-i];\n                \n                leftprod = leftprod == 0 ? 1 : leftprod;\n                rightprod = rightprod == 0 ? 1 : rightprod;\n                \n                leftprod = leftprod * elem1;\n                rightprod = rightprod * elem2;\n                \n                result=Math.max(result, Math.max(leftprod, rightprod));\n            }\n            \n            return result;\n}\n​\nprivate int goodapproch(int[] nums) {\n    int n = nums.length;\n    int maxprod = nums[0];\n    int minprod = nums[0];\n    int result = nums[0];\n​\n    for (int i = 1; i \u003c n; i++) {\n        int e = nums[i];\n        if (e \u003c= 0) {\n            // swap\n            int t = maxprod;\n            maxprod = minprod;\n            minprod = t;\n        }\n        maxprod = Math.max(nums[i], maxprod * e);\n        minprod = Math.min(nums[i], minprod * e);\n        result = Math.max(result, maxprod);\n    }\n​\n    return result;\n}\n}\n"},{"id":"26","name":" Remove Duplicates from Sorted Array","language":"java","code":"class Solution {\n    public int removeDuplicates(int[] nums) {\n        return optimized(nums);\n    }\n​\n    private int optimized(int[] nums) {\n        int n=nums.length;\n        int left=-1;\n        int right=0;\n        while (right\u003cn){\n            int elem=nums[right];\n            if (left==-1||nums[left] != nums[right])\n                nums[++left]=nums[right];\n            right++;\n        }\n        return left+1;\n    }\n}\n"},{"id":"2389","name":" Longest Subsequence With Limited Sum","language":"java","code":"class Solution {\n    public int[] answerQueries(int[] nums, int[] queries) {\n        /*\n         * 1. more logical if we pick the smallest elements i.e. the window length will\n         * become longest 2. sort the nums array, and as it is subsequence so the\n         * original ordering does not matter too much. 3. do the precomputation of\n         * prefixsum[i] = sum(arr[0...i]) and you get the max elements 4. do the lower\n         * bound binary search to get the right index from prefix sum. 5.\n         */\n​\n        Arrays.sort(nums);\n        int n = nums.length;\n        int[] prefixsum = calculatePrefixSum(nums, n);\n        System.out.println(\"prefix = \" + Arrays.toString(prefixsum));\n​\n        int qn = queries.length;\n        int[] result = new int[qn];\n        for (int i = 0; i \u003c qn; i++) {\n            int query = queries[i];\n            int upperIndex = binarySearch(prefixsum, query);\n            result[i] = upperIndex;\n        }\n​\n        return result;\n    }\n​\n    private int binarySearch(int[] arr, int target) {\n        int lo = 0;\n        int hi = arr.length;\n        while (lo \u003c hi) {\n            int mid = (lo + hi) / 2;\n            if (arr[mid] \u003e target) {\n                hi=mid;\n            } else {\n                lo=mid+1;\n            }\n        }\n​\n        return lo;\n    }\n​\n    private int[] calculatePrefixSum(int[] nums, int n) {\n        int[] prefixsum = new int[n];\n        prefixsum[0] = nums[0];\n        for (int i = 1; i \u003c n; i++) {\n            prefixsum[i] += prefixsum[i - 1] + nums[i];\n        }\n        return prefixsum;\n    }\n}\n​\n"},{"id":"242","name":" Valid Anagram","language":"cpp","code":"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        return s == t;\n    }\n};\n"},{"id":"435","name":" Non-overlapping Intervals","language":"java","code":"class Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -\u003e a[1] - b[1]);\n        \n        int prevEndTime = intervals[0][1];\n        int total = 0;\n        \n        for (int i = 1; i \u003c intervals.length; i++) {\n            int[] interval = intervals[i];\n            \n            int curStartTime = interval[0];\n            if (curStartTime \u003e= prevEndTime) {\n                prevEndTime = interval[1];\n                continue;\n            }\n            \n            total++;\n        }\n        \n        return total;\n    }\n}\n"},{"id":"645","name":" Set Mismatch","language":"java","code":"    class Solution {\n        public int[] findErrorNums(int[] nums) {\n            /**\n             * Simple using Maths:\n             * ----------------------\n             * [1,2,2,4]\n             * 1+2+3+4 = 10 (naturalSum)\n             * 1+2+2+4 = 9 (currentSum)\n             * --------------\n             * duplicate = 2\n             * missing = (naturalSum + duplicate - currentSum)\n             * \n             * Using Bit Operation:\n             * ----------------------\n             * use HashSet to store the numbers \u0026\u0026 xor = xor ^ number\n             * if number is in hashset duplicate = number\n             * \n             * for (i=1 to arr.length) {\n             * xor = xor ^ i\n             * }\n             * \n             * return {duplicate, xor};\n             * \n             */\n​\n            int currentSum = Arrays.stream(nums).sum();\n            int naturalSum = ((nums.length) * (nums.length + 1)) / 2;\n​\n            int duplicate = -1;\n            Set\u003cInteger\u003e set = new HashSet\u003c\u003e();\n            for (int x : nums) {\n                if (set.contains(x)) {\n                    duplicate = x;\n                } else {\n                    set.add(x);\n                }\n            }\n​\n            int missing = (naturalSum + duplicate - currentSum);\n            return new int[] { duplicate, missing };\n        }\n    }\n"},{"id":"234","name":" Palindrome Linked List","language":"py","code":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def isPalindrome(self, head: ListNode) -\u003e bool:\n        \n"},{"id":"155","name":" Min Stack","language":"cpp","code":"struct Element\n{\n    int val;\n    int min;\n};\n​\nclass MinStack\n{\n    stack\u003cElement\u003e m_data;\n    int curr_min;\npublic:\n    /** initialize your data structure here. */\n    MinStack()\n​\n    void push(int x)\n    {\n        Element e;\n        e.val = x;\n        if( m_data.empty()){\n            curr_min = INT32_MAX;\n        }\n        if( curr_min \u003e x){\n            curr_min = x;\n        }\n        e.min = curr_min;\n        m_data.push(e);\n    }\n​\n    void pop()\n    {\n        m_data.pop();\n        if(!m_data.empty())\n            curr_min = m_data.top().min;\n    }\n​\n    int top()\n"},{"id":"438","name":" Find All Anagrams in a String","language":"java","code":"// https://leetcode.com/problems/find-all-anagrams-in-a-string/\nclass Solution {\n    public List\u003cInteger\u003e findAnagrams(String s, String p) {\n​\n            List\u003cInteger\u003e answer = new ArrayList\u003cInteger\u003e();\n            if (s.length() \u003c p.length() ) return answer;\n​\n            Map\u003cCharacter, Integer\u003e pmap = new HashMap\u003c\u003e();\n            for (Character c : p.toCharArray())\n                pmap.put(c, pmap.getOrDefault(c, 0)+1);\n​\n            int start = 0;\n            int end = 0;\n​\n            Map\u003cCharacter, Integer\u003e smap = new HashMap\u003c\u003e();\n​\n            while (end \u003c s.length()) {\n                char c = s.charAt(end);\n                smap.put(c, smap.getOrDefault(c, 0) + 1);\n​\n                int windowSize = end - start + 1;\n                if (windowSize == p.length()) {\n                    // check if two maps are equal\n                    if ( pmap.equals(smap)) {\n                        answer.add(start);\n                    }\n                    // decrease the count for s[start]\n                    int ppcount = smap.get(s.charAt(start));\n                    // if the ppcount - 1 == 0 remove it out\n                    if (ppcount - 1 == 0) {\n                        smap.remove(s.charAt(start));\n                    } else {\n                        smap.put( s.charAt(start), ppcount - 1);\n                    }\n​\n                    start++;\n                }\n                end++;\n            }\n​\n​\n            return answer;\n    }\n}   \n"},{"id":"268","name":" Missing Number","language":"cpp","code":"class Solution {\npublic:\n    int missingNumber(vector\u003cint\u003e\u0026 nums) {\n        int n=nums.size();\n       int x1 =0; \n        int x2=0;\n        for(int i=0;i\u003cn;i++){\n            x1^=nums[i];\n            x2^=i+1;\n        }\n        return x1^x2;\n    }\n};\n"},{"id":"130","name":" Surrounded Regions","language":"java","code":"class Solution {\n    private final char IDENTIFIER_CHARACTER = '#';\n​\n    public void solve(char[][] board) {\n        if (board == null)\n            return;\n​\n        int R = board.length;\n        int C = board[0].length;\n​\n        if (R \u003c= 2 || C \u003c= 2)\n            return;\n​\n        for (int row = 0; row \u003c R; row++) {\n            for (int col = 0; col \u003c C; col++) {\n                char value = board[row][col];\n​\n                if (value == 'O' \u0026\u0026 isBoundaryCell(row, col, R, C)) {\n                    traverseAndChange(board, row, col, R, C);\n                }\n            }\n        }\n​\n        for (int row = 0; row \u003c R; row++) {\n            for (int col = 0; col \u003c C; col++) {\n                char value = board[row][col];\n​\n                if (value == 'O') {\n                    board[row][col] = 'X';\n                } else if (value == IDENTIFIER_CHARACTER) {\n                    board[row][col] = 'O';\n                }\n            }\n        }\n    }\n​\n    private void traverseAndChange(char[][] board, int row, int col, int R, int C) {\n        board[row][col] = IDENTIFIER_CHARACTER;\n​\n        int[] dr = new int[] { -1, 1, 0, 0 };\n        int[] dc = new int[] { 0, 0, 1, -1 };\n​\n        for (int k = 0; k \u003c 4; k++) {\n            int nrow = row + dr[k];\n            int ncol = col + dc[k];\n​\n            if (nrow \u003c 0 || nrow \u003e= R || ncol \u003c 0 || ncol \u003e= C)\n                continue;\n​\n            char value = board[nrow][ncol];\n            if (value == 'O') {\n                traverseAndChange(board, nrow, ncol, R, C);\n            }\n        }\n    }\n​\n    private boolean isBoundaryCell(int row, int col, int r, int c) {\n        return row == 0 || row == r - 1 || col == 0 || col == c - 1;\n    }\n}\n"},{"id":"647","name":" Palindromic Substrings","language":"java","code":"class Solution {\n    public int countSubstrings(String s) {\n        int foundSubstrings = 0;\n​\n        /*\n         * return the number of palindromic substrings in it.\n         * \n         * Intuition: dp[i][j] -\u003e whether s.substring(i,j+1) is a palindrome? How?:\n         * s.at(i) == a.at(j) as well as dp[i+1][j-1] is true!\n         */\n​\n        final int n = s.length();\n        int[][] dp = new int[n][n];\n​\n        for (int i = 0; i \u003c n; i++) // means single char is palindrome\n            dp[i][i] = 1;\n​\n        for (int len = 2; len \u003c= n; len++) {\n            for (int i = 0; i + len - 1 \u003c n; i++) {\n                int j = i + len - 1;\n                if (i + 1 == j) {\n                    dp[i][j] = (s.charAt(i) == s.charAt(j) ? 1 : 0);\n                } else {\n                    dp[i][j] = (s.charAt(i) == s.charAt(j) \u0026\u0026 dp[i + 1][j - 1] \u003e 0) ? 1 : 0;\n                }\n            }\n        }\n​\n        for (int i = 0; i \u003c n; i++)\n            for (int j = 0; j \u003c n; j++)\n                foundSubstrings += dp[i][j];\n​\n        return foundSubstrings;\n    }\n}\n​\n"},{"id":"239","name":" Sliding Window Maximum","language":"java","code":"import java.util.ArrayList;\nimport java.util.List;\n\npublic class MaxiumofAllSubarray {\n    private class ElementPosition {\n        int value;\n        int index;\n\n        public ElementPosition(int index, int value) {\n            this.value = value;\n            this.index = index;\n        }\n\n        @Override\n        public String toString() {\n            return \"ElementPosition{\" +\n                    \"value=\" + value +\n                    \", index=\" + index +\n                    '}';\n        }\n    }\n    public List\u003cInteger\u003e getMaximumOfWindowK(int[] arr, int k) {\n        int startIndex = 0;\n        int endIndex = 0;\n\n        ElementPosition firstMaxElement = new ElementPosition(-1, Integer.MIN_VALUE);\n        ElementPosition secondMaxElement = new ElementPosition(-1, Integer.MIN_VALUE);\n\n        List\u003cInteger\u003e result = new ArrayList\u003c\u003e();\n\n        while (endIndex \u003c arr.length) {\n            // calculation\n            ElementPosition[] elementPositions = determineFirstMaxAndSecondMax(firstMaxElement, secondMaxElement, arr, endIndex);\n            firstMaxElement = elementPositions[0];\n            secondMaxElement = elementPositions[1];\n\n            int windowSize = (endIndex - startIndex + 1);\n            if (windowSize == k) {\n                System.out.println(\"firstMax: \" + firstMaxElement);\n                System.out.println(\"secondMax: \" + secondMaxElement);\n                System.out.println(\"========\");\n\n                // get answer\n                result.add(firstMaxElement.value);\n                // slide the window\n                startIndex++;\n                // if startIndex bounds then update firstmax and secondmax\n                ElementPosition[] elementPositions1 = updateFirstMaxAndSecondMax(firstMaxElement, secondMaxElement, startIndex);\n                firstMaxElement = elementPositions1[0];\n                secondMaxElement = elementPositions[1];\n            }\n\n            endIndex++;\n        }\n\n        return result;\n    }\n\n    private ElementPosition[] updateFirstMaxAndSecondMax(ElementPosition firstMaxElement, ElementPosition secondMaxElement, int currIndex) {\n        if (currIndex \u003e firstMaxElement.index) {\n            firstMaxElement = secondMaxElement;\n        }\n\n        return new ElementPosition[]{firstMaxElement, secondMaxElement};\n    }\n\n    private ElementPosition[] determineFirstMaxAndSecondMax(ElementPosition firstMaxElement, ElementPosition secondMaxElement, int[] arr, int endIndex) {\n        int element = arr[endIndex];\n\n        if (element \u003e firstMaxElement.value) {\n            secondMaxElement = firstMaxElement;\n            firstMaxElement = new ElementPosition(endIndex, element);\n        } else  if (element \u003e secondMaxElement.value) {\n            // just update second max\n            secondMaxElement = new ElementPosition(endIndex, element);\n        }\n\n        return new ElementPosition[]{firstMaxElement, secondMaxElement};\n    }\n}\n\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] arr, int k) {\n        MaxiumofAllSubarray maxiumofAllSubarray = new MaxiumofAllSubarray();\n        List\u003cInteger\u003e ans = maxiumofAllSubarray.getMaximumOfWindowK(arr, k);\n        return ans.stream().mapToInt(Integer::intValue).toArray();\n    }\n}\n"},{"id":"45","name":" Jump Game II","language":"java","code":"class Solution {\n    public int jump(int[] nums) {\n        if(nums == null || nums.length == 0)\n            return 0;\n        int n = nums.length;\n        int reach = 0, lastPoint = 0, minSteps = 0;\n        // think like if my current jump cannot reach the current i\n        // I have to increase my steps\n        for (int i = 0; i \u003c n \u0026\u0026 i \u003c= reach; i++) {\n            if (i \u003e lastPoint) {\n                minSteps++;\n                lastPoint = reach;\n            }\n            reach = Math.max(reach, nums[i] + i);\n        }\n        return (reach \u003c n - 1) ? 0 : minSteps;\n    }\n}\n"},{"id":"2466","name":" Count Ways To Build Good Strings","language":"java","code":"class Solution {\n    private final int MOD = (int) 1000000007;\n    Map\u003cInteger, Integer\u003e dp = new HashMap\u003c\u003e();\n​\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        return solver(0, low, high, zero, one);\n    }\n​\n    private int solver(int stringLength, int low, int high, int zero, int one) {\n        if (stringLength \u003e high)\n            return 0;\n​\n        if (dp.containsKey(stringLength))\n            return dp.get(stringLength);\n​\n        int canAppend = 0;\n        if (stringLength \u003e= low \u0026\u0026 stringLength \u003c= high) {\n            canAppend = 1;\n        }\n​\n        int zeroAppend = solver(stringLength + zero, low, high, zero, one);\n        int oneAppend = solver(stringLength + one, low, high, zero, one);\n​\n        int val = (canAppend + (zeroAppend % MOD) + (oneAppend % MOD)) % MOD;\n        dp.putIfAbsent(stringLength, val);\n        return val;\n    }\n}\n"},{"id":"1584","name":" Min Cost to Connect All Points","language":"java","code":"class Solution {\n    public int find(int[] parent, int x) {\n        if(parent[x] == x) {\n            return x;\n        }\n​\n        int temp = find(parent, parent[x]);\n        parent[x] = temp;\n        return temp;\n    }\n​\n    public void union(int lx, int ly, int[] rank, int[] parent) {\n        if(rank[lx] \u003e rank[ly]) {\n            parent[ly] = lx;\n        } else if(rank[lx] \u003c rank[ly]) {\n            parent[lx] = ly;\n        } else {\n            parent[ly] = lx;\n            rank[lx]++;\n        }\n    }\n    // leetcode 1584. https://leetcode.com/problems/min-cost-to-connect-all-points/\n    public int minCostConnectPoints(int[][] coords) {\n        int size = coords.length * (coords.length - 1) / 2;\n        int[][] points = new int[size][3];\n​\n        int indx = 0;\n        for(int i = 0; i \u003c coords.length; i++) {\n            for(int j = i + 1; j \u003c coords.length; j++) {\n                int dist = Math.abs(coords[j][0] - coords[i][0]) + Math.abs(coords[j][1] - coords[i][1]);\n                int[] point = {i, j, dist};\n                points[indx] = point;\n                indx++;\n            }\n        }\n        \n        // kruskal Algo, sort all the edges \n        Arrays.sort(points, (val1, val2) -\u003e Integer.compare(val1[2], val2[2]));\n​\n        int[] parent = new int[coords.length];\n        int[] rank = new int[coords.length];\n​\n        for(int i = 0; i \u003c coords.length; i++) {\n            parent[i] = i;\n            rank[i] = 1;\n        }\n        int cost = 0;\n        for(int i = 0; i \u003c size; i++) {\n            int u = points[i][0];\n            int v = points[i][1];\n            int wt = points[i][2];\n​\n            int lu = find(parent, u);\n            int lv = find(parent, v);\n​\n            if(lu == lv)\n                continue;\n            \n            union(lu, lv, rank, parent);\n            // add edge\n            cost += wt;\n        }\n        return cost;\n    }\n}\n"},{"id":"65","name":" Valid Number","language":"java","code":"class Solution {\n​\n        boolean isdecimal(String s, int e, int sign, int d) {\n​\n            if (s.equals(\"\") || s.equals(\".\"))\n                return false;\n​\n            if (s.startsWith(\"+\") || s.startsWith(\"-\")) {\n                if (sign == 1) {\n                    return false;\n                }\n                if (s.length() \u003e 1) {\n                    if (!(Character.isDigit(s.charAt(1)) || s.charAt(1) == '.'))\n                        return false;\n                }\n                return isdecimal(s.substring(1), e, 1, d);\n            }\n​\n            for (int i = 0; i \u003c s.length(); i++) {\n                char ch = s.charAt(i);\n                if (!Character.isDigit(ch)) {\n                    if (ch == '.' \u0026\u0026 e == 1)\n                        return false;\n​\n                    if (ch == '.') {\n​\n                        if (d == 1)\n                            return false;\n​\n                        if (i == s.length() - 1)\n                            return true;\n​\n                        if (i \u003c s.length() - 1) {\n                            if (!(Character.isDigit(s.charAt(i + 1)) || (s.charAt(i + 1) == 'e'\n                                    \u0026\u0026 (i \u003e 0 ? Character.isDigit(s.charAt(i - 1)) : false))))\n                                return false;\n                        }\n​\n                        return isdecimal(s.substring(i + 1), e, sign, 1);\n                    }\n"},{"id":"2341","name":" Maximum Number of Pairs in Array","language":"java","code":"import java.util.HashMap;\nimport java.util.Map;\n​\nclass Solution {\n    public int[] numberOfPairs(int[] nums) {\n        int totalPairs = 0;\n        int leftOverElems = 0;\n​\n        Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e();\n        // store the elems into map\n        for (int elem : nums) {\n            map.put(elem, map.getOrDefault(elem, 0) + 1);\n        }\n​\n        // iterate on map\n        for (Map.Entry\u003cInteger, Integer\u003e kv : map.entrySet()) {\n            int occurency = kv.getValue();\n​\n            // as pair == 2 elements.\n            // we can do occurency % 2\n            // // totalpairs will be the vagfol\n            // leftover will be the reminder\n​\n            totalPairs += occurency / 2;\n            leftOverElems += occurency % 2;\n        }\n​\n        return new int[] { totalPairs, leftOverElems };\n    }\n​\n}\n"},{"id":"268","name":" Missing Number","language":"java","code":"class Solution {\n    public int missingNumber(int[] nums) {\n        /**\n            naive approch is to just sort and check\n            with nums[0] == 0 ? nums[0] - 1 : nums[len-1] + 1;\n        \n        Arrays.sort(nums);\n        for(int i = 1; i \u003c nums.length; i++) {\n            int gap = nums[i] - nums[i-1];\n            if (gap\u003e1) \n                return nums[i-1] + 1;\n        }\n        if(nums[0] != 0) return nums[0] - 1;\n        return nums[nums.length-1] + 1;\n        */\n        \n        int x1 = 0, x2 = 0;\n        for (int i = 0; i \u003c nums.length; i++) {\n            x1 = x1 ^ nums[i];\n            x2 = x2 ^ (i+1);\n        }\n        return x1 ^ x2;\n    }\n}\n"},{"id":"1302","name":" Deepest Leaves Sum","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int deepestLeavesSum(TreeNode root) {\n        int height = getHeight(root); \n        int a = _deepestLeavesSum(root, height, 0);\n        return a;\n    }\n    private int getHeight(TreeNode root) {\n        if (root == null) return -1;\n        \n        // faith\n        int lh = getHeight(root.left);\n        int rh = getHeight(root.right);\n        \n        return Math.max(lh, rh) + 1;\n    }\n    \n    private int _deepestLeavesSum(TreeNode root, int height, int curlevel) {\n        if (root == null) return 0;\n        \n        if (curlevel == height \u0026\u0026 root.left == null \u0026\u0026 root.right == null) {\n            return root.val;\n        }\n        \n        // faith\n        int leftLeaveSum = _deepestLeavesSum(root.left, height, curlevel + 1);\n        int rightLeaveSum = _deepestLeavesSum(root.right, height, curlevel + 1);\n        \n        int myres = leftLeaveSum + rightLeaveSum;\n        return myres;\n    }\n}\n"},{"id":"25","name":" Reverse Nodes in k-Group","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if (head == null || head.next == null || k==1) return head;\n​\n        ListNode start = head;\n        ListNode end = getEndNode(start, k);\n        ListNode recursiveHead = reverseKGroup(end.next, k);\n        reverseInRange(start, end);\n        start.next = recursiveHead;\n        return end;\n    }\n​\n    private void reverseInRange(ListNode start, ListNode end) {\n        ListNode previous = null;\n        ListNode current = start;\n​\n        while (previous != end) {\n            ListNode nextnode = current.next;\n            current.next = previous;\n            previous = current;\n            current = nextnode;\n        }\n    }\n​\n    private ListNode getEndNode(ListNode start, int k) {\n        ListNode end = start;\n        int inc = k-1;\n        while (inc \u003e 0) {\n            end = end.next;\n            if (end == null) return start;\n            inc--;\n        }\n        return end;\n    }\n}\n"},{"id":"450","name":" Delete Node in a BST","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        return deleteNode_(root, key);\n    }\n    \n    TreeNode getDeepestRightChild(TreeNode root) {\n        while (root.right != null) root = root.right;\n        return root;\n    }\n​\n    TreeNode deleteAndReorderTheSubtree(TreeNode root) {\n        // if root does not have left return right and vice versa\n        if (root.left == null) return root.right;\n        if (root.right == null) return root.left;\n​\n        // copy the right subtree of the root\n        TreeNode rightsubtree = root.right;\n        TreeNode mostRightChild = getDeepestRightChild(root.left);\n        mostRightChild.right = rightsubtree;\n        return root.left;\n    }\n​\n    TreeNode deleteNode_(TreeNode root, int target) {\n        if (root == null) return root;\n        \n        // if root itself is target\n        if (root.val == target) return deleteAndReorderTheSubtree(root);\n​\n        TreeNode temp = root;\n        while (temp != null) {\n            // find the target\n            if (temp.val \u003e target) {\n                // go left\n                // possible left is the target itself\n                if (temp.left != null \u0026\u0026 temp.left.val == target) {\n                    temp.left = deleteAndReorderTheSubtree(temp.left);\n                    break;\n                }\n                else {\n                    temp = temp.left;\n                }\n            } else {\n                if (temp.right != null \u0026\u0026 temp.right.val == target) {\n                    temp.right = deleteAndReorderTheSubtree(temp.right);\n                    break;\n                } else {\n                    temp = temp.right;\n                }\n            }\n        }\n        return root;\n    }\n}\n"},{"id":"66","name":" Plus One","language":"cpp","code":"class Solution {\npublic:\n    vector\u003cint\u003e plusOne(vector\u003cint\u003e\u0026 digits) {\n       int n = digits.size();\n        for(int i = n - 1; i \u003e= 0; i--) {\n            if(digits[i] \u003c 9){\n                digits[i]++;\n                return digits;\n            }\n            \n            digits[i] = 0;\n        }\n        vector\u003cint\u003e nn(n + 1);\n        nn[0] = 1;\n        return nn;\n    }\n};\n​\n//1 2 3 9 9 9\n \n"},{"id":"24","name":" Swap Nodes in Pairs","language":"cpp","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* extra = new ListNode();\n        extra-\u003enext = head;\n        f(extra);\n        return extra-\u003enext;\n    }\n    void f (ListNode* root) {\n        if (!root) {\n            return ;\n        }\n        ListNode* first = root-\u003enext;\n        ListNode* second = nullptr;\n        if (first) {\n            second = first-\u003enext;\n        }\n        if (second) {\n            ListNode* snext = second-\u003enext;\n            second-\u003enext = first ;\n            root-\u003enext = second;\n            first-\u003enext = snext; \n            f(first);\n        }\n    }\n};\n"},{"id":"160","name":" Intersection of Two Linked Lists","language":"cpp","code":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        // set\u003cListNode*\u003e  cache;\n        // if(headA == NULL or headB == NULL){\n        //     return NULL;\n        // }\n        // while(headA != NULL){\n        //     cache.insert(headA);\n        //     headA = headA-\u003enext;\n        // }\n        // while(headB){\n        //     if(cache.count(headB)){\n        //         return headB;\n        //     }\n        //     headB = headB-\u003enext;\n        // }\n        // return NULL ;\n        \n          ListNode* pa = headA, *pb = headB;\n        while (pa != pb) {\n            if(pa!=NULL)\n                pa = pa-\u003enext;\n            else\n                pa = headB;\n            if(pb!=NULL)\n                pb = pb-\u003enext;\n            else\n                pb = headA;\n        }\n        return pa;\n    }\n};\n"},{"id":"451","name":" Sort Characters By Frequency","language":"java","code":"class Solution {\n    private static class CustomSorter {\n        private char[] arr;\n        private StringBuilder sb;\n​\n        public CustomSorter(char[] arr) {\n            super();\n            this.arr = arr;\n        }\n​\n        public void sort() {\n            Map\u003cCharacter, Integer\u003e map = new HashMap\u003c\u003e();\n            for (char x : this.arr)\n                map.put(x, map.getOrDefault(x, 0) + 1);\n            TreeMap\u003cInteger, List\u003cCharacter\u003e\u003e rmap = new TreeMap\u003c\u003e(Collections.reverseOrder());\n            for (Map.Entry\u003cCharacter, Integer\u003e kv : map.entrySet()) {\n                char key = kv.getKey();\n                int value = kv.getValue();\n                rmap.putIfAbsent(value, new ArrayList\u003c\u003e());\n                for (int i = 0; i \u003c value; i++)\n                    rmap.get(value).add(key);\n            }\n            sb = new StringBuilder();\n            for (List\u003cCharacter\u003e list : rmap.values())\n                for (char c : list)\n                    sb.append(c);\n        }\n​\n        public String toString() {\n            return sb.toString();\n        }\n    }\n​\n    public String frequencySort(String s) {\n        CustomSorter sorter = new CustomSorter(s.toCharArray());\n        sorter.sort();\n        return sorter.toString();\n    }\n}\n​\n"},{"id":"28","name":" Implement strStr()","language":"java","code":"/* COPIED SOLUTION - DON'T UNDERSTAND THE HOW TO IMPLEMENT */\n​\nclass Solution {\n   public int strStr(String haystack, String needle) {\n    if(haystack==null || needle==null)    \n        return 0;\n \n    if(needle.length() == 0)\n        return 0;\n \n    for(int i=0; i\u003chaystack.length(); i++){\n        if(i + needle.length() \u003e haystack.length())\n            return -1;\n \n        int m = i;\n        for(int j=0; j\u003cneedle.length(); j++){\n            if(needle.charAt(j)==haystack.charAt(m)){\n                if(j==needle.length()-1)\n                    return i;\n                m++;\n            }else{\n                break;\n            }\n \n        }    \n    }   \n \n    return -1;\n}\n}\n"},{"id":"26","name":" Remove Duplicates from Sorted Array","language":"cpp","code":"class Solution {\npublic:\n    int removeDuplicates(vector\u003cint\u003e\u0026 nums) {\n        // auto itr = unique(nums.begin(), nums.end());\n        // nums.resize(distance(nums.begin(), itr));\n        // return nums.size();\n        \n        int n = nums.size();\n        if (n \u003c 2) return n;\n        \n        int tmp = nums[0];\n        int ret = 1;\n        for (int i = 1; i \u003c n; i++) {\n            if (tmp != nums[i]) {\n                nums[ret] = nums[i];\n                ret++;\n                \n                tmp = nums[i];\n            }\n        }\n        \n        return ret;\n    }\n};\n"},{"id":"665","name":" Non-decreasing Array","language":"java","code":"class Solution {\n    public boolean checkPossibility(int[] nums) {\n       boolean changed = false;\n        for (int i = 0; i \u003c nums.length - 1; i++) {\n            if (nums[i] \u003e nums[i + 1]) {\n                if (changed) return false;\n                if (i != 0 \u0026\u0026 nums[i - 1] \u003e nums[i + 1]) {\n                    nums[i + 1] = nums[i];\n                }\n                changed = true;\n            }\n        }\n        return true;\n    }\n}\n"},{"id":"1306","name":" Jump Game III","language":"cpp","code":"class Solution {\n    vector\u003cbool\u003e visited;\n    public:\n    bool canReach(vector\u003cint\u003e\u0026 nums, int start) {\n        int n = nums.size();\n        visited.resize(n+2);\n        queue\u003cint\u003e q;\n        \n        q.push(start);\n        \n        while(!q.empty()) {\n            start = q.front();\n            q.pop();\n            \n            // go start - nums[start]\n            {if(start - nums[start] \u003e= 0 \u0026\u0026 !visited[start]) {\n                if(start - nums[start] == 0 || nums[start] == 0) {\n                    return true;\n                }else if(start - nums[start] \u003e 0) {\n                    visited[start] = true;\n                    q.push(start-nums[start]);\n                }\n            }else {continue;}}\n            // go start + nums[start]\n            {\n                if(start + nums[start] \u003c (int) nums.size()  \u0026\u0026 !visited[start]) {\n                if(start + nums[start] == 0 || nums[start] == 0 ) {\n                    return true;\n                }else if (start - nums[start] \u003e 0) {\n                    visited[start] = true;\n                    q.push(start+nums[start]);\n                }\n            }else {continue;}\n            }\n        }\n        return false;\n    \n        // bool ans = dfs(nums, start);\n        // return ans;\n    }\n​\n    bool dfs(vector\u003cint\u003e \u0026nums, int start) {\n        if(start \u003c 0 || start \u003e= (int) nums.size() || visited[start]) {\n            return false;\n        }\n        visited[start] = true;\n        if(nums[start] == 0){\n            return true;\n        }\n        bool ans1 = dfs(nums, start + nums[start]);\n        bool ans2 = dfs(nums, start - nums[start]);\n        return ans1 || ans2;\n    }\n};\n"},{"id":"3","name":" Longest Substring Without Repeating Characters","language":"cpp","code":"class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n       if (s.empty()){return 0;}\n​\n        map\u003cint, int\u003e cache ;\n        int st = 0, len=1;\n        for (int end = 0; end \u003c (int) s.length(); end++) {\n            char ch = s[end];\n            if (cache.count(ch) \u0026\u0026 st \u003c= cache[ch]) {\n                st = cache[ch]+1;\n            }\n            len = max(len, end-st+1);\n            cache[ch]=end;\n        }\n​\n        return len;\n    }\n};\n"},{"id":"160","name":" Intersection of Two Linked Lists","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        return this.IntersectionNodeInTwoLL(headA, headB) ;\n    }\n    \n    public ListNode IntersectionNodeInTwoLL(ListNode headA, ListNode headB) {\n        int n = getLength(headA);\n        int m = getLength(headB);\n\n        int diff = Math.abs(n - m);\n        ListNode intersectionPoint = null;\n\n        if (n \u003e m) {\n            intersectionPoint = getIntersection(headA, headB, diff);\n        } else {\n            intersectionPoint = getIntersection(headB, headA, diff);\n        }\n\n        return intersectionPoint;\n    }\n\n    private ListNode getIntersection(ListNode headA, ListNode headB, int diff) {\n\n        ListNode slow = headB;\n        ListNode fast = headA;\n\n        for (int i = 0; i \u003c diff; i++) fast = fast.next;\n\n        while (fast != slow) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n\n        return slow;\n    }\n\n    private static int getLength(ListNode node) {\n        int len = 0;\n        while (node != null) {\n            node = node.next;\n            len++;\n        }\n        return len;\n    }\n\n    \n}\n"},{"id":"279","name":" Perfect Squares","language":"java","code":"class Solution {\n    public int numSquares(int n) {\n        int[] dp = new int[n + 1];\n        for (int i = 1; i \u003c= n; i++) {\n            dp[i] = n;\n            for (int j = 1; j * j \u003c= i; j++) {\n                int sq = j * j;\n                dp[i] = Math.min(dp[i], 1 + dp[i - sq]);\n            }\n        }\n        return dp[n];\n    }\n​\n    private Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e();\n​\n    private int func(int n) {\n        if (n \u003c= 0) {\n            return n == 0 ? 0 : Integer.MAX_VALUE;\n        }\n        if (map.containsKey(n))\n            return map.get(n);\n            \n        int miniways = Integer.MAX_VALUE;\n        for (int i = 1; i * i \u003c= n; i++) {\n            int c = 1 + func(n - (i * i));\n            map.put(n, c);\n            miniways = Math.min(miniways, c);\n        }\n        return miniways;\n    }\n​\n}\n"},{"id":"452","name":" Minimum Number of Arrows to Burst Balloons","language":"java","code":"class Solution {\n   // Finds the minimum number of arrows needed to burst all balloons\n   public int findMinArrowShots(int[][] points) {\n        // Sort the balloons by the end position of the arrow\n        Arrays.sort(points, (a, b) -\u003e Integer.compare(a[1],b[1]));\n        \n        // Initialize the number of arrows needed to 1\n        int result = 1;\n        // Set the index of the previously burst balloon to 0\n        int previous = 0;\n        \n        // Iterate through all balloons\n        for(int current = 1; current \u003c points.length; current++){\n            // If the start position of the current balloon is after the end position of the arrow that burst the previous balloon,\n            // then a new arrow is needed to burst the current balloon\n            if(points[current][0] \u003e points[previous][1]){\n                result++;\n                // Update the index of the previously burst balloon\n                previous = current;\n            }\n        }\n        return result;            \n    }\n}\n"},{"id":"1306","name":" Jump Game III","language":"java","code":"class Solution {\n    private int[] arr;\n    private Set\u003cInteger\u003e visited = new HashSet\u003c\u003e();\n    \n    public boolean canReach(int[] nums, int start) {\n        arr = nums;\n        boolean ans = isPossibleToReach(start);\n        return ans;\n    }\n    \n    private boolean isPossibleToReach(int curIndex) {\n        \n        if (curIndex \u003c 0 || curIndex \u003e= arr.length)\n            return false;\n        \n        if (this.visited.contains(curIndex) == true)\n            return false;\n        \n        if (this.arr[curIndex] == 0) return true;\n        \n        this.visited.add(curIndex);\n        \n        boolean ans = false;\n        if (isPossibleToReach(curIndex + this.arr[curIndex]) == true) ans = true;\n        else if (isPossibleToReach(curIndex - this.arr[curIndex]) == true) ans = true;\n        \n        // backtrack\n        this.visited.remove(curIndex);\n        \n        return ans;\n    }\n}\n"},{"id":"669","name":" Trim a Binary Search Tree","language":"cpp","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int low, int high) {\n        if (root==NULL) {return NULL;}\n        if(root-\u003eval \u003c low)    {\n            return trimBST(root-\u003eright, low, high);\n        }\n        else if (root-\u003eval \u003e high) {\n            return trimBST(root-\u003eleft, low, high);\n        }\n        else {\n            root-\u003eleft = trimBST(root-\u003eleft, low, high);\n            root-\u003eright = trimBST(root-\u003eright, low, high);\n            return root;\n        }\n    }\n};\n"},{"id":"300","name":" Longest Increasing Subsequence","language":"java","code":"class Solution {\n   public int lengthOfLIS (int [] arr) {\n       int n = arr.length;\n          int lis[] = new int[n];\n          int i,j,max = 0;\n \n           for ( i = 0; i \u003c n; i++ )\n              lis[i] = 1;\n \n           for ( i = 1; i \u003c n; i++ )\n              for ( j = 0; j \u003c i; j++ )\n                         if ( arr[i] \u003e arr[j] \u0026\u0026\n                                  lis[i] \u003c lis[j] + 1)\n                    lis[i] = lis[j] + 1;\n \n           for ( i = 0; i \u003c n; i++ )\n              if ( max \u003c lis[i] )\n                 max = lis[i];\n \n            return max;\n    }\n}\n"},{"id":"283","name":" Move Zeroes","language":"cpp","code":"class Solution {\npublic:\n    void moveZeroes(vector\u003cint\u003e\u0026 nums) {\n        int x = 0;\n        for(int i = 0; i \u003c nums.size(); i++){\n            if(nums[i] != 0){\n                nums[x++] = nums[i];\n            }\n        }\n        for(int i = x; i \u003c (int) nums.size(); i++){\n            nums[i] = 0;\n        }\n    }\n};\n"},{"id":"304","name":" Range Sum Query 2D - Immutable","language":"java","code":"public class NumMatrix {\n    int [][] sum;\n \n    public NumMatrix(int[][] matrix) {\n        if(matrix==null || matrix.length==0||matrix[0].length==0)\n            return;\n \n        int m = matrix.length;\n        int n = matrix[0].length;\n        sum = new int[m][n];\n \n        for(int i=0; i\u003cm; i++){\n            int sumRow=0;\n            for(int j=0; j\u003cn; j++){\n                if(i==0){\n                    sumRow += matrix[i][j];\n                    sum[i][j]=sumRow;\n                }else{\n                    sumRow += matrix[i][j];\n                    sum[i][j]=sumRow+sum[i-1][j];\n                }\n \n            }\n        }\n    }\n \n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        if(this.sum==null) \n            return 0;\n \n        int topRightX = row1;\n        int topRightY = col2;\n \n        int bottomLeftX=row2;\n        int bottomLeftY= col1;\n \n        int result=0;\n"},{"id":"310","name":" Minimum Height Trees","language":"java","code":"import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\n​\nclass Solution {\n    public List\u003cInteger\u003e findMinHeightTrees(int n, int[][] edges) {\n        List\u003cInteger\u003e result = new ArrayList\u003c\u003e();\n​\n        if (n \u003c= 0) {\n            return result;\n        }\n​\n        if (n == 1) {\n            result.add(0);\n            return result;\n        }\n​\n        int[] degrees = new int[n];\n        Map\u003cInteger, List\u003cInteger\u003e\u003e adjacentLists = new HashMap\u003c\u003e();\n​\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n​\n            degrees[u] += 1;\n            degrees[v] += 1;\n​\n            adjacentLists.putIfAbsent(u, new ArrayList\u003c\u003e());\n            adjacentLists.putIfAbsent(v, new ArrayList\u003c\u003e());\n​\n            adjacentLists.get(u).add(v);\n            adjacentLists.get(v).add(u);\n        }\n​\n        Queue\u003cInteger\u003e queue = new LinkedList\u003c\u003e();\n​\n        for (int node = 0; node \u003c degrees.length; node++) {\n            if (degrees[node] == 1) {\n                queue.add(node);\n            }\n        }\n​\n        while (n \u003e 2) {\n            int size = queue.size();\n            n -= size;\n​\n            while (size \u003e 0) {\n                int u = queue.poll();\n                for (int v : adjacentLists.get(u)) {\n                    degrees[v] -= 1;\n​\n                    if (degrees[v] == 1) {\n                        queue.add(v);\n                    }\n​\n                }\n​\n                size--;\n            }\n        }\n​\n        return new ArrayList\u003c\u003e(queue);\n    }\n}\n"},{"id":"131","name":" Palindrome Partitioning","language":"java","code":"class Solution {\n    public List\u003cList\u003cString\u003e\u003e partition(String s) {\n        List\u003cList\u003cString\u003e\u003eresult=new ArrayList\u003c\u003e();\n        List\u003cString\u003eset=new ArrayList\u003c\u003e();\n        func(s,0,set,result);\n        return result;\n    }\n​\n    private void func(String s, int current_index, List\u003cString\u003e set, List\u003cList\u003cString\u003e\u003e result) {\n        if (current_index\u003e=s.length()){\n            result.add(new ArrayList\u003c\u003e(set));\n            return;\n        }\n        for (int i=current_index;i\u003cs.length();i++){\n            if (is_palindrome(s,current_index,i)){\n                set.add(s.substring(current_index,i+1));\n                func(s,i+1,set,result);\n                set.remove(set.size()-1);\n            }\n        }\n    }\n​\n    private boolean is_palindrome(String s, int start, int end) {\n        while (start\u003cend){\n            if (s.charAt(start)!=s.charAt(end))return false;\n            start++;\n            end--;\n        }\n        return true;\n    }\n}\n"},{"id":"454","name":" 4Sum II","language":"java","code":"// https://leetcode.com/problems/4sum-ii/\nclass Solution {\n    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n        int answer = 0;\n​\n        Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e();\n        for (int a : nums1) {\n            for (int b : nums2) {\n                int sum = a + b;\n                map.put(sum, map.getOrDefault(sum, 0) + 1);\n            }\n        }\n​\n        for (int a : nums3) {\n            for (int b : nums4) {\n                int sum = a + b;\n​\n                if (map.containsKey(-1*sum)) {\n                    answer += map.get(-1*sum);\n                }\n            }\n        }\n​\n        return answer;\n    }\n}\n"},{"id":"303","name":" Range Sum Query - Immutable","language":"java","code":"public class NumArray {\n\n    class SegmentTreeNode {\n        private int start, end;\n        private  SegmentTreeNode left, right;\n        private  int sum;\n\n        public SegmentTreeNode(int start, int end) {\n            this.start = start;\n            this.end = end;\n            this.left = null;\n            this.right = null;\n            this.sum = 0;\n        }\n    }\n\n    SegmentTreeNode root = null;\n\n    public NumArray(int[] nums) {\n        root = buildTree(nums, 0, nums.length-1);\n    }\n    // TC : O(n)\n    private SegmentTreeNode buildTree(int[] nums, int start, int end) {\n        if (start \u003e end) {\n            return null;\n        } else {\n            SegmentTreeNode ret = new SegmentTreeNode(start, end);\n            if (start == end) {\n                ret.sum = nums[start]; // leaf nodes\n            } else {\n                int mid = start  + (end - start) / 2;\n                ret.left = buildTree(nums, start, mid);\n                ret.right = buildTree(nums, mid + 1, end);\n                ret.sum = ret.left.sum + ret.right.sum;\n            }\n            return ret;\n        }\n    }\n\n    // TC : O(logn)\n    void update(int i, int val) {\n        updateHelper(root, i, val);\n    }\n\n    void updateHelper(SegmentTreeNode root, int pos, int val) {\n        if (root.start == root.end) {\n            root.sum = val;\n        } else {\n            int mid = root.start + (root.end - root.start) / 2;\n            if (pos \u003c= mid) {\n\n                updateHelper(root.left, pos, val);\n            } else {\n                updateHelper(root.right, pos, val);\n            }\n            root.sum = root.left.sum + root.right.sum;\n        }\n    }\n\n    public int sumRange(int i, int j) {\n        return sumRangeHelper(root, i, j);\n    }\n\n    // TC : O(logn)\n    public int sumRangeHelper(SegmentTreeNode root, int start, int end) {\n        if (root.start == start \u0026\u0026 root.end == end ) {\n            return root.sum;\n        } else {\n\n            int mid = root.start + (root.end - root.start) / 2; \n            if (end \u003c= mid) {\n                return sumRangeHelper(root.left, start, end);\n            } else if (start \u003e= mid+1) {\n                return sumRangeHelper(root.right, start, end);\n            }  else {\n                return  sumRangeHelper(root.left, start, mid) + sumRangeHelper(root.right, mid+1, end) ;\n            }\n        }\n    }\n}\n"},{"id":"290","name":" Word Pattern","language":"py","code":"class Solution:\n    def wordPattern(self, pattern: str, str: str) -\u003e bool:\n        str = str.split(' ')\n        if  not len(str) == len(pattern):\n                return False\n        return len(set(zip(pattern, str))) == len(set(str)) == len(set(pattern))\n"},{"id":"162","name":" Find Peak Element","language":"cpp","code":"class Solution {\npublic:\n    int findPeakElement(vector\u003cint\u003e\u0026 nums) {\n        // int n = nums.size();\n        // int lo = 0, hi = n-1;   \n        // while(lo \u003c hi) {\n        //     int mid = lo+(hi-lo)/2;\n        //     if(nums[mid] \u003c nums[mid+1]){\n        //         lo = mid + 1;\n        //     }\n        //     else {\n        //         hi = mid;\n        //     }\n        // }\n        // return lo;\n        \n        int maxelem = *max_element(nums.begin(), nums.end());\n        return find(nums.begin(), nums.end(), maxelem) - nums.begin();\n    }\n};\n"},{"id":"670","name":" Maximum Swap","language":"java","code":"class Solution {\n    public int maximumSwap(int num) {\n        StringBuilder answer = new StringBuilder(\"\" + num);\n​\n        int i = 0;\n        int j = answer.length() - 1;\n        int max_ = -1;\n        int id_ = -1;\n        int id__ = 0;\n​\n        while (j \u003e i) {\n            int digit = answer.charAt(j) - '0';\n            int self = answer.charAt(i) - '0';\n​\n            if (digit \u003e self \u0026\u0026 digit \u003e max_) {\n                max_ = digit;\n                id_ = j;\n                id__ = i;\n            }\n            j--;\n            if (j == i \u0026\u0026 id_ == -1) {\n                i++;\n                j = answer.length() - 1;\n            }\n        }\n        if (id_ != -1) {\n            System.out.println(id__ + \" \" + id_);\n            char t = answer.charAt(id__);\n            answer.setCharAt(id__, answer.charAt(id_));\n            answer.setCharAt(id_, t);\n        }\n​\n        return Integer.parseInt(answer.toString());\n    }\n}\n"},{"id":"322","name":" Coin Change","language":"java","code":"class Solution {\n    public int coinChange(int[] coins, int amount) {\n           int n = coins.length;\n    \n    int dp[] = new int[amount + 1];    \n     dp[0] = 0;        //  amount = 0 can be made by excuding every coin\n    if(amount \u003e 0 \u0026\u0026 coins == null) return 0;\n     for(int i = 1; i \u003c= amount; i++) {\n        dp[i] = 100000;       // if no coin is available we return a large number or infinity\n    }\n    \n    for(int i = 1; i \u003c= n; i++) {\n        for(int j = coins[i-1]; j \u003c= amount; j++) {\n            if(j \u003e= coins[i-1]) {\n                dp[j] =  Math.min(1 + dp[j-coins[i-1]], dp[j]);  // minimum of (Include , Exclude)\n            } else { \n                dp[j] = dp[j];  // else exlude the current coin \n            }\n        }\n    }\n    return dp[amount] \u003e amount ? -1 : dp[amount];\n    }\n}\n"},{"id":"46","name":" Permutations","language":"java","code":"class Solution {\n    public List\u003cList\u003cInteger\u003e\u003e permute(int[] nums) {\n        List\u003cList\u003cInteger\u003e\u003e permutations = new ArrayList\u003c\u003e();\n        permute(nums, permutations, 0);\n        return permutations;\n    }\n​\n    private void permute(int[] nums, List\u003cList\u003cInteger\u003e\u003e permutations, int currentIndex) {\n        // TODO Auto-generated method stub\n        if (nums.length == currentIndex) {\n            permutations.add(toList(nums));\n            return;\n        }\n​\n        for (int i = currentIndex; i \u003c nums.length; i++) {\n            swap(nums, currentIndex, i);\n            permute(nums, permutations, currentIndex + 1);\n            swap(nums, currentIndex, i);\n        }\n    }\n​\n    private List\u003cInteger\u003e toList(int[] nums) {\n        // TODO Auto-generated method stub\n        List\u003cInteger\u003e list = new ArrayList\u003c\u003e();\n        for (int x : nums)\n            list.add(x);\n        return list;\n    }\n​\n    private void swap(int[] nums, int currentIndex, int i) {\n        // TODO Auto-generated method stub\n        int t = nums[currentIndex];\n        nums[currentIndex] = nums[i];\n        nums[i] = t;\n    }\n}\n​\n"},{"id":"315","name":" Count of Smaller Numbers After Self","language":"java","code":"    public static void main(String[] args) throws IOException {\n        FastScanner fs = new FastScanner();\n        int n = fs.nextInt();\n        int[] arr = fs.readArray(n);\n        List\u003cInteger\u003e ans = new MinimumAfterSelf().countSmaller(arr);\n        System.out.println(ans);\n    }\n​\n    // Optimation Using BST / MinHeap\n​\n    class Node {\n        Node left;\n        Node right;\n        int data;\n        int count;\n​\n        Node(int d, Node l, Node r) {\n            this.data = d;\n            this.left = l;\n            this.right = r;\n            this.count = 1;\n        }\n    }\n​\n    public List\u003cInteger\u003e countSmaller(int[] nums) {\n        /*\n         * Build BST and Count\n         */\n​\n        final int n = nums.length;\n        List\u003cInteger\u003e smallers = new ArrayList\u003cInteger\u003e();\n        if (nums == null || nums.length == 0)\n            return smallers;\n​\n        Node root = new Node(nums[n - 1], null, null);\n        smallers.add(0);\n​\n        for (int i = n - 2; i \u003e= 0; i--) {\n            int smallerElems = construct(root, nums[i]);\n            smallers.add(smallerElems);\n        }\n        Collections.reverse(smallers);\n        return smallers;\n    }\n​\n    private int construct(Node root, int data) {\n        // TODO Auto-generated method stub\n        int smallerNodes = 0;\n​\n        while (true) {\n            if (data \u003c= root.data) {\n                // go left\n                root.count++;\n                if (root.left == null) {\n                    root.left = new Node(data, null, null);\n                    break;\n                } else {\n                    root = root.left;\n                }\n            } else {\n                // go right\n                smallerNodes += root.count;\n                if (root.right == null) {\n                    root.right = new Node(data, null, null);\n                    break;\n                } else {\n                    root = root.right;\n                }\n            }\n"},{"id":"1329","name":" Sort the Matrix Diagonally","language":"cpp","code":"class Solution {\n    int R, C;\npublic:\n    void sort(vector\u003cvector\u003cint\u003e\u003e \u0026mat, int row, int col) {\n        vector\u003cint\u003e temp;\n        int r = row, c = col;\n        while(r \u003c R \u0026\u0026 c \u003c C) {\n            temp.push_back(mat[r++][c++]);\n        }\n        std::sort(temp.rbegin(), temp.rend());\n        r = row, c = col;\n        while (r \u003c R \u0026\u0026 c \u003c C) {\n            mat[r++][c++] = temp.back();\n            temp.pop_back();\n        }\n    }\n    vector\u003cvector\u003cint\u003e\u003e diagonalSort(vector\u003cvector\u003cint\u003e\u003e\u0026 mat) {\n        if(mat.empty()){\n            return {{}};\n        }\n        R = mat.size();\n        C = mat[0].size();\n        for (int col = 0; col \u003c C; col++) {\n            sort(mat,0,col);\n        }\n        for (int row = 1; row \u003c R; row++) {\n            sort(mat,row,0);\n        }\n        return mat;\n    }\n};\n"},{"id":"162","name":" Find Peak Element","language":"java","code":"class Solution {\n    public int findPeakElement(int[] nums) {\n        \n        // Quick implementation of BinarySearch,\n        // as it needs to be solved in O(LogN)\n        \n        int lo = 0;\n        int hi = nums.length - 1;\n        while (lo \u003c hi) {\n            int mid = (lo + hi) / 2;\n            if (nums[mid] \u003c nums[mid + 1]) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n        return lo;\n    }\n}\n"},{"id":"295","name":" Find Median from Data Stream","language":"java","code":"class MedianFinder {\n​\n    /** initialize your data structure here. */\n​\n    private List\u003cInteger\u003e list;\n​\n    // actually we need 2 Priority Queues, one for left half and one for right\n    PriorityQueue\u003cInteger\u003e firstHalf;\n    PriorityQueue\u003cInteger\u003e secondHalf;\n​\n    public MedianFinder() {\n        this.list = new ArrayList\u003cInteger\u003e();\n        this.firstHalf = new PriorityQueue\u003c\u003e(Collections.reverseOrder());\n        this.secondHalf = new PriorityQueue\u003c\u003e();\n    }\n​\n    public void addNum(int num) {\n        this.list.add(num);\n        if (secondHalf.isEmpty() == false \u0026\u0026 secondHalf.peek() \u003c num) {\n            this.secondHalf.add(num);\n        } else {\n            this.firstHalf.add(num);\n        }\n​\n        if (this.firstHalf.size() - this.secondHalf.size() == 2) {\n            this.secondHalf.add(this.firstHalf.poll());\n        } else if (this.secondHalf.size() - this.firstHalf.size() == 2) {\n            this.firstHalf.add(this.secondHalf.poll());\n        }\n    }\n​\n    public double findMedian() {\n        int size1 = this.firstHalf.size();\n        int size2 = this.secondHalf.size();\n​\n        if (size1 == size2) {\n            return (this.firstHalf.peek() + this.secondHalf.peek()) / 2.0;\n        } else if (size1 \u003e= size2) {\n            return this.firstHalf.peek();\n        } else if (size1 \u003c size2) {\n            return this.secondHalf.peek();\n        } else {\n            // do nothing\n        }\n        return -1;\n    }\n}\n​\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder obj = new MedianFinder();\n * obj.addNum(num);\n * double param_2 = obj.findMedian();\n */\n"},{"id":"309","name":" Best Time to Buy and Sell Stock with Cooldown","language":"java","code":"class Solution {\n    public int maxProfit(int[] prices) {\n         if(prices == null || prices.length \u003c= 1) return 0;\n​\n            int b0 = -prices[0], b1 = b0;\n            int s0 = 0, s1 = 0, s2 = 0;\n​\n            for(int i = 1; i \u003c prices.length; i++) {\n                b0 = Math.max(b1, s2 - prices[i]);\n                s0 = Math.max(s1, b1 + prices[i]);\n                b1 = b0; s2 = s1; s1 = s0; \n            }\n            return s0;   \n    }\n}\n"},{"id":"684","name":" Redundant Connection","language":"java","code":"/*\n    Question e find that edge for that the tree converted into graph\n    Find the last edge who cause cycle in the structure\n​\n    boils down to find the edge for whom the cycle is forming.\n    *** Cycle detection but DFS use cannot be possible ***\n​\n */\nclass Solution {\n    public int[] findRedundantConnection(int[][] edges) {\n        int[] parent = new int[edges.length + 1];\n        Arrays.fill(parent, -1);\n​\n        int[] ans = new int[2];\n​\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n​\n            if (parent[u] == -1) parent[u] = u;\n            if (parent[v] == -1) parent[v] = v;\n​\n            int leader_u = find(parent, u);\n            int leader_v = find(parent, v);\n​\n            if (leader_u != leader_v) {\n                parent[leader_v] = leader_u;\n            } else {\n                ans = edge;\n                break;\n            }\n        }\n        return ans;\n    }\n​\n    private int find(int[] parent, int f) {\n        return (parent[f] == f) ? f : find(parent, parent[f]);\n    }\n}\n"},{"id":"46","name":" Permutations","language":"py","code":"class Solution:\n    def permute(self, nums: List[int]) -\u003e List[List[int]]:\n        from itertools import permutations\n        return list(permutations(nums))\n"},{"id":"324","name":" Wiggle Sort II","language":"java","code":"class Solution {\n    // leetcode 324. https://leetcode.com/problems/wiggle-sort-ii/\n    public void wiggleSort(int[] nums) {\n        int n = nums.length;\n        int[] arr = new int[n]; // dupliicate array\n​\n        for(int i = 0; i \u003c n; i++)\n            arr[i] = nums[i];\n​\n        Arrays.sort(arr);\n​\n        int j = n - 1;\n        int i = 1;\n​\n        // fill odd index\n        while(i \u003c n) {\n            nums[i] = arr[j];\n            j--;\n            i += 2;\n        }\n​\n        // fill even index\n        i = 0;\n        while(i \u003c n) {\n            nums[i] = arr[j];\n            j--;\n            i += 2;\n        }\n    }\n    \n}\n"},{"id":"326","name":" Power of Three","language":"cpp","code":"class Solution {\npublic:\n    bool isPowerOfThree(int n) {\n       return (n \u003e 0) \u0026\u0026 pow(3,19) % n == 0;\n    }\n};\n"},{"id":"31","name":" Next Permutation","language":"cpp","code":"class Solution {\npublic:\n    void nextPermutation(vector\u003cint\u003e\u0026 nums) {\n        next_permutation(nums.begin(), nums.end());\n    }\n};\n"},{"id":"69","name":" Sqrt(x)","language":"py","code":"class Solution:\n    def mySqrt(self, x: int) -\u003e int:\n        \n        left, right = 0,  x\n        while left \u003c= right:\n            mid = left + (right - left) // 2\n​\n            if mid * mid \u003e x:\n                right = mid - 1\n            elif mid * mid \u003c x:\n                left = mid + 1\n            else:\n                return mid\n​\n        # left \u003e right\n        return right\n"},{"id":"318","name":" Maximum Product of Word Lengths","language":"java","code":"class Solution {\n    public int maxProduct(String[] words) {\n        int ans = Integer.MIN_VALUE;\n        final int n = words.length;\n​\n        for (int i = 0; i \u003c n; i++) {\n            String word1 = words[i];\n            HashSet\u003cCharacter\u003e set = this.prepareHashSet(word1);\n​\n            int innerMax = Integer.MIN_VALUE;\n            for (int j = i + 1; j \u003c n; j++) {\n                String word2 = words[j];\n                boolean status = false;\n​\n                for (Character c : word2.toCharArray()) {\n                    if (set.contains(c)) {\n                        status = true;\n                        break;\n                    }\n                }\n                if (status == false) {\n                    innerMax = Math.max(innerMax, word2.length());\n                }\n            }\n            ans = Math.max(ans, innerMax * word1.length());\n        }\n​\n        return ans == Integer.MIN_VALUE ? 0 : ans;\n    }\n​\n    private HashSet\u003cCharacter\u003e prepareHashSet(String word1) {\n        // TODO Auto-generated method stub\n        HashSet\u003cCharacter\u003e set = new HashSet\u003c\u003e();\n        for (Character c : word1.toCharArray()) {\n            set.add(c);\n        }\n        return set;\n    }\n}\n"},{"id":"460","name":" LFU Cache","language":"java","code":"class LFUCache {\n    // key: original key, value: frequency and original value.\n    private Map\u003cInteger, Pair\u003cInteger, Integer\u003e\u003e cache;\n    // key: frequency, value: All keys that have the same frequency.\n    private Map\u003cInteger, LinkedHashSet\u003cInteger\u003e\u003e frequencies;\n    private int minf;\n    private int capacity;\n    \n    private void insert(int key, int frequency, int value) {\n        cache.put(key, new Pair\u003c\u003e(frequency, value));\n        frequencies.putIfAbsent(frequency, new LinkedHashSet\u003c\u003e());\n        frequencies.get(frequency).add(key);\n    }\n​\n    public LFUCache(int capacity) {\n        cache = new HashMap\u003c\u003e();\n        frequencies = new HashMap\u003c\u003e();\n        minf = 0;\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        Pair\u003cInteger, Integer\u003e frequencyAndValue = cache.get(key);\n        if (frequencyAndValue == null) {\n            return -1;\n        }\n        final int frequency = frequencyAndValue.getKey();\n        final Set\u003cInteger\u003e keys = frequencies.get(frequency);\n        keys.remove(key);\n        if (minf == frequency \u0026\u0026 keys.isEmpty()) {\n            ++minf;\n        }\n        final int value = frequencyAndValue.getValue();\n        insert(key, frequency + 1, value);   \n        return value;\n    }\n    \n    public void put(int key, int value) {\n        if (capacity \u003c= 0) {\n            return;\n        }\n        Pair\u003cInteger, Integer\u003e frequencyAndValue = cache.get(key);\n        if (frequencyAndValue != null) {\n            cache.put(key, new Pair\u003c\u003e(frequencyAndValue.getKey(), value));\n            get(key);\n            return;\n        }\n        if (capacity == cache.size()) {\n            final Set\u003cInteger\u003e keys = frequencies.get(minf);\n            final int keyToDelete = keys.iterator().next();\n            cache.remove(keyToDelete);\n            keys.remove(keyToDelete);\n        }\n        minf = 1;\n        insert(key, 1, value);\n    }\n}\n"},{"id":"1626","name":" Best Team With No Conflicts","language":"java","code":"class Solution {\n    public int bestTeamScore(int[] scores, int[] ages) {\n        final int n = ages.length;\n        int[][] ageScorePair = new int[n][2];\n​\n        for (int i = 0; i \u003c n; i++) {\n            ageScorePair[i][0] = ages[i];\n            ageScorePair[i][1] = scores[i];\n        }\n​\n        // Sort in ascending order of age and then by score.\n        Arrays.sort(ageScorePair, (a,b) -\u003e a[0] == b[0] ? a[1]-b[1] : a[0]-b[0]);\n        // Initially, all states are null, denoting not yet calculated.\n        Integer[][] dp = new Integer[n][n];\n​\n        return findMaxScore(dp, ageScorePair, -1, 0);\n    }\n​\n    private int findMaxScore(Integer[][] dp, int[][] ageScorePair, int prev, int index) {\n        // Return 0 if we have iterated over all the players.\n        if (index \u003e= ageScorePair.length) {\n            return 0;\n        }\n​\n        // We have already calculated the answer, so no need to go into recursion.\n        if (dp[prev + 1][index] != null) {\n            return dp[prev + 1][index];\n        }\n​\n        // If we can add this player, return the maximum of two choices we have.\n        if (prev == -1 || ageScorePair[index][1] \u003e= ageScorePair[prev][1]) {\n            return dp[prev + 1][index] = Math.max(findMaxScore(dp, ageScorePair, prev, index + 1),\n                    ageScorePair[index][1] + findMaxScore(dp, ageScorePair, index, index + 1));\n        }\n​\n        // This player cannot be added; return the corresponding score.\n        return dp[prev + 1][index] = findMaxScore(dp, ageScorePair, prev, index + 1);\n    }\n​\n}\n"},{"id":"328","name":" Odd Even Linked List","language":"go","code":"/**\n * Definition for singly-linked list.\n * type ListNode struct {\n *     Val int\n *     Next *ListNode\n * }\n */func oddEvenList(head *ListNode) *ListNode {\n    if head == nil || head.Next == nil {\n        return head\n    }\n    \n    \n    second := head.Next\n    \n    tmp := head\n    odd := head\n    even := head.Next\n    count := 1\n    \n    for tmp != nil {\n        if count % 2 != 0 \u0026\u0026 tmp != head {\n            odd.Next = tmp\n            odd = tmp\n        } \n        if count % 2 == 0 \u0026\u0026 tmp != second {\n            even.Next = tmp\n            even = tmp\n        }\n        tmp = tmp.Next\n        count += 1\n    }\n    \n    even.Next = nil\n    odd.Next = second\n    \n    return head\n}\n"},{"id":"133","name":" Clone Graph","language":"java","code":"/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List\u003cNode\u003e neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList\u003cNode\u003e();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList\u003cNode\u003e();\n    }\n    public Node(int _val, ArrayList\u003cNode\u003e _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n​\nclass Solution {\n    Map\u003cInteger, Node\u003e map = new HashMap\u003c\u003e();\n​\n    public Node cloneGraph(Node node) {\n        return _cloneGraph(node);\n    }\n​\n    private Node _cloneGraph(Node node) {\n        if (node == null) {\n            return null;\n        }\n​\n        if (map.containsKey(node.val)) {\n            return map.get(node.val);\n        }\n​\n        Node nnode = new Node(node.val);\n        map.putIfAbsent(node.val, nnode);\n​\n        for (Node neighbour : node.neighbors) {\n            Node rres = _cloneGraph(neighbour);\n            nnode.neighbors.add(rres);\n        }\n​\n        return nnode;\n    }\n}\n"},{"id":"332","name":" Reconstruct Itinerary","language":"java","code":"class Solution {\n    private class Node {\n        String value;\n        List\u003cString\u003e adjacentNodes;\n\n        public Node(String value, List\u003cString\u003e adjacentNodes) {\n            this.value = value;\n            this.adjacentNodes = adjacentNodes;\n        }\n    }\n\n    public List\u003cString\u003e findItinerary(List\u003cList\u003cString\u003e\u003e tickets) {\n        /**\n         * actually this problem is nothing but a dijsktra algorithm.\n         * and dijsktra is nothing but a typical PQ + BFS\n         *\n         * so as JKF is the source node for all cases, we will find 1:m the shortest path\n         * push adjacent dictionary order {node} by popping out from PQ.\n         *\n         * do this until PQ gets empty()\n         */\n\n        Map\u003cString, List\u003cString\u003e\u003e graph = new HashMap\u003c\u003e();\n        for (List\u003cString\u003e ticketInfo : tickets) {\n            String fromNode = ticketInfo.get(0);\n            String toNode = ticketInfo.get(1);\n\n            graph.putIfAbsent(fromNode, new ArrayList\u003c\u003e());\n            graph.get(fromNode).add(toNode);\n        }\n        System.out.println(graph);\n\n        /**\n         * Map{fromNode, PQ{}}\n         */\n\n        List\u003cString\u003e orderDestinations = new ArrayList\u003c\u003e();\n        PriorityQueue\u003cString\u003e queue = new PriorityQueue\u003c\u003e();\n        queue.add(\"JFK\");\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            // for all neighbour from node\n            orderDestinations.add(node);\n            List\u003cString\u003e neighbours = graph.get(node);\n            while (neighbours != null \u0026\u0026 !neighbours.isEmpty()){\n                String popped = neighbours.remove(neighbours.size()-1);\n                queue.add(popped);\n            }\n        }\n\n        return orderDestinations;\n    }\n}\n"},{"id":"33","name":" Search in Rotated Sorted Array","language":"java","code":"class Solution {\n\tpublic int search(int[] nums, int target) {\n\t\tint lo = 0;\n\t\tint hi = nums.length - 1;\n\n\t\twhile (lo \u003c hi) {\n\t\t\tint mid = (lo + hi) / 2;\n\t\t\tint midelem = nums[mid];\n\n\t\t\tif (midelem == target)\n\t\t\t\treturn mid;\n\n\t\t\tif (nums[lo] \u003c= midelem) {\n\t\t\t\tif (nums[lo] \u003c= target \u0026\u0026 target \u003c midelem) {\n\t\t\t\t\thi = mid - 1;\n\t\t\t\t} else {\n\t\t\t\t\tlo = mid + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (midelem \u003c target \u0026\u0026 target \u003c= nums[hi]) {\n\t\t\t\t\tlo = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\thi = mid - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn nums[lo] == target ? lo : -1;\n\t}\n}\n"},{"id":"692","name":" Top K Frequent Words","language":"java","code":"class Solution {\n    public List\u003cString\u003e topKFrequent(String[] words, int k) {\n        List\u003cString\u003e result = new ArrayList\u003c\u003e();\n        Map\u003cString, Integer\u003e frequencyMap = new HashMap\u003c\u003e();\n        for (String word : words) {\n            frequencyMap.put(word, frequencyMap.getOrDefault(word, 0) + 1);\n        }\n        WordsQueue wordsQueue = new WordsQueue();\n        for (Map.Entry\u003cString, Integer\u003e kvPair : frequencyMap.entrySet()) {\n            wordsQueue.add(kvPair);\n            // normal heap logic for top = `K` results\n            if (wordsQueue.size() \u003e k) {\n                wordsQueue.poll();\n            }\n        }\n​\n        while (!wordsQueue.isEmpty()) {\n            Map.Entry\u003cString, Integer\u003e polled = wordsQueue.poll();\n            result.add(polled.getKey());\n        }\n        // because result so far has ASC order in\n        Collections.reverse(result);\n​\n        return result;\n    }\n​\n    private class WordsQueue extends PriorityQueue\u003cMap.Entry\u003cString, Integer\u003e\u003e {\n        public WordsQueue() {\n            // min heap implication --\n            super((a, b) -\u003e {\n                if (a.getValue() == b.getValue()) {\n                    return b.getKey().compareTo(a.getKey());\n                }\n​\n                return a.getValue() - b.getValue();\n            });\n        }\n    }\n}\n"},{"id":"336","name":" Palindrome Pairs","language":"java","code":"class Solution {\n   // TC: O(n * (word.lenth ^ 2)) nearly\n    public List\u003cList\u003cInteger\u003e\u003e palindromePairs(String[] words) {\n        List\u003cList\u003cInteger\u003e\u003e res = new ArrayList\u003cList\u003cInteger\u003e\u003e();\n        Map\u003cString, Integer\u003e map = new HashMap\u003cString, Integer\u003e();\n​\n        for (int i = 0; i \u003c words.length; ++i) {\n            map.put(words[i], i);\n        }\n​\n        // Blank string | add by default all palindromes\n        if (map.containsKey(\"\")) {\n            int blankIdx = map.get(\"\");\n            for (int i = 0; i \u003c words.length; ++i) {\n                if (i != blankIdx \u0026\u0026 isPalindrome(words[i])) {\n                    res.add(Arrays.asList(blankIdx, i));\n                    res.add(Arrays.asList(i, blankIdx));\n                }\n            }\n        }\n​\n        // alike: aab | baa presents\n        for (int i = 0; i \u003c words.length; ++i) {\n            String reversed = new StringBuilder(words[i]).reverse().toString();\n            Integer reversedIdx = map.get(reversed);\n            if (reversedIdx != null \u0026\u0026 reversedIdx != i) {\n                res.add(Arrays.asList(i, reversedIdx));\n            }\n        }\n​\n        // 1 TC\n        for (int i = 0; i \u003c words.length; ++i) {\n            String cur = words[i];\n            for (int cut = 1; cut \u003c cur.length(); ++cut) {\n                String left = cur.substring(0, cut);\n                String right = cur.substring(cut);\n                if (isPalindrome(left)) {\n                    String reversedRight = new StringBuilder(right).reverse().toString();\n                    if (map.containsKey(reversedRight)) {\n                        res.add(Arrays.asList(map.get(reversedRight), i));\n                    }\n                }\n                if (isPalindrome(right)) {\n                    String reversedLeft = new StringBuilder(left).reverse().toString();\n                    if (map.containsKey(reversedLeft)) {\n                        res.add(Arrays.asList(i, map.get(reversedLeft)));\n                    }\n                }\n            }\n        }\n        return res;\n    }\n​\n    private boolean isPalindrome(String word) {\n        int i = 0, j = word.length() - 1;\n        while (i \u003c j) {\n            if (word.charAt(i++) != word.charAt(j--))\n                return false;\n        }\n        return true;\n    }\n}\n"},{"id":"328","name":" Odd Even Linked List","language":"java","code":"class Solution {\n    public ListNode oddEvenList(ListNode head) {\n        ListNode doddIndices = new ListNode(-1);\n        ListNode devenIndices = new ListNode(-1);\n​\n        ListNode oddIndices = doddIndices;\n        ListNode evenIndices = devenIndices;\n        ListNode node = head;\n        int index = 0;\n        while (node != null) {\n            boolean isEven = (index % 2 == 0);\n            if (isEven) {\n                evenIndices.next = new ListNode(node.val);\n                evenIndices = evenIndices.next;\n            } else {\n                oddIndices.next = new ListNode(node.val);\n                oddIndices = oddIndices.next;\n            }\n            node = node.next;\n            index++;\n        }\n        evenIndices.next = doddIndices.next;\n        return devenIndices.next;\n    }\n}\n"},{"id":"328","name":" Odd Even Linked List","language":"cpp","code":"using Node = ListNode;\nclass Solution {\npublic:\n    ListNode* oddEvenList(ListNode* root) {\n        if (root == nullptr || root-\u003enext == nullptr) {\n            return root;\n        }\n        Node *even = nullptr, *odd = nullptr, *tmp = root;\n        Node* t = nullptr, *p = nullptr; int c = 1;\n        while(tmp != nullptr) {\n            if (c \u0026 1) {\n                if (odd == nullptr) {\n                    odd = new Node(tmp-\u003eval);\n                    t = odd;\n                } else {\n                    Node *newnode = new Node(tmp-\u003eval);\n                    odd-\u003enext = newnode;\n                    odd = newnode;\n                }\n            } else {\n                if (even == nullptr) {\n                    even = new Node(tmp-\u003eval);\n                    p = even;\n                }else {\n                    Node *newnode = new Node(tmp-\u003eval);\n                    even-\u003enext = newnode;\n                    even = newnode;\n                }\n            }\n            tmp = tmp-\u003enext;\n            c++;\n        }\n        odd-\u003enext = p;\n        root = t;\n        return root;\n    }\n};\n"},{"id":"34","name":" Find First and Last Position of Element in Sorted Array","language":"cpp","code":"class Solution {\npublic:\n    vector\u003cint\u003e searchRange(vector\u003cint\u003e\u0026 nums, int target) {\n        if(nums.empty()){\n            return {-1,-1} ;\n        }\n        if(binary_search(nums.begin(), nums.end(), target) == false){\n            return {-1,-1} ;\n        }\n        int lo = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\n        int hi = upper_bound(nums.begin(), nums.end(), target) - nums.begin();\n        return {lo, hi-1} ;   \n    }\n};\n"},{"id":"472","name":" Concatenated Words","language":"java","code":"class Solution {\n    public List\u003cString\u003e findAllConcatenatedWordsInADict(String[] words) {\n        Set\u003cString\u003e s = new HashSet\u003c\u003e();\n        List\u003cString\u003e concatenateWords = new ArrayList\u003c\u003e();\n        for(String word : words)\n            s.add(word);\n        for(String word : words) {\n            if(checkConcatenate(word, s) == true)\n                concatenateWords.add(word);\n        }\n        return concatenateWords;\n    }\n    public boolean checkConcatenate(String word, Set\u003cString\u003e s) {\n        for(int i = 1; i \u003c word.length(); i++) {\n            String prefixWord = word.substring(0, i);\n            String suffixWord = word.substring(i, word.length());\n            if(s.contains(prefixWord) \u0026\u0026 (s.contains(suffixWord) || checkConcatenate(suffixWord, s)))\n                return true;\n        }\n        return false;\n    }\n}\n​\n"},{"id":"695","name":" Max Area of Island","language":"cpp","code":"class Solution {\n    int H,W;\n    vector\u003cvector\u003cint\u003e\u003e grid;\n    int dfs(int row, int col) {\n        if((row \u003c 0 || row \u003e= H )|| (col \u003c 0 || col \u003e= W) || grid[row][col]==0) {\n            return 0;\n        }\n        grid[row][col]=0;\n​\n        int count = 1;\n        count += dfs(row+1,col) + dfs(row-1,col) + dfs(row,col+1) + dfs(row,col-1);\n        return count;\n    };\n​\npublic:\n    int maxAreaOfIsland(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) {\n        grid = matrix;\n        H = matrix.size(), W = matrix[0].size();\n        int maxarea = 0;\n        for (int row = 0; row \u003c H; row++) {\n            for (int col = 0; col \u003c W; col++) {\n                if (grid[row][col]) {\n                    maxarea = max(maxarea, dfs(row, col));\n                }\n            }\n        }\n        return maxarea;\n    }\n};\n"},{"id":"344","name":" Reverse String","language":"cpp","code":"class Solution {\npublic:\n    void reverseString(vector\u003cchar\u003e\u0026 s) {\n       reverse(s.begin(), s.end());\n    }\n};\n"},{"id":"345","name":" Reverse Vowels of a String","language":"java","code":"class Solution {\n    private boolean isVowel(char ch) {\n        String vowels = \"aeiouAEIOU\";\n        return vowels.contains(ch + \"\");\n    }\n    public String reverseVowels(String s) {\n        char[] arr = s.toCharArray();\n​\n        int left = 0;\n        int right = arr.length - 1;\n​\n        while(left \u003c right) {\n            // make left pointer at vowel\n            while(left \u003c right \u0026\u0026 isVowel(arr[left]) == false) {\n                left++;\n            }\n​\n            // make right pointer at vowel\n            while(left \u003c right \u0026\u0026 isVowel(arr[right]) == false) {\n                right--;\n            }\n​\n            char temp = arr[left];\n            arr[left] = arr[right];\n            arr[right] = temp;\n​\n            left++;\n            right--;\n        }\n​\n        return String.valueOf(arr);\n    }\n}\n"},{"id":"473","name":" Matchsticks to Square","language":"java","code":"class Solution {\n    public boolean makesquare(int[] matchsticks) {\n        final int n = matchsticks.length;\n        if (n \u003c 4)\n            return false;\n​\n        int peri = 0;\n        for (int x : matchsticks)\n            peri += x;\n​\n        if (peri % 4 != 0)\n            return false;\n​\n        int side = peri / 4;\n        int[] sides = new int[] { side, side, side, side };\n​\n        return _makeSqaure(matchsticks, sides, 0);\n    }\n​\n    private boolean _makeSqaure(int[] matchsticks, int[] sides, int i) {\n        // TODO Auto-generated method stub\n        if (i \u003e= matchsticks.length) {\n            boolean side1 = sides[0] == 0 \u0026\u0026 sides[2] == 0;\n            boolean side2 = sides[1] == 0 \u0026\u0026 sides[3] == 0;\n            return side1 \u0026\u0026 side2;\n        }\n​\n        for (int j = 0; j \u003c sides.length; j++) {\n            if (matchsticks[i] \u003e sides[j])\n                continue;\n            else {\n                sides[j] -= matchsticks[i];\n                // System.out.println(\"Pre: \" + Arrays.toString(sides));\n                if (_makeSqaure(matchsticks, sides, i + 1) == true)\n                    return true;\n                sides[j] += matchsticks[i];\n                // System.out.println(\"Post: \" + Arrays.toString(sides));\n            }\n        }\n​\n        return false;\n    }\n}\n"},{"id":"814","name":" Binary Tree Pruning","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode pruneTree(TreeNode root) {\n        if(root==null) return null;\n        root.left=pruneTree(root.left);\n        root.right=pruneTree(root.right);\n        if(root.left!=null || root.right!=null || root.val==1)\n            return root;\n        return null;\n    }\n    \n    public TreeNode pruneTree2(TreeNode root) {\n        if (root == null) return null;\n        this.containsOne(root);\n        return root;\n    }\n​\n    private boolean containsOne(TreeNode root) {\n        if (root == null) return false;\n​\n        // faith\n        boolean rrleft = this.containsOne(root.left);\n        boolean rrright = this.containsOne(root.right);\n​\n        if (rrleft == false) root.left = null; // meaning deleting whole left subtree\n        if (rrright == false) root.right = null; // // meaning deleting whole right subtree\n​\n        int myval = root.val;\n        boolean mystatus = myval == 1;\n​\n        return mystatus || rrleft || rrright; // because either one will work for us\n    }\n}\n"},{"id":"938","name":" Range Sum of BST","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int sum = 0;\n​\n    public int rangeSumBST(TreeNode root, int low, int high) {\n        _rangeSumBST(root, low, high);\n        return this.sum;\n    }\n​\n    public void _rangeSumBST(TreeNode root, int low, int high) {\n        if (root == null)\n            return;\n​\n        int data = root.val;\n        // faith\n        if (data \u003e= low)\n            _rangeSumBST(root.left, low, high);\n​\n        if (data \u003e= low \u0026\u0026 data \u003c= high)\n            sum += data;\n​\n        if (data \u003c= high)\n            _rangeSumBST(root.right, low, high);\n    }\n}\n"},{"id":"78","name":" Subsets","language":"cpp","code":"class Solution {\npublic:\n    \n    void dfs(vector\u003cvector\u003cint\u003e\u003e \u0026subsets, vector\u003cint\u003e \u0026nums, int index, vector\u003cint\u003e current){\n​\n        subsets.push_back(current);\n        for(int i = index; i \u003c nums.size(); i++){\n            current.push_back(nums[i]);\n            dfs(subsets, nums, i+1, current);\n            current.pop_back();\n        }\n    }\n    \n    vector\u003cvector\u003cint\u003e\u003e subsets(vector\u003cint\u003e\u0026 nums) {\n        vector\u003cvector\u003cint\u003e\u003e subsets;\n        dfs(subsets, nums, 0, vector\u003cint\u003e());\n        return subsets;\n    }\n};\n"},{"id":"83","name":" Remove Duplicates from Sorted List","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode root) {\n        ListNode dummy = new ListNode(-9999999);\n        ListNode temp = dummy;\n​\n        ListNode head = root;\n        while(head != null) {\n            if(temp.val != head.val) {\n                temp.next = new ListNode(head.val);\n                temp = temp.next;\n            }\n            head = head.next;\n        }\n        return dummy.next;\n    }\n}\n"},{"id":"88","name":" Merge Sorted Array","language":"cpp","code":"class Solution {\npublic:\nvoid merge(vector\u003cint\u003e\u0026 nums1, int m, vector\u003cint\u003e\u0026 nums2, int n) {\n    int i=0,j=0,k=0;\n    while (j\u003cn \u0026\u0026 i\u003c=(m+n) ){\n        if(i\u003e=(m+j)){ \n            nums1[i]=nums2[j];\n            j++;\n        } \n        else if(nums1[i]\u003e=nums2[j]) {\n            nums1.erase(nums1.begin()+m+k);\n            nums1.insert(nums1.begin()+i,nums2[j]);\n            j++;\n            k++;\n        }\n        i++;\n        }\n    }\n};\n"},{"id":"94","name":" Binary Tree Inorder Traversal","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private List\u003cInteger\u003e result;\n    public List\u003cInteger\u003e inorderTraversal(TreeNode root) {\n        result = new ArrayList\u003c\u003e();\n        _inorderTraversal(root);\n        return result;\n    }\n​\n    private void _inorderTraversal(TreeNode root) {\n​\n        if (root == null) {\n            return ;\n        }\n        // faith\n        _inorderTraversal(root.left);\n        this.result.add(root.val);\n        _inorderTraversal(root.right);\n    }\n}\n"},{"id":"876","name":" Middle of the Linked List","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n​\n        if (head == null || head.next == null) return head;\n​\n        ListNode slow_pointer = head;\n        ListNode fast_pointer = head;\n​\n        while (fast_pointer != null \u0026\u0026 fast_pointer.next != null) {\n            slow_pointer = slow_pointer.next;\n            fast_pointer = fast_pointer.next.next;\n        }\n​\n        return slow_pointer;\n        \n    }\n}\n"},{"id":"880","name":" Decoded String at Index","language":"java","code":"class Solution {\n    public String decodeAtIndex(String s, int K) {\n          if (s.length()==0) {\n            return null;\n        }\n​\n        long size = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                size = size * (c-'0');\n            }else {size++ ;}\n        }\n        System.out.println(\"Size of the string : \" + size);\n​\n        char[] carray = s.toCharArray();\n        for (int index = carray.length-1; index \u003e= 0; index--) {\n            char x = carray[index];\n            System.out.print(x);\n            K %= size;\n            if ((K==0 || K==size) \u0026\u0026 Character.isLetter(x)) {\n                return Character.toString(x) ;\n            } else if (Character.isDigit(x)) {\n                size = size / (x-'0');\n            } else {\n                size-- ;\n            }\n        }\n        return null;\n    }\n}\n"},{"id":"783","name":" Minimum Distance Between BST Nodes","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private TreeNode previousNode = null;\n    private int minimumSoFar = Integer.MAX_VALUE;\n​\n    public int minDiffInBST(TreeNode root) {\n        if (root.left != null)\n            this.minDiffInBST(root.left);\n        if (previousNode != null) this.minimumSoFar = Math.min(this.minimumSoFar, root.val - previousNode.val);\n        this.previousNode = root;\n        if (root.right != null)\n            this.minDiffInBST(root.right);\n        return this.minimumSoFar;\n    }\n}\n"},{"id":"525","name":" Contiguous Array","language":"java","code":"class Solution {\n    public int findMaxLength(int[] nums) {\n        return getMaxWindow(nums);\n    }\n    \n    // TC-O(N), SC: O(N)\n    public int getMaxWindow(int[] arr) {\n        final int n = arr.length;\n        int maxWindowLength = 0; // (higherIndex - lowerIndex + 1)\n        int runningSum = 0;\n​\n        Map\u003cInteger, Integer\u003e seen = new HashMap\u003c\u003e(); // stores the runningSum indices\n        seen.put(0, -1); // dummy value for initialization\n​\n        for (int index = 0; index \u003c n; index++) {\n            int elem = arr[index];\n​\n            runningSum = getRunningSum(runningSum, elem);\n            maxWindowLength = updateTheWindowLength(maxWindowLength, runningSum, seen, index);\n        }\n​\n        return maxWindowLength;\n    }\n​\n    private int updateTheWindowLength(int maxlength, int runningSum, Map\u003cInteger, Integer\u003e seen, int index) {\n        if (seen.containsKey(runningSum) == false) {\n            seen.put(runningSum, index);\n        } else {\n            int alreadyPresentedLowerIndex = seen.get(runningSum);\n            int windowLength = index - alreadyPresentedLowerIndex;\n            maxlength = Math.max(maxlength, windowLength);\n        }\n        // System.out.println(\"running sum: \" + runningSum + \", window Len so far: \" + maxlength);\n        return maxlength;\n    }\n​\n    private int getRunningSum(int runningSum, int elem) {\n        if (elem == 0) {\n            runningSum++;\n        } else runningSum--;\n        return runningSum;\n    }\n​\n}\n"},{"id":"1335","name":" Minimum Difficulty of a Job Schedule","language":"java","code":"class Solution {\n    public int minDifficulty(int[] k, int d) {\n        if(d \u003e k.length) return -1;\n        \n        //we now have a cache!\n        //don't really need a row for the last day\n        int[][] cache = new int[d-1][k.length];\n        for(int[] day : cache) Arrays.fill(day, -1);\n        \n        return dfs(k, d-1, 0, cache);\n    }\n    \n    private int dfs(int[] k, int d, int pos, int[][] cache) {\n        //base case\n        if(d == 0) {\n            int max = k[pos];\n            for(int i = pos; i \u003c k.length; i++) max = Math.max(max, k[i]);\n            return max;\n        } \n        \n        //just making sure we start indexing from 0\n        int day = cache.length-d;\n        \n        //we already have this in the cache, just return it right here\n        if(cache[day][pos] != -1) return cache[day][pos];\n        \n        // same logic as naive recursion\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        for(int i = pos; i \u003c k.length-d; i++) {\n            max = Math.max(max, k[i]);\n            min = Math.min(min, max + dfs(k, d-1, i+1, cache));\n        }\n        \n        // but now we're also updating the cache the first time we calculate this\n        return cache[day][pos] = min;\n    }\n}\n"},{"id":"523","name":" Continuous Subarray Sum","language":"java","code":"class Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n        return this.optimized(nums, k);\n    }\n​\n    private boolean optimized(int[] nums, int k) {\n        /**\n         * as this is a continuos subarray we can leverage prefix sum concept\n         * map = {0, -1};\n         * prefixsum += arr[i] % k;\n         * map.put(prefixsum, i);\n         * if (map.contains prefixsum \u0026\u0026 prefixsum == 0) return true with i -\n         * map[predixsum] \u003e= 2;\n         */\n​\n        int n = nums.length;\n        int prefixSum = 0;\n        Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e(); // \u003csum, index\u003e\n        map.put(0, -1); // {special case to conform the check}\n​\n        for (int i = 0; i \u003c n; i++) {\n            prefixSum = (prefixSum + nums[i]) % k;\n            if (map.containsKey(prefixSum)) {\n                int start = map.get(prefixSum);\n                int windowsize = i - start;\n                if (windowsize \u003e= 2) {\n                    return true;\n                }\n            } else {\n                map.put(prefixSum, i);\n            }\n        }\n​\n        // if (map.containsKey(prefixSum)) {\n        //     int start = map.get(prefixSum);\n        //     int windowsize = n - start;\n        //     if (windowsize \u003e= 2) {\n        //         return true;\n        //     }\n        // }\n​\n        return false;\n    }\n​\n    private boolean bruteforoce(int[] nums, int k) {\n        int n = nums.length;\n        boolean isFound = false;\n​\n        for (int i = 0; i \u003c n; i++) {\n            int cursum = nums[i];\n            boolean _isFound = false;\n            for (int j = i + 1; j \u003c n; j++) {\n                cursum += nums[j];\n                int windowlength = j - i + 1;\n                if (windowlength \u003e= 2 \u0026\u0026 (cursum % k) == 0) {\n                    _isFound = true;\n                    break;\n                }\n            }\n            if (_isFound) {\n                isFound = true;\n                break;\n            }\n        }\n​\n        return isFound;\n    }\n}\n"},{"id":"886","name":" Possible Bipartition","language":"java","code":"class Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        Map\u003cInteger, List\u003cInteger\u003e\u003e graph = buildGraph(n, dislikes);\n//\t\t\treturn isBipartite(graph);\n\n        UnionFind uf = new UnionFind(n);\n\n        for (int i = 1; i \u003c n + 1; i++) {\n            List\u003cInteger\u003e neighbors = graph.get(i);\n            if (neighbors == null || neighbors.size() == 0)\n                continue;\n            int firstNeighbor = neighbors.iterator().next(); // gets the first item in the set\n\n            for (int neighbor : neighbors) {\n                if (uf.isConnected(i, neighbor))\n                    return false; // if vertex i is connected with any of its neighbors, graph is not bipartite\n                uf.union(firstNeighbor, neighbor); // unionize all its neighbors\n            }\n        }\n\n        return true;\n    }\n\n    private static class UnionFind {\n        int[] parent;\n        int[] rank;\n\n        public UnionFind(int n) {\n            parent = new int[n + 1];\n            rank = new int[n + 1];\n\n            for (int i = 0; i \u003c n + 1; i++) {\n                parent[i] = i;\n            }\n        }\n\n        public void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n\n            if (rootX != rootY) {\n                if (rank[rootX] \u003e rank[rootY]) {\n                    rank[rootX]++;\n                    parent[rootY] = rootX;\n                } else {\n                    rank[rootY]++;\n                    parent[rootX] = rootY;\n                }\n            }\n        }\n\n        public int find(int x) {\n            if (parent[x] == x)\n                return x;\n\n            int root = find(parent[x]);\n            parent[x] = root; // path compression\n            return root;\n        }\n\n        public boolean isConnected(int x, int y) {\n            return find(x) == find(y);\n        }\n    }\n\n    public boolean isBipartite(Map\u003cInteger, List\u003cInteger\u003e\u003e graph) {\n        // Array representing the colors\n        int[] colors = new int[graph.size()];\n\n        // DFS of each node\n        for (int i = 1; i \u003c graph.size(); i++) {\n            // If uncolored, then perform DFS\n            if (colors[i] == 0 \u0026\u0026 !hasEvenCycle(graph, colors, i, 1))\n                return false;\n        }\n\n        return true;\n    }\n\n    // Return true when graph is bipartite\n    public boolean hasEvenCycle(Map\u003cInteger, List\u003cInteger\u003e\u003e graph, int[] colors, int node, int c) {\n        // if node is colored, node color is same as sent in func definition, return\n        // true\n        if (colors[node] != 0)\n            return colors[node] == c;\n\n        // Color the current node with color sent in func definition\n        colors[node] = c;\n\n        // Check for all the adjecent nodes of the current node \"node\"\n        for (int n : graph.get(node)) {\n            if (!hasEvenCycle(graph, colors, n, -c))\n                return false;\n        }\n\n        return true;\n\n    }\n\n    private Map\u003cInteger, List\u003cInteger\u003e\u003e buildGraph(int n, int[][] dislikes) {\n        // TODO Auto-generated method stub\n        Map\u003cInteger, List\u003cInteger\u003e\u003e graph = new HashMap\u003c\u003e();\n\n        for (int[] edge : dislikes) {\n            int u = edge[0];\n            int v = edge[1];\n            graph.putIfAbsent(u, new ArrayList\u003c\u003e());\n            graph.putIfAbsent(v, new ArrayList\u003c\u003e());\n\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n\n        return graph;\n    }\n}\n"},{"id":"695","name":" Max Area of Island","language":"java","code":"class Solution {\n    private class Pair {\n        int x;\n        int y;\n​\n        Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n​\n    private int[] dx = new int[] { 1, -1, 0, 0 };\n    private int[] dy = new int[] { 0, 0, 1, -1 };\n    private int maxarea = 0;\n​\n    public void area(int[][] grid, Pair start, boolean[][] visited){\n        int n = grid.length;\n        int m = grid[0].length;\n        Queue\u003cPair\u003e queue = new LinkedList\u003c\u003e();\n        if(visited[start.x][start.y] == true) return;\n        queue.add(start);\n        int curarea = 1;\n        while (queue.isEmpty() == false) {\n            Pair p = queue.remove();\n            visited[p.x][p.y] = true;\n            for (int k = 0; k \u003c 4; k++) {\n                int nx = p.x + dx[k];\n                int ny = p.y + dy[k];\n​\n                if (nx \u003e= 0 \u0026\u0026 nx \u003c n \u0026\u0026 ny \u003e= 0 \u0026\u0026 ny \u003c m) {\n                    if (grid[nx][ny] == 1 \u0026\u0026 visited[nx][ny] == false) {\n                        curarea++;\n                        visited[nx][ny] = true;\n                        queue.add(new Pair(nx, ny));\n                    }\n                }\n            }\n            \n        }\n        // System.out.println( start.x + \" \" + start.y + \" \" + curarea);\n        this.maxarea = Math.max(curarea, this.maxarea);\n    }\n    \n    public int maxAreaOfIsland(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        boolean[][] visited = new boolean[n][m];\n        \n​\n        for (int i = 0; i \u003c n; i++) {\n            for (int j = 0; j \u003c m; j++) {\n                if (grid[i][j] == 1) {\n                    Pair start = new Pair(i, j);\n                    area(grid, start, visited);\n                }\n            }\n        }\n​\n        \n​\n        return this.maxarea;\n    }\n}\n"},{"id":"48","name":" Rotate Image","language":"java","code":"class Solution {\n    public void rotate(int[][] matrix) {\n        int R = matrix.length;\n        int C = matrix[0].length;\n​\n        // find tranpose of matrix\n        for (int i = 0; i \u003c R; i++) {\n            for (int j = i + 1; j \u003c C; j++) {\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            }\n        }\n        // reverse each row\n        for (int i = 0; i \u003c R; i++) {\n            for (int j = 0; j \u003c C / 2; j++) {\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[i][C - 1 - j];\n                matrix[i][C - 1 - j] = temp;\n            }\n        }\n    }\n}\n"},{"id":"835","name":" Image Overlap","language":"java","code":"class Solution {\n    public int largestOverlap(int[][] img1, int[][] img2) {\n        int R = img1.length;\n        int C = img1.length;\n​\n        int maxoverlaps = 0;\n        for (int row = -R; row \u003c R; row++) {\n            for (int col = -C; col \u003c C; col++) {\n                int currentOverlap = solver(img1, img2, row, col, R, C);\n                maxoverlaps = Math.max(maxoverlaps, currentOverlap);\n            }\n        }\n​\n        return maxoverlaps;\n    }\n​\n    private int solver(int[][] img1, int[][] img2, int crow, int ccol, int R, int C) {\n        int count = 0;\n        for (int row = 0; row \u003c R; row++) {\n            for (int col = 0; col \u003c C; col++) {\n                int nrw = row + crow;\n                int ncl = col + ccol;\n                if (isSafeArea(nrw, ncl, R, C) \u0026\u0026 hasPixel(img1[row][col], img2[nrw][ncl])) {\n                    count++;\n                }\n            }\n        }\n​\n        return count;\n    }\n​\n    private boolean hasPixel(int p1, int p2) {\n        return (p1 == 1) \u0026\u0026 (p1 == p2);\n    }\n​\n    private boolean isSafeArea(int nrw, int ncl, int r, int c) {\n        return nrw \u003e= 0 \u0026\u0026 nrw \u003c r \u0026\u0026 ncl \u003e= 0 \u0026\u0026 ncl \u003c c;\n    }\n}\n"},{"id":"53","name":" Maximum Subarray","language":"cpp","code":"using arr = vector\u003cint\u003e;\nconst int inf = 2e9+18;\nint maxx = -1 * inf;\nclass Solution {\npublic:\n    int maxSubArray(vector\u003cint\u003e\u0026 nums) {\n        int n = nums.size() ;\n        arr dp(n);\n        dp[0] = nums[0];\n        maxx = dp[0];\n        for(int i = 1; i \u003c n; i++){\n            if(dp[i-1] + nums[i] \u003e nums[i]){\n                dp[i] = dp[i-1] + nums[i];\n            }else{\n                dp[i] = nums[i];\n            }\n            maxx = max(dp[i],maxx);\n        }\n        return maxx;\n    }\n};\n"},{"id":"787","name":" Cheapest Flights Within K Stops","language":"java","code":"class Solution {\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        List\u003cList\u003cint[]\u003e\u003e adj = new ArrayList\u003c\u003e();\n        for (int i = 0; i \u003c n; i++) adj.add(new ArrayList\u003c\u003e());\n        for (int[] flight : flights) {\n            adj.get(flight[0]).add(new int[] {flight[1], flight[2]});\n        }\n        Queue\u003cint[]\u003e q = new LinkedList\u003c\u003e();\n        q.offer(new int[] {src, 0});\n        int[] minCost = new int[n];\n        Arrays.fill(minCost, Integer.MAX_VALUE);\n        int stops = 0;\n        while (!q.isEmpty() \u0026\u0026 stops \u003c= k) {\n            int size = q.size();\n            while (size-- \u003e 0) {\n                int[] curr = q.poll();\n                for (int[] neighbour : adj.get(curr[0])) {\n                    int price = neighbour[1], neighbourNode = neighbour[0];\n                    if (price + curr[1] \u003e= minCost[neighbourNode]) continue;\n                    minCost[neighbourNode] = price + curr[1];\n                    q.offer(new int[] {neighbourNode, minCost[neighbourNode]});\n                }\n            }\n            stops++;\n        }\n        return minCost[dst] == Integer.MAX_VALUE ? -1 : minCost[dst];\n    }\n}\n​\n"},{"id":"7","name":" Reverse Integer","language":"cpp","code":"class Solution {\npublic:\n    int reverse(int x) {\n        int ret = 0;\n        int last_digit = 0;\n        while(true) {\n            last_digit = x % 10;\n            ret = ret + last_digit;\n            x = x/10;\n            if (x == 0) break;\n            else {\n                if (ret \u003e INT_MAX/10 || ret \u003c INT_MIN/10) return 0;\n                ret = ret * 10;\n            }\n        }\n        return ret;   \n    }\n};\n"},{"id":"1339","name":" Maximum Product of Splitted Binary Tree","language":"java","code":"class Solution {\n    public int maxProduct(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n​\n        long totalSum = getTotalSum(root);\n        long[] maxsum = new long[] { Integer.MIN_VALUE };\n        runForEachNodeAndUpdateTotalSum(root, totalSum, maxsum);\n        return (int) (maxsum[0] % (int) (1e9 + 7));\n    }\n​\n    private long runForEachNodeAndUpdateTotalSum(TreeNode root, long totalSum, long[] maxsum) {\n        // TODO Auto-generated method stub\n        if (root == null) {\n            return 0;\n        }\n​\n        long leftsum = runForEachNodeAndUpdateTotalSum(root.left, totalSum, maxsum);\n        long rightsum = runForEachNodeAndUpdateTotalSum(root.right, totalSum, maxsum);\n​\n        long temp = leftsum + rightsum + root.val;\n        long probableAnswer = temp * (totalSum - temp);\n        maxsum[0] = Math.max(maxsum[0], probableAnswer);\n​\n        return temp;\n    }\n​\n    private long getTotalSum(TreeNode root) {\n        // TODO Auto-generated method stub\n        if (root == null)\n            return 0;\n        return (long) (getTotalSum(root.left) + root.val + getTotalSum(root.right));\n    }\n}\n​\n"},{"id":"889","name":" Construct Binary Tree from Preorder and Postorder Traversal","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    \n    private TreeNode constructPrePost(int[] pre, int[] post, int preSt, int preEnd, int poSt, int poEnd) {\n        if (preSt == preEnd)\n            return new TreeNode(pre[preSt]);\n​\n        if (preSt \u003e preEnd)\n            return null;\n​\n        TreeNode root = new TreeNode(pre[preSt]);\n        int ele = pre[preSt + 1];\n        int indx = poSt;\n​\n        while (post[indx] != ele) {\n            indx++;\n        }\n        int elementCount = indx - poSt + 1;\n        root.left = constructPrePost(pre, post, preSt + 1, preSt + elementCount, poSt, indx);\n        root.right = constructPrePost(pre, post, preSt + elementCount + 1, preEnd, indx + 1, poEnd - 1);\n        return root;\n    }\n​\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\n        if (pre.length == 0) return null;\n        return constructPrePost(pre, post, 0, pre.length - 1, 0, post.length - 1);\n    }\n}\n"},{"id":"941","name":" Valid Mountain Array","language":"cpp","code":"class Solution {\npublic:\n    bool validMountainArray(vector\u003cint\u003e\u0026 arr) {\n        if(arr.size() \u003c 3) \n        {\n            return false;\n        }\n        int i = 0;\n        for(;i \u003c (int) arr.size()-1; i++) \n        {\n            if(arr[i] \u003e arr[i+1])\n            {\n                i++;\n                break;\n            }\n            else if (arr[i] == arr[i+1])\n            {\n                return false;\n            }\n        }\n        if(i \u003c 2) {\n            return false;\n        }\n​\n        for(; i \u003c (int) arr.size(); i++) \n        {\n            if(arr[i-1] \u003c= arr[i]) {\n                return false;\n            }\n        }\n​\n        return true ;\n    }\n};\n"},{"id":"485","name":" Max Consecutive Ones","language":"java","code":"class Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int n=nums.length;\n        int start=0;\n        int end=0;\n        int cumlength=0;\n        int maxlength=0;\n​\n        while (end\u003cn) {\n            int elem=nums[end];\n            if (elem==1) {\n                ++cumlength;\n            } else {\n                maxlength=Math.max(maxlength,cumlength);\n                // System.out.println(\"CUML=\"+cumlength+\" START=\"+start+\" END=\"+end);\n                start=end;\n                cumlength=0;\n            }\n            end++;\n        }\n        maxlength=Math.max(maxlength,cumlength);\n        return maxlength;\n    }\n}\n"},{"id":"53","name":" Maximum Subarray","language":"java","code":"class Solution {\n    public int maxSubArray(int[] arr) {\n        int n = arr.length;\n        int maximumsum = arr[0];\n        int runningSum = arr[0];\n​\n        for (int i = 1; i \u003c n; i++) {\n            runningSum += arr[i];\n            if (runningSum \u003e arr[i]) {\n                maximumsum = Math.max(maximumsum, runningSum);  \n            } else {\n                runningSum = arr[i];\n                maximumsum = Math.max(maximumsum, runningSum);\n            }\n        }\n​\n        return maximumsum;\n    }\n}\n"},{"id":"838","name":" Push Dominoes","language":"java","code":"class Solution {\n    public String pushDominoes(String dominoes) {\n        StringBuilder sb = new StringBuilder();\n​\n        // we have to construct array of forces for each domino\n        // if +ve -ve or 0\n        // +ve --\u003e right\n        // -ve --\u003e left\n        // 0 --\u003e do nothing || stand still\n​\n        final int n = dominoes.length();\n        int[] forces = new int[n];\n​\n        // calculate forces for right and left\n        // building the answer string\n        calculateRightForces(dominoes, n, forces);\n        calculateLeftForces(dominoes, n, forces);\n        buildOutputString(sb, forces);\n​\n​\n        return sb.toString();\n    }\n​\n    private void buildOutputString(StringBuilder sb, int[] forces) {\n        for (int force : forces) {\n            if (force \u003e 0) {\n                sb.append('R');\n            } else if (force \u003c 0) {\n                sb.append('L');\n            } else {\n                sb.append('.');\n            }\n        }\n    }\n​\n    private void calculateLeftForces(String dominoes, final int n, int[] forces) {\n        int current_force = 0;\n        // left force calculation\n        for (int i = n - 1; i \u003e= 0; i--) {\n            char c = dominoes.charAt(i);\n            if (c == 'L')\n                current_force = n;\n            else if (c == 'R')\n                current_force = 0;\n            else {\n                current_force = Math.max(current_force - 1, 0);\n            }\n            forces[i] -= current_force;\n        }\n    }\n​\n    private void calculateRightForces(String dominoes, final int n, int[] forces) {\n        int current_force = 0;\n        // // right force calculation\n        for (int i = 0; i \u003c n; i++) {\n            char c = dominoes.charAt(i);\n            if (c == 'R')\n                current_force = n; // \"R.......R\" --\u003e \"RRRRRRRRR\" mane sobai k fele debe right e\n            else if (c == 'L')\n                current_force = 0; // \"L.......L\" --\u003e \"LLLLLLLLL\" mane sobai k fele debe left e\n            else {\n                current_force = Math.max(current_force - 1, 0);\n                // current_force = 0;\n                // if (i \u003e 0) {\n                // if (dominoes.charAt(i - 1) == 'R') current_force = n;\n                // else if (dominoes.charAt(i - 1) == 'L') current_force = -n;\n                // }\n            }\n            forces[i] += current_force;\n        }\n    }\n}\n"},{"id":"70","name":" Climbing Stairs","language":"cpp","code":"class Solution {\n    private:\n    int memo[46] = {-1};\npublic:\n    Solution() { memo[0] = memo[1] = 1 ; }\n    int climbStairs(int n) {\n        if(n \u003c= 1){\n            return 1;\n        }\n        if(memo[n]){ return memo[n] ; }\n        return memo[n] = climbStairs(n - 1) + climbStairs(n - 2);\n    }\n};\n"},{"id":"890","name":" Find and Replace Pattern","language":"java","code":"class Solution {\n    \n    public List\u003cString\u003e findAndReplacePattern(String[] words, String pattern) {\n        /*\n            * Question is fairly easy to solve\n            * Think that way.\n            * First generate and number pattern using hasmap.put(key, index++)\n            * iterate all words and generate patternforcurrent word\n            * and just compare using \n            * patternWordPermutation.equals(currwordPattern)\n        */\n        \n        List\u003cString\u003e foundWords = new ArrayList\u003c\u003e();\n        String patternPermutationString = this.generatePermutationString(pattern);\n        // cheeck locally\n        System.out.println(patternPermutationString);\n        // iterate over all words\n        for(String word : words) {\n            if (word.length() == pattern.length()) {\n                String currentWordPermutation = this.generatePermutationString(word);\n                if (patternPermutationString.equals(currentWordPermutation)==true) {\n                    foundWords.add(word);\n                }\n            }\n        }\n​\n        return foundWords;\n    }\n​\n    private String generatePermutationString(String pattern) {\n        HashMap\u003cCharacter, Integer\u003e hashMap = new HashMap\u003c\u003e();\n        int index = 0;\n        StringBuilder permutationString = new StringBuilder();\n​\n        for (int i = 0; i \u003c pattern.length(); i++) {\n            char key = pattern.charAt(i);\n            if (hashMap.containsKey(key) == false) {\n                index++;\n                hashMap.put(key, index);\n            }\n            permutationString.append(hashMap.get(key));\n        }\n        \n        return permutationString.toString();\n    }\n​\n}\n"},{"id":"943","name":" Find the Shortest Superstring","language":"java","code":"class Solution {\n    \n    private String mergeTwoStrings(String a, String b) {\n        int n = a.length();\n        int m = b.length();\n        \n        int overLapped1 = 0;\n        int overLapped2 = 0;\n        \n        for(int i = 1; n - i \u003e= 0 \u0026\u0026 i \u003c= m; i++) {\n            if(a.substring(n - i).equals(b.substring(0, i))) {\n                overLapped1 = i;\n            }\n        }\n        \n        for (int i = 1; m - i \u003e= 0 \u0026\u0026 i \u003c= n; i++) {\n            if (b.substring(m-i).equals(a.substring(0, i))) {\n                overLapped2 = i;\n            }\n        }\n        \n        if (overLapped1 \u003e= overLapped2)\n            return b.substring(0, m - overLapped2) + a;\n        \n        return a.substring(0, n - overLapped1) + b;\n    }\n    \n    public String shortestSuperstring(String[] words) {\n        List\u003cString\u003e listsOfWords = new ArrayList\u003c\u003e(Arrays.asList(words));\n                \n        while(true) {\n            int n = listsOfWords.size();\n            if (n==1)\n                break;\n        \n            int maxLength = -1;\n            int index1 = 0;\n            int index2 = 0;\n            String answer = \"\";\n            \n            for (int i = 0; i \u003c n - 1; i++) {\n                for (int j = i + 1; j \u003c n; j++) {\n                    String a = listsOfWords.get(i);\n                    String b = listsOfWords.get(j);\n                    \n                    String mergedString = this.mergeTwoStrings(a, b);\n                    int computedLength = a.length() + b.length() - mergedString.length();\n                    if (computedLength \u003c maxLength) {\n                        maxLength = computedLength;\n                        index1 = i;\n                        index2 = j;\n                        answer= mergedString;\n                    }\n                }\n            }\n            \n            // remove the processed words and add newly mergedString\n            String a = listsOfWords.get(index1);\n            String b = listsOfWords.get(index2);\n            \n            listsOfWords.remove(a);\n            listsOfWords.remove(b);\n            listsOfWords.add(answer);\n        }\n        \n        return listsOfWords.get(0);\n    }\n}\n"},{"id":"49","name":" Group Anagrams","language":"java","code":"class Solution {\n    public List\u003cList\u003cString\u003e\u003e groupAnagrams(String[] strs) {\n        List\u003cList\u003cString\u003e\u003e result = new ArrayList\u003c\u003e();\n​\n        Map\u003cString, List\u003cString\u003e\u003e map = new HashMap\u003c\u003e();\n        for (String str : strs) {\n            String temp = getDictionaryKey(str);\n            map.putIfAbsent(temp, new ArrayList\u003c\u003e());\n            map.get(temp).add(str);\n        }\n​\n        for (Map.Entry\u003cString, List\u003cString\u003e\u003e kv : map.entrySet()) {\n            result.add(new ArrayList\u003c\u003e(kv.getValue()));\n        }\n​\n        return result;\n    }\n​\n    private String getDictionaryKey(String str) {\n        char[] tempstr = str.toCharArray();\n        Arrays.sort(tempstr);\n        String temp = new String(tempstr);\n        return temp;\n    }\n}\n"},{"id":"134","name":" Gas Station","language":"java","code":"class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        return GasStation.startingStation(gas, cost);\n    }\n}\n​\npublic class GasStation {\n    private static class Station {\n        int index;\n        int cost;\n        int gas;\n        public Station(int index, int cost, int gas) {\n            super();\n            this.index = index;\n            this.cost = cost;\n            this.gas = gas;\n        }\n        @Override\n        public String toString() {\n            return \"Station [index=\" + index + \", cost=\" + cost + \", gas=\" + gas + \"]\";\n        }\n        \n    }\n    public static int startingStation(int[] gases, int[] costs) {\n        int n = gases.length;\n        Station[] stations = new Station[n];\n        for (int i = 0 ; i \u003c n; i++) {\n            stations[i] = new Station(i, costs[i], gases[i]);\n        }\n        \n        int shortage = 0;\n        int stationpoint = 0;\n        int totalShortage = 0;\n        \n        for (Station station : stations) {\n            shortage += (station.gas - station.cost);\n            if (shortage \u003c 0) {\n                shortage = 0;\n                stationpoint = station.index + 1;\n            }\n            totalShortage += (station.gas - station.cost);\n        }\n        \n        if (totalShortage \u003e= 0) {\n            // System.out.println(\"STP: \" + stationpoint);\n            return stationpoint;\n        } else {\n            // System.out.println(\"STP: \" + -1);\n            return -1;\n        }\n    }\n}\n​\n"},{"id":"700","name":" Search in a Binary Search Tree","language":"js","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar searchBST = function (root, val) {\n  if (!root) {\n    return null;\n  }\n​\n  if (root.val == val) {\n    return root;\n  }\n​\n  if (val \u003c root.val) {\n    return searchBST(root.left, val);\n  } else {\n    return searchBST(root.right, val);\n  }\n};\n​\n"},{"id":"897","name":" Increasing Order Search Tree","language":"cpp","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    vector\u003cTreeNode*\u003e nodes;\npublic:\n    TreeNode* increasingBST(TreeNode* root) {\n        if(root == NULL) {\n            return nullptr;\n        }\n        \n        inorder(root);\n        \n        for(int i = 0; i \u003c (int) nodes.size()-1; i++ ) {\n            nodes[i]-\u003eleft = nullptr;\n            nodes[i]-\u003eright = nodes[i+1];\n        }\n        nodes.back()-\u003eleft = nullptr;\n        nodes.back()-\u003eright = nullptr;\n        \n        return nodes[0];\n    }\n    \n    void inorder(TreeNode* root) {\n        if(!root) {\n            return ;\n        }\n        inorder(root-\u003eleft);\n        nodes.push_back(root);\n        inorder(root-\u003eright);\n    }\n};\n"},{"id":"491","name":" Non-decreasing Subsequences","language":"java","code":"class Solution {\n    private void backtrack(int[] nums, int index, List\u003cInteger\u003e sequence,\n            Set\u003cList\u003cInteger\u003e\u003e result) {\n        // if we have checked all elements\n        if (index == nums.length) {\n            if (sequence.size() \u003e= 2) {\n                result.add(new ArrayList\u003c\u003e(sequence));\n            }\n            return;\n        }\n        // if the sequence remains increasing after appending nums[index]\n        if (sequence.isEmpty() ||\n                sequence.get(sequence.size() - 1) \u003c= nums[index]) {\n            // append nums[index] to the sequence\n            sequence.add(nums[index]);\n            // call recursively\n            backtrack(nums, index + 1, sequence, result);\n            // delete nums[index] from the end of the sequence\n            sequence.remove(sequence.size() - 1);\n        }\n        // call recursively not appending an element\n        backtrack(nums, index + 1, sequence, result);\n    }\n​\n    public List\u003cList\u003cInteger\u003e\u003e findSubsequences(int[] nums) {\n        Set\u003cList\u003cInteger\u003e\u003e result = new HashSet\u003cList\u003cInteger\u003e\u003e();\n        List\u003cInteger\u003e sequence = new ArrayList\u003cInteger\u003e();\n        backtrack(nums, 0, sequence, result);\n        return new ArrayList(result);\n    }\n}\n"},{"id":"79","name":" Word Search","language":"cpp","code":"class Solution {\npublic:\n    \nbool dfs(vector\u003cvector\u003cchar\u003e\u003e \u0026board, int row, int col, string \u0026word, int wc)\n{\n    if(wc == (int) word.length()){\n        return true;\n    }\n    if(row \u003c 0 or row \u003e= board.size() or col \u003c 0 or col \u003e= board[row].size() or board[row][col] != word[wc])\n    {\n        return false;\n    }\n    {\n        char temp = board[row][col];\n        board[row][col] = ' ';\n        bool found = (dfs(board, row+1, col, word, wc+1) || dfs(board, row-1, col, word, wc+1)\n                      || dfs(board, row, col+1, word, wc+1) || dfs(board, row, col-1, word, wc+1));\n        board[row][col] = temp;\n        return found;\n    }\n}\n​\n    \n    bool exist(vector\u003cvector\u003cchar\u003e\u003e\u0026 board, string word) {\n        \n        int M = board.size(), N = board[0].size();\n        if(board.empty()){\n            return false;\n        }\n        for(int row = 0; row \u003c M; row++){\n            for(int col = 0; col \u003c N; col++){\n                if(board[row][col] == word[0] \u0026\u0026 dfs(board, row, col, word, 0)){\n                    return true;\n"},{"id":"54","name":" Spiral Matrix","language":"cpp","code":"class Solution {\npublic:\n    vector\u003cint\u003e spiralOrder(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) {\n       vector\u003cint\u003e rez;\n      \n        if(matrix.empty()) {\n        return rez;\n       }\n        \n      int l=0,r=matrix[0].size(),t=0,b = matrix.size(); \n      \n      while(l\u003cr \u0026\u0026 t\u003cb){\n        for(int i = l;i\u003cr;i++) rez.push_back(matrix[t][i]);   // move from left to right\n        t++;\n        if(t==b) break;\n        for(int i = t;i\u003cb;i++) rez.push_back(matrix[i][r-1]);   // move from top to bottom\n        r--;\n        if(l==r) break;\n        for(int i = r-1;i\u003e=l;i--) rez.push_back(matrix[b-1][i]);     // move from right to left\n        b--;\n        if(t==b) break;\n        for(int i = b-1;i\u003e=t;i--) rez.push_back(matrix[i][l]);     //move from bottom to top\n        l++;\n      }\n      return rez;\n    }\n};\n"},{"id":"944","name":" Delete Columns to Make Sorted","language":"java","code":"class Solution {\n      public int minDeletionSize(String[] strs) {\n        int count = 0;\n        for(int i=0; i\u003cstrs[0].length(); i++){\n            for(int j=0; j\u003cstrs.length-1; j++){\n                if(strs[j].charAt(i) \u003e strs[j+1].charAt(i)){\n                    count++;\n                    break;\n                }\n            }\n        }\n        return count;\n    }\n}\n"},{"id":"91","name":" Decode Ways","language":"java","code":"class Solution {\n    public int numDecodings(String s) {\n        /*\n         * 224 2, 2, 4 22, 4 2, 24\n         * \n         * f[i] ---\u003e f[i-1] + s[i-1][i] (1) if \u003c 26 + s[i] (1)\n         */\n//          return _func(s.toCharArray(), 0);\n​\n        final int n = s.length();\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = s.charAt(0) == '0' ? 0 : 1;\n​\n        for (int i = 2; i \u003c dp.length; i++) {\n            int one = Integer.valueOf(s.substring(i - 1, i));\n            int two = Integer.valueOf(s.substring(i - 2, i));\n            System.out.println(\"one=\" + one + \", two=\" + two);\n            if (one \u003e 0) {\n                dp[i] += dp[i - 1];\n            }\n            if (two \u003e= 10 \u0026\u0026 two \u003c= 26) {\n                dp[i] += dp[i - 2];\n            }\n        }\n​\n        return dp[n];\n    }\n​\n    private int _func(char[] charArray, int curindex) {\n        if (curindex == charArray.length)\n            return 1;\n​\n        int onedigit = toNumber(\"\" + charArray[curindex]);\n        if (onedigit == 0)\n            return 0;\n        int count = _func(charArray, curindex + 1);\n        if (curindex + 1 \u003c charArray.length) {\n            int twodigit = toNumber(\"\" + charArray[curindex] + charArray[curindex + 1]);\n            if (twodigit \u003e= 10 \u0026\u0026 twodigit \u003c 27) {\n                count += _func(charArray, curindex + 2);\n            }\n        }\n​\n        return count;\n    }\n​\n    private int toNumber(String string) {\n        // TODO Auto-generated method stub\n        return (int) Integer.parseInt(string);\n    }\n}\n​\n"},{"id":"911","name":" Online Election","language":"cpp","code":"class TopVotedCandidate {\n    map\u003cint, int\u003e vote_count, most_prefered_by_time;\npublic:\n    TopVotedCandidate(vector\u003cint\u003e\u0026 persons, vector\u003cint\u003e\u0026 times) {\n        int max_voted_person = -1;\n        for (int i = 0; i \u003c persons.size(); i++) {\n            int person = persons[i];\n            vote_count[person]++; \n            if(max_voted_person \u003c= vote_count[person]) {\n                max_voted_person = vote_count[person];\n                most_prefered_by_time[times[i]] = person;    \n            }\n            \n        }\n    }\n    \n    int q(int t) {\n     auto itr = most_prefered_by_time.lower_bound(t);\n       if(itr-\u003efirst != t) {\n           itr--;\n       }\n       return itr-\u003esecond;\n    }\n};\n​\n/**\n * Your TopVotedCandidate object will be instantiated and called as such:\n * TopVotedCandidate* obj = new TopVotedCandidate(persons, times);\n * int param_1 = obj-\u003eq(t);\n */\n"},{"id":"701","name":" Insert into a Binary Search Tree","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        return insert(root, val);\n    }\n    \n    // TC: O(logN), SC: O(H)\n    TreeNode insert(TreeNode root, int data) {\n        if (root == null) {\n            return new TreeNode(data);\n        }\n​\n        if (root.val \u003e data) {\n            root.left = insert(root.left, data);\n        }\n        else {\n            root.right = insert(root.right, data);\n        }\n​\n        return root;\n    }\n}\n"},{"id":"540","name":" Single Element in a Sorted Array","language":"java","code":"class Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int n=nums.length;\n        if (n==1) return nums[0];\n​\n        if (nums[0]!=nums[1]) return nums[0];\n        if(nums[n-1]!=nums[n-2]) return nums[n-1];\n​\n        int lo=0;\n        int hi=n-1;\n​\n        while (lo \u003c= hi) {\n            int mid=(lo+hi)/2;\n            if(nums[mid]!=nums[mid-1] \u0026\u0026 nums[mid]!=nums[mid+1]) return nums[mid];\n            else if (nums[mid]==nums[mid-1]) {\n                int left_count=mid-lo+1;\n                if (left_count%2==0) {\n                    lo=mid+1;\n                } else {\n                    hi=mid-2;\n                }\n            } else if (nums[mid]==nums[mid+1]) {\n                int right_count=hi-mid+1;\n                if (right_count%2==0) {\n                    hi=mid-1;\n                } else {\n                    lo=mid+2;\n                }\n            }\n        }\n        \n        return -1;\n    }\n}\n"},{"id":"946","name":" Validate Stack Sequences","language":"java","code":"class Solution {\n    public boolean validateStackSequences(int[] pushed, int[] popped) {\n        /*\n        * there is no spcl. algo for that, just traverse and use 2-pointer approch\n        * and carefully remove the stack.peek() == popped[j] ? stack.pop() : break ;\n        * after pushing all elems into stack, now traverse from jth to popped.length\n        * similar check for that also!\n        */\n        int n = pushed.length, j = 0;\n        Stack\u003cInteger\u003e stack = new Stack\u003c\u003e();\n        for (int i = 0; i \u003c n; i++) {\n            int elem = pushed[i];\n            stack.add(elem);\n            j = removeElemfromStack(popped, j, stack);\n        }\n        while(j \u003c popped.length) {\n            int topelem = stack.peek();\n            int popelem = popped[j];\n            if (topelem == popelem) { stack.pop(); j++; }\n            else { return false; }\n        }\n        return true;\n    }\n    private static int removeElemfromStack(int[] popped, int j, Stack\u003cInteger\u003e stack) {\n        while(stack.isEmpty()==false) {\n            if (stack.peek() == popped[j]) {\n                stack.pop();\n                j++;\n            } else {\n                break;\n            }\n        }\n        return j;\n    }\n}\n"},{"id":"839","name":" Similar String Groups","language":"java","code":"class UnionFind {\n    int[] parent;\n    int[] rank;\n​\n    public UnionFind(int size) {\n        parent = new int[size];\n        for (int i = 0; i \u003c size; i++)\n            parent[i] = i;\n        rank = new int[size];\n    }\n​\n    public int find(int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n​\n    public void union_set(int x, int y) {\n        int xset = find(x), yset = find(y);\n        if (xset == yset) {\n            return;\n        } else if (rank[xset] \u003c rank[yset]) {\n            parent[xset] = yset;\n        } else if (rank[xset] \u003e rank[yset]) {\n            parent[yset] = xset;\n        } else {\n            parent[yset] = xset;\n            rank[xset]++;\n        }\n    }\n}\n​\nclass Solution {\n    public boolean isSimilar(String a, String b) {\n        int diff = 0;\n        for (int i = 0; i \u003c a.length(); i++) {\n            if (a.charAt(i) != b.charAt(i)) {\n                diff++;\n            }\n        }\n        return diff == 0 || diff == 2;\n    }\n​\n    public int numSimilarGroups(String[] strs) {\n        int n = strs.length;\n        UnionFind dsu = new UnionFind(n);\n        int count = n;\n        // Form the required graph from the given strings array.\n        for (int i = 0; i \u003c n; i++) {\n            for (int j = i + 1; j \u003c n; j++) {\n                if (isSimilar(strs[i], strs[j]) \u0026\u0026 dsu.find(i) != dsu.find(j)) {\n                    count--;\n                    dsu.union_set(i, j);\n                }\n            }\n        }\n​\n        return count;\n    }\n}\n"},{"id":"704","name":" Binary Search","language":"java","code":"class Solution {\n    public int search(int[] nums, int target) {\n        int r = 0;\n        int lo = 0;\n        int hi = nums.length - 1;\n        \n        while (lo \u003c= hi) {\n            int mid = (lo + hi)/2;\n            if (nums[mid]==target) return r = mid;\n            else if (nums[mid] \u003e target) hi = mid - 1;\n            else lo = mid + 1;\n        }\n        \n        return -1;\n    }\n}\n"},{"id":"79","name":" Word Search","language":"java","code":"class Solution {\n​\n    private class Pair {\n        int row;\n        int col;\n​\n        Pair(int r, int c) {\n            this.row = r;\n            this.col = c;\n        }\n    }\n​\n    private int[] dx = new int[] { 1, -1, 0, 0 };\n    private int[] dy = new int[] { 0, 0, -1, 1 };\n​\n    public boolean exist(char[][] board, String word) {\n        final int R = board.length;\n        final int C = board[0].length;\n​\n        for (int row = 0; row \u003c R; row++) {\n            for (int col = 0; col \u003c C; col++) {\n                if (search(board, word, 0, new Pair(row, col)) == true) {\n                    return true;\n                }\n            }\n        }\n​\n        return false;\n    }\n​\n    private boolean search(char[][] board, String word, int wordCount, Pair node) {\n​\n        if (wordCount == word.length()) {\n            return true;\n        }\n​\n        if (isNotUnderSafeArea(board, node.row, node.col, word, wordCount) == true)\n            return false;\n​\n        // faith\n        if (word.charAt(wordCount) == board[node.row][node.col]) {\n            char orignalCharacter = board[node.row][node.col];\n            board[node.row][node.col] = '#';\n            for (int k = 0; k \u003c 4; k++) {\n                boolean rres = search(board, word, wordCount + 1, new Pair(node.row + dx[k], node.col + dy[k]));\n                if (rres == true) {\n                    return true;\n                }\n            }\n            board[node.row][node.col] = orignalCharacter;\n        }\n​\n        return false;\n    }\n​\n    private boolean isNotUnderSafeArea(char[][] board, int row, int col, String word, int wordCount) {\n​\n        return row \u003c 0 || row \u003e= board.length || col \u003c 0 || col \u003e= board[0].length\n                || word.charAt(wordCount) != board[row][col] || board[row][col] == '#';\n​\n    }\n}\n"},{"id":"912","name":" Sort an Array","language":"java","code":"class Solution {\n    public int[] sortArray(int[] nums) {\n//         PriorityQueue\u003cInteger\u003e heap = new PriorityQueue\u003c\u003e();\n//         for (int elem : nums) {\n//             heap.add(elem);\n//         }\n        \n//         for (int i = 0; i \u003c nums.length; i++) {\n//             nums[i] = heap.remove();\n//         }\n//         return nums;\n        \n        HH.heapsort(nums);\n        return nums;\n    }\n}\n​\n// \"static void main\" must be defined in a public class.\nclass HH {\n    public static void heapsort(int[] arr) {\n        buildHeap(arr);\n        \n        for (int i = arr.length - 1; i \u003e= 0; i--) {\n            swap(arr, 0, i);\n            heapify(arr, i, 0);\n        }\n    }\n    \n    private static void buildHeap(int[] arr) {\n        int n = arr.length;\n        for (int i = n/2; i \u003e= 0; i--) {\n            heapify(arr, n, i);   \n        }\n    }\n    \n    private static void heapify(int[] arr, int n, int i) {\n        int largest = i;\n        int lc = 2*i+1;\n        int rc = 2*i+2;\n        \n        if (lc \u003c n \u0026\u0026 arr[lc] \u003e arr[largest]) largest = lc;\n        if (rc \u003c n \u0026\u0026 arr[rc] \u003e arr[largest]) largest = rc;\n        \n        if (largest != i) {\n            swap(arr, largest, i);\n            heapify(arr, n, largest);\n        }\n    }\n    \n    private static void swap(int[] arr, int i, int j) {\n        int t = arr[i];\n        arr[i] = arr[j];\n        arr[j] = t;\n    }\n}\n​\n"},{"id":"952","name":" Largest Component Size by Common Factor","language":"java","code":"class Solution {\n​\n    class UnionFindAlgorithm {\n        public static final int find (int node, int[] parent) {\n            if (parent[node]==-1) {\n                return node;\n            } else {\n                int rparent = find(parent[node], parent);\n                parent[node] = rparent;\n                return rparent;\n            }\n        }\n​\n        public static final void union(int u, int v, int[] parent) {\n            int unode = find(u, parent);\n            int vnode = find(v, parent);\n​\n            if (unode != vnode) {\n                parent[vnode] = unode;\n            }\n        }\n    }\n​\n    public int largestComponentSize(int[] nums) {\n        int[] parent = new int[100005];\n        Arrays.fill(parent, -1);\n​\n        for (int node : nums) {\n                for (int i = 2; i \u003c= (int) Math.sqrt(node); i++) {\n                    if (node % i == 0) {\n                        // means divisable\n                        UnionFindAlgorithm.union(i, node, parent); // 20\n                        UnionFindAlgorithm.union(node, (int) node/i, parent);\n                    }\n                }\n        }\n​\n        // System.out.println(parent);\n​\n        int answer = 0;\n        Map\u003cInteger, Integer\u003e map = new HashMap\u003c\u003e();\n        for (int x : nums) {\n                int xp = UnionFindAlgorithm.find(x, parent);\n                map.put(xp, map.getOrDefault(xp, 0) + 1 );\n                answer = Math.max(answer, map.get(xp) );\n        }\n​\n            return answer;\n    }\n}\n"},{"id":"9","name":" Palindrome Number","language":"java","code":"class Solution {\n    public boolean isPalindrome(int x) {\n        if (x \u003c 0) {\n            return false;\n        }\n        \n        String s = \"\" + x;\n        \n        int lo = 0;\n        int hi = s.length()-1;\n        \n        while (lo \u003c hi) {\n            if (s.charAt(lo) != s.charAt(hi))\n                return false;\n            \n            lo++;\n            hi--;\n        }\n        return true;\n    }\n}\n"},{"id":"709","name":" To Lower Case","language":"java","code":"class Solution {\n  public String toLowerCase(String str) {\n        char[] a = str.toCharArray();\n        for (int i = 0; i \u003c a.length; i++)\n            if ('A' \u003c= a[i] \u0026\u0026 a[i] \u003c= 'Z')\n                a[i] = (char) (a[i] - 'A' + 'a');\n        return new String(a);\n    }\n}\n"},{"id":"496","name":" Next Greater Element I","language":"java","code":"class Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        int[] nextGreaterElems = findNextGreaterElems(nums2);\n        HashMap\u003cInteger,Integer\u003e cache = new HashMap\u003c\u003e();\n        for(int i = 0; i \u003c nums2.length; i++){\n            cache.put( nums2[i], nextGreaterElems[i] );\n        }\n        int[] ans = new int[nums1.length];\n        for(int i = 0; i \u003c nums1.length; i++){\n            ans[i] = cache.get(nums1[i]);\n        }\n        return ans;\n    }\n    \n    private static int[] findNextGreaterElems(int[] arr){\n        Stack\u003cInteger\u003e stack = new Stack\u003c\u003e();\n        int n = arr.length;\n        /**\n           traverse korbo backward ar ans[] te rightside \n           ...er big elem store korbo!\n           ---\n           [4,1,2] ~\u003e -1  2 -1\n        */\n        int[] elems = new int[n];\n        for(int i = n - 1; i \u003e= 0; i--) {\n            while(stack.isEmpty()==false \u0026\u0026 stack.peek() \u003c arr[i]) stack.pop();\n            elems[i] = stack.isEmpty() ? -1 : stack.peek();\n            stack.add(arr[i]);\n        }\n        return elems;\n    }\n}\n"},{"id":"792","name":" Number of Matching Subsequences","language":"java","code":"class Solution {\n    // O N^2 Solution with Space - Constant\n    public int numMatchingSubseq(String s, String[] words) {\n        int count = 0;\n        \n        for (String word : words) {\n            if (isSubsequence(s, word))\n                count++;\n        }\n        \n        return count;\n    }\n​\n    private boolean isSubsequence(String s, String word) {\n        // TODO Auto-generated method stub\n        int prevChIndex = 0;\n        \n        for (char c : word.toCharArray()) {\n            int index = s.indexOf(c, prevChIndex);\n            if (index == -1) return false;\n            prevChIndex = index+1;\n        }\n        \n        return true;\n    }\n​\n    // ~~~~~~~ SLOW Solution -\u003e\u003e EXOPENTIAL COMPLEXITY + SPACE 2^n ~~~~~~~~~~\n    // ~~~~~~ Super BAD Super in TC ~~~~~~~~~~~~`\n    public int numMatchingSubseq2(String s, String[] words) {\n        List\u003cString\u003e subsequences = generateAllSubsequences(s);\n        System.out.println(subsequences);\n        Set\u003cString\u003e set = new HashSet\u003cString\u003e(subsequences);\n        \n        int found = 0;\n        for (String word : words)\n            if (set.contains(word)==true) found++;\n        \n        return found;\n    }\n​\n    private List\u003cString\u003e generateAllSubsequences(String s) {\n        // TODO Auto-generated method stub\n        List\u003cString\u003e answers = new ArrayList\u003cString\u003e();\n        answers = _generateAllSubsequences(s);\n        return answers;\n    }\n​\n    private List\u003cString\u003e _generateAllSubsequences(String s) {\n        // TODO Auto-generated method stub\n​\n        if (s.length() == 0) {\n            List\u003cString\u003e bres = new ArrayList\u003cString\u003e();\n            bres.add(\"\");\n            return bres;\n        }\n​\n        List\u003cString\u003e myres = new ArrayList\u003cString\u003e();\n​\n        char fc = s.charAt(0);\n        String ros = s.substring(1);\n​\n        // faith\n        List\u003cString\u003e rres = _generateAllSubsequences(ros);\n        for (String r : rres) {\n            myres.add(r);\n            myres.add(fc + r);\n        }\n​\n        return myres;\n    }\n}\n"},{"id":"84","name":" Largest Rectangle in Histogram","language":"java","code":"        final int n = heights.length;\n        int[] walls = new int[n];\n​\n        Stack\u003cInteger\u003e stack = new Stack\u003c\u003e();\n​\n        for (int i = n - 1; i \u003e= 0; i--) {\n            int curHeight = heights[i];\n​\n            while (stack.isEmpty() == false \u0026\u0026 heights[stack.peek()] \u003e= curHeight)\n                stack.pop();\n​\n            if (stack.isEmpty() == true)\n                walls[i] = n;\n            else\n                walls[i] = stack.peek();\n​\n            stack.push(i);\n        }\n​\n        return walls;\n    }\n​\n    private int[] getLeftHeightIndcies(int[] heights) {\n        // TODO Auto-generated method stub\n​\n        final int n = heights.length;\n        int[] walls = new int[n];\n​\n        Stack\u003cInteger\u003e stack = new Stack\u003c\u003e();\n​\n        for (int i = 0; i \u003c n; i++) {\n            int curheight = heights[i];\n​\n            while (stack.isEmpty() == false \u0026\u0026 heights[stack.peek()] \u003e= curheight)\n                stack.pop();\n​\n            if (stack.isEmpty() == true)\n                walls[i] = -1;\n            else\n                walls[i] = stack.peek();\n​\n            stack.push(i);\n        }\n​\n        return walls;\n    }\n}\n​\n"},{"id":"90","name":" Subsets II","language":"cpp","code":"class Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e subsetsWithDup(vector\u003cint\u003e\u0026 nums) {\n        /*\n            * iterative approch exists, but need O(N) extra space\n            * n = size of vector\u003cint\u003enums.\n        */\n        sort(nums.begin(), nums.end());\n        vector\u003cvector\u003cint\u003e\u003e subsets;\n        dfs(nums, subsets, 0, vector\u003cint\u003e());\n        return subsets;\n    }\n    \n    void dfs(vector\u003cint\u003e \u0026nums, vector\u003cvector\u003cint\u003e\u003e \u0026subsets, int index, vector\u003cint\u003e current){\n        subsets.push_back(current);\n        for(int i = index; i \u003c (int) nums.size(); i++){\n            if(index \u003c i \u0026\u0026 nums[i-1] == nums[i]){\n                continue;\n            }\n            current.push_back(nums[i]);\n            dfs(nums, subsets, i+1, current);\n            current.pop_back();\n        }\n    }\n};\n"},{"id":"915","name":" Partition Array into Disjoint Intervals","language":"java","code":"class Solution {\n    public int partitionDisjoint(int[] nums) {\n        final int n = nums.length;\n        \n        int current_max = nums[0];\n        int max = current_max;\n        int partitioned_index = 0; // mentioned that index must exists!\n        \n        for (int i = 1; i \u003c n; i++) {\n            int elem = nums[i];\n            \n            if (current_max \u003e elem) {\n                current_max = max; // switch the maxi elem\n                partitioned_index = i;\n            } \n             else max = Math.max( max, elem );\n        }\n        \n        partitioned_index++; // point is prev elem was the last elem of the first interval, (index+1) will be parition index.\n        \n        return partitioned_index;\n    }\n}\n"},{"id":"542","name":" 01 Matrix","language":"java","code":"class Solution {\n​\n    private class Pair {\n        int x;\n        int y;\n​\n        Pair(int x , int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n​\n    private int[] dx = new int[]{1,-1,0,0};\n    private int[] dy = new int[]{0,0,-1,1};\n​\n    public int[][] updateMatrix(int[][] mat) {\n        int n = mat.length;\n        int m = mat[0].length;\n​\n        int[][] dist = new int[n][m];\n        for (int i = 0; i \u003c n; i++)\n            Arrays.fill(dist[i], Integer.MAX_VALUE);\n        \n        Queue\u003cPair\u003e queue = new LinkedList\u003c\u003e();\n​\n        for (int i = 0 ; i \u003c n; i++) {\n            for (int j = 0; j \u003c m; j++) {\n                if (mat[i][j] == 0) {\n                    queue.add(new Pair(i,j));\n                    dist[i][j] = 0;\n                }\n            }\n        }\n​\n​\n        while(queue.isEmpty() == false) {\n            Pair p = queue.remove();\n​\n            for (int k = 0; k \u003c 4; k++) {\n                int nx = p.x + this.dx[k];\n                int ny = p.y + this.dy[k];\n​\n                if ( 0 \u003c= nx \u0026\u0026 nx \u003c n \u0026\u0026 0 \u003c= ny \u0026\u0026 ny \u003c m \u0026\u0026 dist[nx][ny] == Integer.MAX_VALUE) {\n                    dist[nx][ny] = 1 + dist[p.x][p.y];\n                    queue.add( new Pair(nx, ny) );\n                }\n​\n            }\n        }\n​\n        return dist;\n    }\n}\n"},{"id":"718","name":" Maximum Length of Repeated Subarray","language":"java","code":"            HashMap\u003cInteger, List\u003cInteger\u003e\u003e map = new HashMap\u003cInteger, List\u003cInteger\u003e\u003e();\n​\n            for (int i = 0; i \u003c arr1.length; i++) {\n                int key = arr1[i];\n                if (map.containsKey(key) == true) {\n                    map.get(key).add(i);\n                } else {\n                    List\u003cInteger\u003e list = new ArrayList\u003c\u003e();\n                    list.add(i);\n                    map.put(key, list);\n                }\n            }\n​\n            System.out.println(map);\n​\n            // checking weither the length of the array subarray;\n​\n            int maxLength = 0;\n​\n            for (int i = 0; i \u003c arr2.length; i++) {\n                int key = arr2[i];\n​\n                // check if key presents in map\n                if (map.containsKey(key) == true) {\n                    int ii = i;\n                    for (int jj : map.get(key)) {\n                        while ((ii \u003c arr2.length \u0026\u0026 jj \u003c arr1.length) \u0026\u0026 arr2[ii] == arr1[jj]) {\n                            ii++;\n                            jj++;\n                        }\n                        ii--;\n                        int len = Math.abs(ii - i);\n                        maxLength = Math.max(len, maxLength);\n                    }\n                }\n​\n            }\n​\n            return maxLength;\n        }\n    }\n​\n"},{"id":"96","name":" Unique Binary Search Trees","language":"java","code":"class Solution {\n    public int numTrees(int n) {\n        \n        int[] dp = new int [n+1];\n        dp[0] = 1;\n        \n        for (int i = 1; i \u003c n + 1; i++) {\n            for (int root = 1 ; root \u003c= i; root++)\n            {\n                dp[i] += dp[root-1] * dp[i - root] ;\n            }\n        }\n        \n        return dp[n];\n    }\n}\n​\n"},{"id":"795","name":" Number of Subarrays with Bounded Maximum","language":"java","code":"class Solution {\n    // public int numSubarrayBoundedMax(int[] nums, int left, int right) {\n    \n    // leetcode 795 https://leetcode.com/problems/number-of-subarrays-with-bounded-maximum/\n    public int numSubarrayBoundedMax(int[] nums, int left, int right) {\n        int prev_count = 0;\n        int overall_count = 0;\n​\n        int i = 0;\n        int j = 0;\n​\n        while(j \u003c nums.length) {\n            if(left \u003c= nums[j] \u0026\u0026 nums[j] \u003c= right) {\n                prev_count = j - i + 1;\n                overall_count += prev_count;\n            } else if(nums[j] \u003c left) {\n                overall_count += prev_count;\n            } else {\n                prev_count = 0;\n                i = j + 1;\n            }\n            j++;\n        }\n        return overall_count;\n    }\n}\n"},{"id":"5","name":" Longest Palindromic Substring","language":"cpp","code":"class Solution {\npublic:\n    string longestPalindrome(string s) {\n        int start = 0;\n        if (s.empty()) {\n            return nullptr;\n        }\n        if (s.length() == 1) {\n            return s;\n        }\n        int maxlen = 1;\n        int n = (int) s.length();\n        for (int i = 0; i \u003c n-1; i++) {\n            int l = i, r = i;\n            while (l \u003e= 0 \u0026\u0026 r \u003c n) {\n                if (s[l]==s[r]) {\n                    l--, r++;\n                }else {\n                    break;\n                }\n            }\n            int len = r-l-1;\n            if (maxlen \u003c len) {\n                maxlen = len;\n                start = l+1;\n            }\n        }\n        for (int i = 0; i \u003c n-1; i++) {\n            int l = i, r = i+1;\n            while (l \u003e= 0 \u0026\u0026 r \u003c n) {\n                if (s[l]==s[r]) {\n                    l--, r++;\n                }else {\n                    break;\n                }\n            }\n            int len = r-l-1;\n            if (maxlen \u003c len) {\n                maxlen = len;\n                start = l+1;\n            }\n        }\n​\n        return s.substr(start, maxlen);\n    }\n};\n"},{"id":"841","name":" Keys and Rooms","language":"cpp","code":"class Solution {\npublic:\n    bool canVisitAllRooms(vector\u003cvector\u003cint\u003e\u003e\u0026 rooms) {\n        set\u003cint\u003e visitedRooms ;\n        visitedRooms.insert(0);\n​\n        stack\u003cint\u003e cacheRooms ;\n        cacheRooms.push(0);\n        while (cacheRooms.empty()==false) {\n            vector\u003cint\u003e roomKeys = rooms[cacheRooms.top()];\n            cacheRooms.pop();\n            for (int key : roomKeys) {\n                if (visitedRooms.count(key)==0) {\n                    visitedRooms.insert(key);\n                    cacheRooms.push(key);\n                }\n            }\n        }\n        return (int) visitedRooms.size() == (int) rooms.size() ;   \n    }\n};\n"},{"id":"72","name":" Edit Distance","language":"java","code":"class Solution {\n    private int[][] memo;\n    public int minDistance(String word1, String word2) {\n        if (word1.length() == 0) return word2.length();\n        if (word2.length() == 0) return word1.length();\n        int n = word1.length();\n        int m = word2.length();\n        memo = new int[n+1][m+1];\n        for (int i = 0; i \u003c= n; i++) {\n            for (int j = 0; j \u003c= m; j++) {\n                if (i == 0)\n                    memo[i][j] = j;\n                else if (j == 0)\n                    memo[i][j] = i;\n                else if (word1.charAt(i-1) == word2.charAt(j-1)) {\n                    memo[i][j] = memo[i-1][j-1] + 0;\n                } else {\n                    int a = memo[i][j-1];\n                    int b = memo[i-1][j];\n                    int c = memo[i-1][j-1];\n                    memo[i][j] = 1 + Math.min(a, Math.min(b, c));\n                }\n            }\n        }\n        return memo[n][m];\n    }\n​\n}\n"},{"id":"90","name":" Subsets II","language":"java","code":"class Solution {\n    public List\u003cList\u003cInteger\u003e\u003e subsetsWithDup(int[] nums) {\n        List\u003cList\u003cInteger\u003e\u003e subsets=new ArrayList\u003c\u003e();\n        List\u003cInteger\u003e set=new ArrayList\u003c\u003e();\n        Arrays.sort(nums);\n        func(nums,0,set,subsets);\n        return subsets;\n    }\n​\n    private void func(int[] nums, int i, List\u003cInteger\u003e set, List\u003cList\u003cInteger\u003e\u003e subsets) {\n        subsets.add(new ArrayList\u003c\u003e(set));\n        for (int index=i; index\u003c nums.length;index++){\n           if (i!=index \u0026\u0026 nums[index] == nums[index-1]) continue;\n           set.add(nums[index]);\n           func(nums,index+1,set, subsets);\n           set.remove(set.size()-1);\n        }\n    }\n}\n"},{"id":"5","name":" Longest Palindromic Substring","language":"java","code":"class Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        if (n == 0) return \"\";\n        int maxLen = 1;\n        int maxCenter = 0;\n​\n        boolean[][] dp = new boolean[n][n];\n        for (int i = 0; i \u003c n; i++) {\n            dp[i][i] = true;\n        }\n        for (int i = 0; i \u003c n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                maxLen = 2;\n                maxCenter = i;\n            }\n        }\n        for (int len = 3; len \u003c= n; len++) {\n            for (int i = 0; i \u003c n - len + 1; i++) {\n                int j = i + len - 1;\n                if (s.charAt(i) == s.charAt(j) \u0026\u0026 dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    if (len \u003e maxLen) {\n                        maxLen = len;\n                        maxCenter = i;\n                    }\n                }\n            }\n        }\n        return s.substring(maxCenter, maxCenter + maxLen);\n    }\n}\n\n// One Of The Easiest Implementation Solution\n// However need to fix some rare cases\n\nclass Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        if (n == 0)\n            return \"\";\n\n        StringBuilder sb = new StringBuilder(s);\n        String t = sb.reverse().toString();\n\n        int[][] dp = new int[n + 1][n + 1];\n\n        int maxlen = 0;\n        int startIndex = -1;\n\n        for (int i = 1; i \u003c dp.length; i++) {\n            for (int j = 1; j \u003c dp[i].length; j++) {\n                char x = s.charAt(i - 1);\n                char y = t.charAt(j - 1);\n\n                if (x == y) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                    if (maxlen \u003c dp[i][j]) {\n                        maxlen = dp[i][j];\n                        startIndex = i - dp[i][j];\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i \u003c dp.length; i++) {\n            System.out.println(Arrays.toString(dp[i]));\n        }\n\n        return s.substring(startIndex, startIndex + maxlen);\n    }\n}\n"},{"id":"918","name":" Maximum Sum Circular Subarray","language":"java","code":"class Solution {\n    public int maxSubarraySumCircular(int[] nums) {\n        final int n = nums.length;\n        final int[] rightMax = new int[n];\n        rightMax[n - 1] = nums[n - 1];\n        for (int suffixSum = nums[n - 1], i = n - 2; i \u003e= 0; --i) {\n            suffixSum += nums[i];\n            rightMax[i] = Math.max(rightMax[i + 1], suffixSum);\n        }\n        int maxSum = nums[0];\n        int specialSum = nums[0];\n        for (int i = 0, prefixSum = 0, curMax = 0; i \u003c n; ++i) {\n            curMax = Math.max(curMax, 0) + nums[i];\n            // This is Kadane's algorithm.\n            maxSum = Math.max(maxSum, curMax);\n            prefixSum += nums[i];\n            if (i + 1 \u003c n) {\n                specialSum = Math.max(specialSum, prefixSum + rightMax[i + 1]);\n            }\n        }\n        return Math.max(maxSum, specialSum);  \n    }\n}\n"},{"id":"841","name":" Keys and Rooms","language":"java","code":"class Solution {\n    public boolean canVisitAllRooms(List\u003cList\u003cInteger\u003e\u003e rooms) {\n        int totalRooms = rooms.size();\n        boolean[] visitedRooms = new boolean[totalRooms];\n        exploreAllRoomsAndOpen(rooms, visitedRooms, 0);\n        return hasAllExplored(visitedRooms);\n    }\n​\n    private boolean hasAllExplored(boolean[] visitedRooms) {\n        boolean status = visitedRooms[0];\n        for (boolean val : visitedRooms)\n            status = status \u0026 val;\n        return status;\n    }\n​\n    private void exploreAllRoomsAndOpen(List\u003cList\u003cInteger\u003e\u003e rooms, boolean[] visitedRooms, int currentRoom) {\n        visitedRooms[currentRoom] = true;\n        for (int nextRoomKey : rooms.get(currentRoom)) {\n            if (!visitedRooms[nextRoomKey]) {\n                exploreAllRoomsAndOpen(rooms, visitedRooms, nextRoomKey);\n            }\n        }\n    }\n}\n"},{"id":"724","name":" Find Pivot Index","language":"java","code":"class Solution {\n    public int pivotIndex(int[] nums) {\n        /**\n         * One simple solution will be count prefsum for whole arr[]; do check\n         * rightpartsum[curindex+1] == prefsum[curindex-1];\n         */\n        int leftPartSum = 0;\n        int runningSum = 0;\n        for (int i = 0; i \u003c nums.length; i++)\n            runningSum += nums[i];\n​\n        for (int i = 0; i \u003c nums.length; i++) {\n            runningSum -= nums[i];\n            if (leftPartSum == runningSum)\n                return i;\n            else leftPartSum += nums[i];\n        }\n        return -1;\n    }\n}\n"},{"id":"50","name":" Pow(x, n)","language":"cpp","code":"class Solution {\npublic:\n    double myPow(double x, int n) {\n        return pow(x, n)   ;\n    }\n};\n"},{"id":"904","name":" Fruit Into Baskets","language":"cpp","code":"class Solution {\npublic:\n    int totalFruit(vector\u003cint\u003e\u0026 trees) {\n        if(trees.empty()) {\n            return 0;\n        }\n        int maxfruit = 1;\n        unordered_map\u003cint, int\u003e cache;\n        int i=0, j=0;\n        while(j \u003c (int) trees.size()) {\n            if(cache.size() \u003c= 2) {\n                cache[trees[j]] = j;\n                j++;\n            }\n            if((int) cache.size() \u003e= 3) {\n                int minimum = (int) trees.size() - 1;\n                for(auto \u0026\u0026p : cache) {\n                    minimum = min(minimum, p.second);\n                }\n                i = minimum+1;\n                cache.erase(trees[minimum]);\n            }\n            maxfruit = max(maxfruit, j-i);\n        }\n        return maxfruit;\n    }\n};\n"},{"id":"925","name":" Long Pressed Name","language":"java","code":"class Solution {\n    public boolean isLongPressedName(String name, String typed) {\n        return isPossible(name, typed);\n    }\n    \n​\n  public boolean isPossible(String name, String typed) {\n    int i = 0;\n    int j = 0;\n​\n    if (name.charAt(0) != typed.charAt(0)) return false;\n​\n    i++;\n    j++;\n​\n​\n    while (i \u003c name.length() \u0026\u0026 j \u003c typed.length()) {\n      if (isEqual(name, typed, i, j)) {\n        i++;\n        j++;\n      } else if (0 \u003c= i - 1 \u0026\u0026 isEqual(name, typed, i - 1, j)) {\n        j++;\n      } else {\n        return false;\n      }\n    }\n    \n    while (j \u003c typed.length()) {\n        if ( isEqual(name, typed, i-1, j)) j++;\n        else return false;\n    }\n​\n    return i == name.length();\n  }\n​\n  private boolean isEqual(String name, String typed, int i, int j) {\n    return name.charAt(i) == typed.charAt(j);\n  }\n​\n}\n"},{"id":"845","name":" Longest Mountain in Array","language":"java","code":"class Solution {\n    public int longestMountain(int[] arr) {\n        int answer = 0;\n        int n = arr.length;\n​\n        // go from 1...n-2\n        // seems Time: O(N2)\n        for (int i = 1; i \u003c= n-2; i++) {\n            /*\n             * find if arr[i] is peak\n             * how? --\u003e arr[i] \u003e arr[i] \u003e arr[i+1]\n             */\n​\n            if (arr[i] \u003e arr[i-1] \u0026\u0026 arr[i] \u003e arr[i+1]) {\n                int j = i;\n                int size = 1;\n​\n                // left neighours\n                while (j \u003e 0 \u0026\u0026 arr[j] \u003e arr[j-1]) {\n                    size++;\n                    j--;\n                }\n​\n                // right neighbours\n                j = i;\n                while (j \u003c n - 1 \u0026\u0026 arr[j] \u003e arr[j+1]) {\n                    size++;\n                    j++;\n                }\n​\n                answer = Math.max(answer, size);\n            } else {\n                // i++;\n            }\n        }\n        \n        /**\n            optimization would be-\n            you already know by the right neighbours who are the peak values\n            so you can increment i pointer directly, \n            not to create dependency upon j for rightward traversal\n            TIME: O(N)\n        */\n​\n        return answer;\n    }\n}\n"},{"id":"729","name":" My Calendar I","language":"java","code":"class Pair extends LinkedList\u003cPair\u003e {\n    int start;\n    int end;\n    Pair next;\n​\n    Pair(int start, int end) {\n        this.start = start;\n        this.end = end;\n    }\n​\n}\n​\nclass MyCalendar {\n​\n    private Pair eventStorage;\n​\n    public MyCalendar() {\n        Pair dummyTail = new Pair(Integer.MAX_VALUE, Integer.MAX_VALUE);\n        this.eventStorage = new Pair(-1, -1);\n        this.eventStorage.next = (dummyTail);\n    }\n​\n    public boolean book(int start, int end) {\n        Pair currentNode = this.eventStorage;\n        Pair tempNode = this.eventStorage;\n​\n        /*\n         * ami joto khon na faka starttime pabo curr node k egiye niye jabo\n         */\n​\n        while (currentNode.start \u003c start) {\n            tempNode = currentNode;\n            currentNode = currentNode.next;\n        }\n​\n        // jodi already sesh besi event reggister kora thake\n        // OR: prebooked kono event already ache, jar start time end er interval e\n        // conflict korche\n        if (tempNode.end \u003e start || currentNode.start \u003c end) {\n            return false;\n        }\n​\n        Pair newEvent = new Pair(start, end);\n        newEvent.next = currentNode;\n        tempNode.next = newEvent;\n​\n        // means booking newa hoye gelo\n        return true;\n    }\n}\n​\n/**\n* Your MyCalendar object will be instantiated and called as such:\n* MyCalendar obj = new MyCalendar();\n* boolean param_1 = obj.book(start,end);\n*/\n"},{"id":"967","name":" Numbers With Same Consecutive Differences","language":"java","code":"class Solution {\n    public int[] numsSameConsecDiff(int n, int k) {\n        List\u003cString\u003e result = new ArrayList\u003c\u003e();\n        backtrack(result, new StringBuilder(), n, k, true);\n        int[] res = new int[result.size()];\n        for(int i=0; i\u003cresult.size(); i++){\n            res[i] = Integer.parseInt(result.get(i));\n        }\n        return res;\n    }\n    private void backtrack(List\u003cString\u003e result, StringBuilder sb, int n, int k, boolean firstZero){\n        if(sb.length() == n){\n            StringBuilder copy = new StringBuilder(sb);\n            result.add(copy.toString());\n            return;\n        }\n        for(int i=0; i\u003c=9; i++){\n            if(i == 0 \u0026\u0026 firstZero) continue;\n            else{\n                if(sb.length() == 0){\n                    sb.append(i);\n                    backtrack(result, sb, n, k, false);\n                    sb.deleteCharAt(sb.length()-1);\n                }\n                else{\n                    int lastChar = sb.charAt(sb.length()-1) - '0';\n                    if(Math.abs(i - lastChar) == k){\n                        sb.append(i);\n                        backtrack(result, sb, n, k, false);\n                        sb.deleteCharAt(sb.length()-1);\n                    }\n                }\n            }\n        }\n    }\n}\n"},{"id":"543","name":" Diameter of Binary Tree","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int finalDiameter = 0;\n    public int diameterOfBinaryTree(TreeNode root) {\n        this._diameterOfBinaryTree(root);\n        return this.finalDiameter;\n    }\n    \n    private int _diameterOfBinaryTree(TreeNode root) {\n        \n        if (root == null)\n            return -1;\n        \n        // faith\n        int leftHeight = this._diameterOfBinaryTree(root.left);\n        int rightHeight = this._diameterOfBinaryTree(root.right);\n        \n        int mydiameter = leftHeight + rightHeight + 2;\n        \n        // updating global max\n        finalDiameter = Math.max(mydiameter, finalDiameter);\n        \n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}\n"},{"id":"905","name":" Sort Array By Parity","language":"java","code":"class Solution {\n    public int[] sortArrayByParity(int[] nums) {\n        /**\n         * move all even numbers into beginning and odd to right half of the arr\n         */\n        int j = 0;\n​\n        for (int i = 0; i \u003c nums.length; i++) {\n            // if odd\n            if (nums[i] % 2 == 1) {\n​\n            } else {\n                int t = nums[j];\n                nums[j] = nums[i];\n                nums[i] = t;\n                j++;\n            }\n        }\n        return nums;\n    }\n}\n"},{"id":"849","name":" Maximize Distance to Closest Person","language":"java","code":"class Solution {\n    public int maxDistToClosest(int[] seats) {\n        int dist = 0;\n        int zeros = 0;\n        int indx = 0;\n        // left sub part\n        while(seats[indx] != 1) {\n            indx++;\n            zeros++;\n        }\n        indx++;\n        dist = zeros;\n        zeros = 0;\n        // segements calculations\n        while(indx \u003c seats.length) {\n            while(indx \u003c seats.length \u0026\u0026 seats[indx] != 1) {\n                zeros++;\n                indx++;\n            }\n            if(indx == seats.length)\n                break;\n​\n            indx++;\n            dist = Math.max(dist, (zeros + 1) / 2);\n            zeros = 0;\n        }\n​\n        // right sub part\n        return Math.max(zeros, dist);\n    }\n​\n}\n"},{"id":"51","name":" N-Queens","language":"java","code":"class Solution {\n   public List\u003cList\u003cString\u003e\u003e solveNQueens(int n) {\n    List\u003cList\u003cString\u003e\u003e result = new ArrayList\u003cList\u003cString\u003e\u003e();\n    helper(result, new ArrayList\u003cString\u003e(), 0, new boolean[n], new boolean[2*n], new boolean[2*n], n);\n    return result;\n}\n​\nprivate void helper(List\u003cList\u003cString\u003e\u003e result, List\u003cString\u003e board, int row, boolean[] cols, boolean[] d1, boolean[] d2, int n){\n    if (row == n) {\n        result.add(new ArrayList\u003cString\u003e(board));\n    }\n    for (int col=0; col\u003cn; col++){\n        int id1 = col - row + n;\n        int id2 = col + row;\n        if (!cols[col] \u0026\u0026 !d1[id1] \u0026\u0026 !d2[id2]){\n            char[] r = new char[n];\n            Arrays.fill(r, '.');\n            r[col] = 'Q';\n            board.add(new String(r));\n            cols[col] = true;\n            d1[id1] = true;\n            d2[id2] = true;\n            helper(result, board, row+1, cols, d1, d2, n);\n            board.remove(board.size()-1);\n            cols[col] = false;\n            d1[id1] = false;\n            d2[id2] = false;\n        }\n    }\n}\n}\n"},{"id":"968","name":" Binary Tree Cameras","language":"cpp","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    int camera = 0;\npublic:\n    \n    int f(TreeNode* root) {\n        if (!root) {\n            return 1;\n        }\n        int lc = f(root-\u003eleft) ;\n        int rc = f(root-\u003eright) ;\n        if (lc == -1 || rc == -1) {\n            camera++;\n            return 0;\n        }\n        if (lc == 0 || rc == 0) {\n            return 1;\n        }\n        return -1;\n    }\n    \n    int minCameraCover(TreeNode* root) {\n        if (f(root) == -1) {\n            camera++;\n        }    \n        // f(root);\n        return camera;\n    }\n};\n"},{"id":"547","name":" Number of Provinces","language":"java","code":"class Solution {\n​\n    private class Edge {\n        int source;\n        int nbr;\n​\n        Edge(int s, int nbr) {\n            this.source = s;\n            this.nbr = nbr;\n        }\n    }\n​\n    private List\u003cEdge\u003e[] construct_graph(int[][] isConnected) {\n        List\u003cEdge\u003e[] graph = new ArrayList[isConnected.length];\n​\n        for (int v = 0; v \u003c isConnected.length; v++)\n            graph[v] = new ArrayList\u003c\u003e();\n​\n        for (int v = 0; v \u003c isConnected.length; v++) {\n            for (int edge = 0; edge \u003c isConnected[v].length; edge++) {\n                if (isConnected[v][edge] == 0 || edge == v)\n                    continue;\n                graph[v].add(new Edge(v, edge));\n            }\n        }\n​\n        return graph;\n    }\n​\n    public int findCircleNum(int[][] isConnected) {\n        List\u003cEdge\u003e[] graph = construct_graph(isConnected);\n​\n        int components = 0;\n        boolean[] visited = new boolean[isConnected.length];\n​\n        for (int vertex = 0; vertex \u003c isConnected.length; vertex++) {\n            if (visited[vertex] == false) {\n                components++;\n                __travel_provinces_count(graph, vertex, visited);\n            }\n        }\n​\n        return components;\n    }\n​\n    private void __travel_provinces_count(List\u003cEdge\u003e[] graph, int vertex, boolean[] visited) {\n        visited[vertex] = true;\n​\n        for (Edge edge : graph[vertex])\n            if (visited[edge.nbr] == false)\n                __travel_provinces_count(graph, edge.nbr, visited);\n    }\n}\n"},{"id":"797","name":" All Paths From Source to Target","language":"java","code":"class Solution {\n    public List\u003cList\u003cInteger\u003e\u003e allPathsSourceTarget(int[][] graph) {\n        List\u003cList\u003cInteger\u003e\u003e paths = new ArrayList\u003c\u003e();\n        List\u003cInteger\u003e currentPath = new ArrayList\u003c\u003e();\n        Set\u003cInteger\u003e visitedSet = new HashSet\u003c\u003e();\n​\n        explorePaths(graph, 0, graph.length - 1, paths, currentPath, visitedSet);\n        return paths;\n    }\n​\n    private void explorePaths(int[][] graph, int currentNode, int dest, List\u003cList\u003cInteger\u003e\u003e paths,\n            List\u003cInteger\u003e currentPath,\n            Set\u003cInteger\u003e visitedSet) {\n​\n        currentPath.add(currentNode);\n        visitedSet.add(currentNode);\n​\n        if (currentNode == dest) {\n            paths.add(new ArrayList\u003c\u003e(currentPath));\n            // return;\n        }\n​\n        for (int neighbour : graph[currentNode]) {\n            if (visitedSet.contains(neighbour))\n                continue;\n            explorePaths(graph, neighbour, dest, paths, currentPath, visitedSet);\n        }\n​\n        visitedSet.remove(currentNode);\n        currentPath.remove(currentPath.size() - 1);\n    }\n}\n"},{"id":"73","name":" Set Matrix Zeroes","language":"java","code":"class Solution {\n    public void setZeroes(int[][] matrix) {\n        int R = matrix.length;\n        int C = matrix[0].length;\n        \n        boolean isColumnZero = checkColIfZero(matrix, R, C);\n        boolean isRowZero = checkRowIfZero(matrix, R, C);\n        \n        for (int row = 1; row \u003c R; row++) {\n            for (int col = 1; col \u003c C; col++) {\n                int elem = matrix[row][col];\n                if (elem == 0) {\n                    matrix[0][col] = 0;\n                    matrix[row][0] = 0;\n                }\n            }\n        }\n        \n        for (int col = 1; col \u003c C; col++) {\n            if (matrix[0][col]==0) {\n                for (int row = 0; row \u003c R; row++) {\n                    matrix[row][col] = 0;\n                }\n            }\n        }\n        \n        \n        for (int row = 1; row \u003c R; row++) {\n            if (matrix[row][0]==0) {\n                for (int col = 0; col \u003c C; col++) {\n                    matrix[row][col] = 0;\n                }\n            }\n        }\n        \n        if (isColumnZero) {\n            for (int row = 0 ; row \u003c R; row++) {\n                matrix[row][0] = 0;\n            }\n        }\n        \n        if (isRowZero) {\n            for (int col = 0; col \u003c C; col++) {\n                matrix[0][col] = 0;\n            }\n        }\n    }\n​\n    private boolean checkRowIfZero(int[][] matrix, int r, int c) {\n        // TODO Auto-generated method stub\n        for (int col = 0; col \u003c c; col++)\n            if (matrix[0][col] == 0) return true;\n        \n        return false;\n    }\n​\n    private boolean checkColIfZero(int[][] matrix, int r, int c) {\n        // TODO Auto-generated method stub\n        for (int row = 0; row \u003c r; row++)\n            if (matrix[row][0]==0) return true;\n        \n        return false;\n    }\n}\n"},{"id":"929","name":" Unique Email Addresses","language":"java","code":"class Solution {\n    public int numUniqueEmails(String[] emails) {\n        int totalUniqEmails = 0;\n​\n        HashSet\u003cString\u003e set = new HashSet\u003c\u003e();\n​\n        for (String email : emails) {\n            email = normalizeTheEmailPattern(email);\n            set.add(email);\n        }\n​\n        totalUniqEmails = set.size();\n        return totalUniqEmails;\n    }\n​\n    private String normalizeTheEmailPattern(String email) {\n        // TODO Auto-generated method stub\n        StringBuilder normalizedEmail = new StringBuilder();\n        boolean ignoreChars = false;\n        boolean domainPart = false;\n​\n        for (char x : email.toCharArray()) {\n            if (x == '@') {\n                ignoreChars = false;\n                domainPart = true;\n            }\n​\n            if (domainPart) {\n                normalizedEmail.append(x);\n                continue;\n            }\n​\n            if (x == '.')\n                continue;\n            if (x == '+') {\n                ignoreChars = true;\n                continue;\n            }\n​\n            if (ignoreChars == true)\n                continue;\n​\n            normalizedEmail.append(x);\n        }\n​\n        return normalizedEmail.toString();\n    }\n}\n"},{"id":"906","name":" Super Palindromes","language":"java","code":"class Solution {\n    // Hopefully Working!! Phewwwww!\n    public int superpalindromesInRange(String left, String right) {\n        List\u003cLong\u003e palindromicNo = new ArrayList\u003c\u003e();\n        Long leftNo = Long.parseLong(left);\n        Long rightNo = Long.parseLong(right);\n        int count = 0;\n        for(long i= 1;i\u003c10;i++){\n            palindromicNo.add(i);\n        }\n        for(long i=1;i\u003c10000;i++){\n            String leftPart = Long.toString(i);\n            String rightPart = new StringBuilder(leftPart).reverse().toString();\n​\n            palindromicNo.add(Long.parseLong(leftPart+rightPart));\n​\n            for(int digit=0;digit\u003c10;digit++){\n                palindromicNo.add(Long.parseLong(leftPart + digit + rightPart));\n            }\n        }\n        for(long no : palindromicNo){\n            long squareNo = no * no; // 10^18\n            if(leftNo \u003c= squareNo \u0026\u0026 rightNo \u003e=squareNo \u0026\u0026  isPalindromic(Long.toString(squareNo))){\n​\n                count++;\n            }\n        }\n        return count;\n    }\n​\n     private boolean isPalindromic(String str){\n        int start = 0;\n        int end = str.length()-1;\n        while(start\u003c end){\n            if(str.charAt(start)!= str.charAt(end)){\n                return false;\n            } else{\n                start++;\n                end--;\n            }\n        }\n​\n        return true;\n    }\n}\n"},{"id":"55","name":" Jump Game","language":"cpp","code":"class Solution {\npublic:\n    bool canJump(vector\u003cint\u003e\u0026 nums) {\n        int len = nums.size();\n        int maxjp = 0;\n        for(int i = 0; i \u003c= maxjp; i++){\n            maxjp = max(maxjp, i+nums[i]);\n            if(maxjp \u003e= len-1){\n                return true;\n            }\n        }\n        return false;\n    }\n};\n"},{"id":"863","name":" All Nodes Distance K in Binary Tree","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n​\nclass Solution {\n​\n    private List\u003cInteger\u003e nodesAtKDistance;\n​\n    public List\u003cInteger\u003e distanceK(TreeNode root, TreeNode target, int k) {\n        this.nodesAtKDistance = new ArrayList\u003c\u003e();\n​\n        ArrayList\u003cTreeNode\u003e rootpath = this.getTheNodeRootPath(root, target);\n​\n        for (int i = 0; i \u003c rootpath.size(); i++) {\n            TreeNode node = rootpath.get(i);\n            if (i == 0) {\n                this.printNodesWhichAreKLevelsDown(node, k-i, null);\n            } else {\n                this.printNodesWhichAreKLevelsDown(node, k-i, rootpath.get(i-1));\n            }\n        }\n​\n        return this.nodesAtKDistance;\n    }\n​\n    private void printNodesWhichAreKLevelsDown(TreeNode node, int k, TreeNode blocker) {\n​\n        if (node == null || node == blocker || k \u003c 0)\n            return;\n​\n        if (k == 0) {\n            nodesAtKDistance.add(node.val);\n            return;\n        }\n​\n        // faith\n        this.printNodesWhichAreKLevelsDown(node.left, k - 1, blocker); // left call\n        this.printNodesWhichAreKLevelsDown(node.right, k - 1, blocker); // right call\n    }\n​\n    private ArrayList\u003cTreeNode\u003e getTheNodeRootPath(TreeNode root, TreeNode target) {\n​\n        if (root == null)\n            return new ArrayList\u003c\u003e();\n​\n        if (root == target) {\n            ArrayList\u003cTreeNode\u003e bres = new ArrayList\u003c\u003e();\n            bres.add(root);\n            return bres;\n        }\n​\n        // faith\n        ArrayList\u003cTreeNode\u003e path1 = this.getTheNodeRootPath(root.left, target);\n        ArrayList\u003cTreeNode\u003e path2 = this.getTheNodeRootPath(root.right, target);\n​\n        ArrayList\u003cTreeNode\u003e mypath = new ArrayList\u003c\u003e();\n​\n        if (path1.size() \u003e 0) {\n            mypath = (ArrayList) path1.clone();\n            mypath.add(root);\n        } else if (path2.size() \u003e 0) {\n            mypath = (ArrayList) path2.clone();\n            mypath.add(root);\n        }\n​\n        return mypath;\n    }\n​\n}\n"},{"id":"80","name":" Remove Duplicates from Sorted Array II","language":"cpp","code":"class Solution {\npublic:\n    int removeDuplicates(vector\u003cint\u003e\u0026 nums) {\n        if(nums.empty() || nums.size() \u003c 3) {\n            return nums.size();\n        }\n        int indx = 2;\n        for(int i = 2 ; i \u003c (int) nums.size(); i++) {\n            if(nums[i] != nums[indx-2]) {\n                nums[indx++] = nums[i];\n            }\n        }\n        \n        return indx;\n    }\n};\n"},{"id":"739","name":" Daily Temperatures","language":"java","code":"import java.util.Arrays;\nimport java.util.Stack;\n​\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        int n = temperatures.length;\n        int[] answers = new int[n];\n        Stack\u003cInteger\u003e stack = new Stack\u003c\u003e();\n​\n        for (int i = n - 1; i \u003e= 0; i--) {\n            int temperature = temperatures[i];\n            if (stack.isEmpty()) {\n                answers[i] = 0;\n            } else {\n                while (!stack.isEmpty() \u0026\u0026 temperatures[stack.peek()] \u003c= temperature) {\n                    stack.pop();\n                }\n                answers[i] = stack.isEmpty() ? 0 : (stack.peek()-i);\n            }\n            stack.add(i);\n        }\n​\n        return answers;\n    }\n}\n"},{"id":"907","name":" Sum of Subarray Minimums","language":"java","code":"​\nclass Solution {\n    public int sumSubarrayMins(int[] arr) {\n        int MOD = 1000000007;\n​\n        Stack\u003cInteger\u003e stack = new Stack\u003c\u003e();\n​\n        // make a dp array of the same size as the input array `arr`\n        int[] dp = new int[arr.length];\n​\n        // making a monotonic increasing stack\n        for (int i = 0; i \u003c arr.length; i++) {\n            // pop the stack until it is empty or\n            // the top of the stack is greater than or equal to\n            // the current element\n            while (!stack.empty() \u0026\u0026 arr[stack.peek()] \u003e= arr[i]) {\n                stack.pop();\n            }\n​\n            // either the previousSmaller element exists\n            if (stack.size() \u003e 0) {\n                int previousSmaller = stack.peek();\n                dp[i] = dp[previousSmaller] + (i - previousSmaller) * arr[i];\n            } else {\n                // or it doesn't exist, in this case the current element\n                // contributes with all subarrays ending at i\n                dp[i] = (i + 1) * arr[i];\n            }\n            // push the current index\n            stack.push(i);\n        }\n​\n        // Add all elements of the dp to get the answer\n        long sumOfMinimums = 0;\n        for (int count : dp) {\n            sumOfMinimums += count;\n            sumOfMinimums %= MOD;\n        }\n​\n        return (int) sumOfMinimums;\n    }\n}\n​\n"},{"id":"974","name":" Subarray Sums Divisible by K","language":"java","code":"class Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int n = nums.length;\n        int prefixMod = 0, result = 0;\n​\n        // There are k mod groups 0...k-1.\n        int[] modGroups = new int[k];\n        modGroups[0] = 1;\n​\n        for (int num: nums) {\n            // Take modulo twice to avoid negative remainders.\n            prefixMod = (prefixMod + num % k + k) % k;\n            // Add the count of subarrays that have the same remainder as the current\n            // one to cancel out the remainders.\n            result += modGroups[prefixMod];\n            modGroups[prefixMod]++;\n        }\n​\n        return result;\n    }\n}\n"},{"id":"518","name":" Coin Change 2","language":"java","code":"class Solution {\n    public int change(int amount, int[] coins) {\n        int n = coins.length;\n        int[] dp = new int[amount + 1];\n        dp[0] = 1;\n        \n        for (int coin : coins) {\n            for (int i = 1; i \u003c= amount; i++) {\n                if (i \u003e= coin) {\n                    dp[i] += dp[i - coin];\n                }\n            }\n        }\n        \n        return dp[amount];\n    }\n}\n"},{"id":"55","name":" Jump Game","language":"java","code":"class Solution {\n    public boolean canJump(int[] nums) {\n        /*\n         * f(n) --\u003e f(n-1) + possibilities possibilities -\u003e (j + 0...arr[n-1]) can reach\n         * n?\n         */\n​\n        int maxjump = 0;\n        for (int i = 0; i \u003c= maxjump; i++) {\n            maxjump = Math.max(maxjump, i + nums[i]);\n            if (maxjump \u003e= nums.length-1)\n                return true;\n        }\n        return false;\n    }\n​\n    private boolean func(int[] nums, int curindex) {\n        // TODO Auto-generated method stub\n        if (curindex \u003e= nums.length - 1)\n            return true;\n​\n        int jumpCount = nums[curindex];\n        if (jumpCount == 0)\n            return false;\n​\n        for (int j = 1; j \u003c= jumpCount; j++) {\n            int nextidx = curindex + j;\n            boolean ans2 = func(nums, nextidx);\n            if (ans2)\n                return ans2;\n        }\n​\n        return false;\n    }\n}\n​\n"},{"id":"865","name":" Smallest Subtree with all the Deepest Nodes","language":"cpp","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* answer = nullptr; \n    int maxDepthNode = -1;\n    TreeNode* subtreeWithAllDeepest(TreeNode* root) {\n        TreeNode *tmp = root ;\n        dfs(tmp,0);\n        return answer ;\n    }\n    \n    int dfs(TreeNode* root, int curDepth) {\n        if(!root) {\n            return curDepth;\n        }\n        int leftside = dfs(root-\u003eleft, curDepth+1);\n        int rightside = dfs(root-\u003eright, curDepth+1);\n​\n        if(leftside == rightside) {\n            maxDepthNode = max(maxDepthNode, leftside);\n            if(maxDepthNode == leftside) {\n                answer = root;\n            }\n        }\n​\n        return max(leftside, rightside);\n    }\n"},{"id":"91","name":" Decode Ways","language":"cpp","code":"class Solution {\n    vector\u003cint\u003e dp;\n    int go(string \u0026s, int curindex) {\n        if (s[curindex] == '0' ) {\n            return 0;\n        }\n        if (curindex \u003e= s.length()) {\n            return 1;\n        }\n        if (dp[curindex]!=-1){\n            return dp[curindex];\n        }\n        int newWays = go(s, curindex+1);\n        if (curindex+2 \u003c= s.length() \u0026\u0026 stoi(s.substr(curindex,2)) \u003c= 26 ) {\n            newWays += go(s,curindex+2);\n        }\n        return dp[curindex] = newWays;\n    }\n    \npublic:\n    int numDecodings(string s) {\n        dp.resize((int)s.length(), -1);\n        return go(s,0);\n    }\n};\n"},{"id":"74","name":" Search a 2D Matrix","language":"java","code":"class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        return find(matrix, target);\n    }\n    private boolean find(int[][] grid, int target) {\n        int R = grid.length;\n        int C = grid[0].length;\n​\n        int lo = 0;\n        int hi = (R * C) - 1;\n​\n        while (lo \u003c= hi) {\n            int mid = (lo + hi) / 2;\n            int irow = mid / C;\n            int icol = mid % C;\n            int value = grid[irow][icol];\n​\n            if (value == target)\n                return true;\n            else if (value \u003c target)\n                lo = mid + 1;\n            else\n                hi = mid - 1;\n        }\n​\n        return false;\n    }\n}\n"},{"id":"976","name":" Largest Perimeter Triangle","language":"java","code":"class Solution {\n    public int largestPerimeter(int[] nums) {\n         Arrays.sort(nums);\n        \n        int perimeter =0;\n        \n        for(int i=nums.length-1; i \u003e= 2; i--){\n            if(nums[i-1] + nums[i-2] \u003e nums[i]){\n                perimeter = nums[i] + nums[i-1] +nums[i-2];\n                break;\n            }\n        }\n        return perimeter;       \n    }\n}\n"},{"id":"52","name":" N-Queens II","language":"java","code":"class Solution {\n    private int totalSolutions = 0;\n     public int totalNQueens(int n) {\n         boolean[] cols = new boolean[n];\n         boolean[] rightDiagonal = new boolean[2 * n];\n         boolean[] leftDiagonal = new boolean[2 * n];\n         \n         this.dfs(0,cols, leftDiagonal, rightDiagonal, n);\n        return this.totalSolutions;\n     }\n​\n    private void dfs(int currow, boolean[] cols, boolean[] leftDiagonal, boolean[] rightDiagonal, int n) {\n        // TODO Auto-generated method stub\n        \n        if (currow == n) this.totalSolutions++;\n        \n        for (int col = 0; col \u003c n; col++) {\n            int id1 = currow + col; // basically leftDiagonalPosition\n            // (row = 1, col = 0 -\u003e id1 = 4 ==\u003e 0 - 1 + 5 = 4 ) // basically rightDiagonalPosition\n            int id2 = col - currow + n;\n            \n            if(cols[col] || leftDiagonal[id1] || rightDiagonal[id2]) continue;\n            \n            cols[col] = leftDiagonal[id1] = rightDiagonal[id2] = true;\n            dfs(currow + 1, cols, leftDiagonal, rightDiagonal, n);\n            cols[col] = leftDiagonal[id1] = rightDiagonal[id2] = false;\n        }\n    }\n}\n"},{"id":"871","name":" Minimum Number of Refueling Stops","language":"java","code":"class Solution {\n    class Pair {\n        int fuel;\n        int mile;\n​\n        public Pair(int fuel, int mile) {\n            // TODO Auto-generated constructor stub\n            this.fuel = fuel;\n            this.mile = mile;\n        }\n​\n        @Override\n        public String toString() {\n            return \"Pair [fuel=\" + fuel + \", mile=\" + mile + \"]\";\n        }\n    }\n​\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\n        int minFuelStop = 0;\n​\n        if (startFuel \u003e= target)\n            return 0;\n​\n        PriorityQueue\u003cPair\u003e fuelStations = new PriorityQueue\u003c\u003e(new Comparator\u003cPair\u003e() {\n​\n            @Override\n            public int compare(Pair o1, Pair o2) {\n                // TODO Auto-generated method stub\n                if (o2.mile==o1.mile) {\n                    return o1.fuel - o2.fuel; \n                }\n                return o2.mile - o1.mile;\n            }\n        \n        }); // max heap on fuel\n        \n        for (int[] station : stations)\n            fuelStations.add(new Pair(station[0], station[1]));\n        \n        int currMile = startFuel;\n        while (fuelStations.isEmpty()==false \u0026\u0026 currMile \u003c target) {\n            Pair p = fuelStations.remove();\n            System.out.println(p);\n            if (currMile \u003e= p.fuel) {\n                currMile += p.mile;\n                minFuelStop++;\n            }\n        }\n        \n        return (target \u003c= currMile) ? minFuelStop : -1;\n    }\n}\n"},{"id":"931","name":" Minimum Falling Path Sum","language":"java","code":"public class Solution {\n    private class Cell {\n        int row;\n        int col;\n        int cost;\n\n        public Cell(int row, int col, int cost) {\n            this.row = row;\n            this.col = col;\n            this.cost = cost;\n        }\n\n        @Override\n        public String toString() {\n            return \"Cell [row=\" + row + \", col=\" + col + \", cost=\" + cost + \"]\";\n        }\n    }\n\n    private int miniCost = Integer.MAX_VALUE;\n\n    public int minFallingPathSum(int[][] matrix) {\n        int R = matrix.length;\n        int C = matrix[0].length;\n\n        /*\n         * dp[row][col] = matrix[row][col] + dp[row-1][col-1, col, col+1] until and\n         * unless is in safe side\n         */\n\n        int[][] dp = new int[R][C];\n        for (int col = 0; col \u003c C; col++)\n            dp[0][col] = matrix[0][col];\n\n        for (int row = 1; row \u003c R; row++) {\n            for (int col = 0; col \u003c C; col++) {\n                if (isThatCell(col, 0)) {\n                    dp[row][col] += Math.min(dp[row - 1][col], dp[row - 1][col + 1]) + matrix[row][col];\n                } else if (isThatCell(col, C - 1)) {\n                    dp[row][col] += Math.min(dp[row - 1][col], dp[row - 1][col - 1]) + matrix[row][col];\n                } else {\n                    dp[row][col] += Math.min(dp[row - 1][col - 1], Math.min(dp[row - 1][col], dp[row - 1][col + 1]))\n                            + matrix[row][col];\n                }\n            }\n        }\n\n        for (int[] row : dp) {\n            // System.out.println(Arrays.toString(row));\n        }\n\n        return Arrays.stream(dp[R - 1]).min().getAsInt();\n    }\n\n    private boolean isThatCell(int col, int C) {\n        return col == C;\n    }\n\n    public int minFallingPathSum2(int[][] matrix) {\n        int R = matrix.length;\n        int C = matrix[0].length;\n\n        for (int col = 0; col \u003c C; col++) {\n            Cell startCell = new Cell(0, col, matrix[0][col]);\n            getTheCostForFallingPath(matrix, startCell);\n        }\n        return miniCost;\n    }\n\n    private void getTheCostForFallingPath(int[][] matrix, Cell cell) {\n        int R = matrix.length;\n        int C = matrix[0].length;\n        int[] dy = new int[] { -1, 0, +1 };\n\n        for (int dir = 0; dir \u003c dy.length; dir++) {\n            int nextrow = cell.row + 1;\n            int nextcol = cell.col + dy[dir];\n\n            if (hasReached(new Cell(nextrow, nextcol, 0), R, C)) {\n                miniCost = Math.min(miniCost, cell.cost);\n                return;\n            }\n\n            if (!safeArea(nextrow, nextcol, R, C))\n                continue;\n            int newcost = cell.cost + matrix[nextrow][nextcol];\n            Cell nextcell = new Cell(nextrow, nextcol, newcost);\n            System.out.println(\"f=\" + cell + \" n=\" + nextcell);\n            getTheCostForFallingPath(matrix, nextcell);\n        }\n\n        return;\n    }\n\n    private boolean hasReached(Cell cell, int R, int C) {\n        return (cell.row == R);\n    }\n\n    private boolean safeArea(int r, int c, int R, int C) {\n        return (r \u003e= 0 \u0026\u0026 r \u003c R) \u0026\u0026 (c \u003e= 0 \u0026\u0026 c \u003c C);\n    }\n}\n"},{"id":"815","name":" Bus Routes","language":"java","code":"class Solution {\n    public int numBusesToDestination(int[][] routes, int source, int target) {\n        HashMap\u003cInteger, List\u003cInteger\u003e\u003e map = new HashMap\u003c\u003e();\n​\n        for (int bus_no = 0; bus_no \u003c routes.length; bus_no++) {\n            for (int c = 0; c \u003c routes[bus_no].length; c++) {\n                int stand = routes[bus_no][c];\n​\n                if (map.containsKey(stand) == true)\n                    map.get(stand).add(bus_no);\n                else {\n                    List\u003cInteger\u003e _bus_no = new ArrayList\u003c\u003e();\n                    _bus_no.add(bus_no);\n                    map.put(stand, _bus_no);\n                }\n            }\n        }\n​\n        Set\u003cInteger\u003e visited_buses = new HashSet\u003c\u003e();\n        Set\u003cInteger\u003e visited_stands = new HashSet\u003c\u003e();\n​\n        Queue\u003cInteger\u003e queue = new LinkedList\u003c\u003e();\n        queue.add(source);\n        int level = -1;\n​\n        while (queue.isEmpty() == false) {\n            int size = queue.size();\n            level++;\n​\n            while (size-- \u003e 0) {\n                int current_stand = queue.remove();\n​\n                if (current_stand == target)\n                    return level;\n​\n                for (int bus_no : map.get(current_stand)) {\n                    if (visited_buses.contains(bus_no) == false) {\n                        for (int bus_stand : routes[bus_no]) {\n                            if (visited_stands.contains(bus_stand) == false) {\n                                visited_stands.add(bus_stand);\n                                queue.add(bus_stand);\n                            }\n                        }\n                    }\n                    visited_buses.add(bus_no);\n                }\n            }\n        }\n​\n        return -1; // if no route found\n    }\n}\n"},{"id":"560","name":" Subarray Sum Equals K","language":"java","code":"class Solution {\n    public int subarraySum(int[] nums, int k) {\n        final int n = nums.length;\n        \n        Map\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e();\n        int cursum = 0;\n        int countOfSubarray = 0;\n        \n        for (int i = 0; i \u003c n; i++) {\n            int elem = nums[i];\n            \n            cursum += elem;\n            \n            if (cursum == k) {\n                countOfSubarray++;\n            }\n            \n            int diff = cursum - k;\n            if (map.containsKey(diff)==true) {\n                countOfSubarray += map.get(diff) ;\n            }\n            \n            map.put(cursum, map.getOrDefault(cursum, 0) + 1);\n        }\n        \n        return countOfSubarray;\n    }\n}\n"},{"id":"520","name":" Detect Capital","language":"java","code":"class Solution {\n    public boolean detectCapitalUse(String word) {\n        if(word.length() \u003c 2) return true;\n        return solver(word);\n    }\n    private boolean solver(String word){\n        if(Character.isUpperCase(word.charAt(0))){\n            if(Character.isUpperCase(word.charAt(1))){\n                for(int i=2; i\u003cword.length(); i++){\n                    if(!Character.isUpperCase(word.charAt(i))){\n                        return false;\n                    }\n                }\n            }else{\n                for(int i=2; i\u003cword.length(); i++){\n                    if(Character.isUpperCase(word.charAt(i))){\n                        return false;\n                    }\n                }\n            }\n        }else{\n            for(int i=1; i\u003cword.length(); i++){\n                if(Character.isUpperCase(word.charAt(i))){\n                        return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n"},{"id":"872","name":" Leaf-Similar Trees","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean leafSimilar(TreeNode root1, TreeNode root2) {\n        /*\n         * store all the nodes of indivisual tree and compare\n         */\n        return preorder(root1).equals(preorder(root2));\n    }\n​\n    private String preorder(TreeNode root) {\n        // TODO Auto-generated method stub\n        if (root == null)\n            return \"\";\n        if (isLeaf(root))\n            return \"-\" + root.val + \"-\";\n        String left = preorder(root.left);\n        String right = preorder(root.right);\n        return left + right;\n    }\n​\n    private boolean isLeaf(TreeNode root) {\n        // TODO Auto-generated method stub\n        return (root != null \u0026\u0026 root.left == null \u0026\u0026 root.right == null);\n    }\n}\n​\n"},{"id":"934","name":" Shortest Bridge","language":"java","code":"class Solution {\n    int row, col;\n    public int shortestBridge(int[][] a) {\n        row = a.length;\n        col = a[0].length;\n        Queue\u003cint[]\u003e q = new LinkedList();\n        for (int i = 0; i \u003c row \u0026\u0026 q.isEmpty(); i++) {\n            for (int j = 0; j \u003c col \u0026\u0026 q.isEmpty(); j++) {\n                if (a[i][j]==1) dfs(i, j, q, a);\n            }\n        }\n        int[][] dirs = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        while (q.isEmpty()==false) {\n            int[] cur = q.poll();\n            for (int[] dir : dirs) {\n                int i = cur[0] + dir[0], j = cur[1] + dir[1];\n                if (i \u003c 0 || i == row || j \u003c 0 || j == col || a[i][j]==-1) continue;\n                if (a[i][j]==1) return cur[2];\n                a[i][j] = -1;\n                q.add(new int[]{i, j, cur[2]+1});//increase distance\n            }\n        }\n        return -1;\n    }\n    public void dfs(int i, int j, Queue\u003cint[]\u003e q, int[][] a) {\n        if (i \u003c 0 || i == row || j \u003c 0 || j == col || a[i][j]!=1) return;\n        //a value is 1\n        a[i][j] = -1;\n        q.add(new int[]{i, j, 0});//0 distance travelled\n        dfs(i+1, j, q, a);\n        dfs(i-1, j, q, a);\n        dfs(i, j+1, q, a);\n        dfs(i, j-1, q, a);\n    }\n}\n"},{"id":"977","name":" Squares of a Sorted Array","language":"cpp","code":"class Solution {\npublic:\n    vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) {\n       /* \n         // --\u003e O(NlogN) solution\n        for_each(nums.begin(), nums.end(), [\u0026](int \u0026n) {return n = n*n;});\n        sort(nums.begin(), nums.end());\n        return nums ;\n        */\n        \n        // Quite efficient - O(N) solution\n        int n = nums.size() ;\n        vector\u003cint\u003e answer(n) ;\n        for (int i = 0, j = n-1, k = j; i \u003c= j; k-- ) {\n            if( pow(nums[i], 2) \u003e pow(nums[j],2)) {\n                answer[k] = nums[i]*nums[i];\n                i++ ;\n            } else {\n                answer[k] = nums[j]*nums[j];\n                j-- ;\n            }\n        }\n        return answer ;\n    }\n};\n"},{"id":"745","name":" Prefix and Suffix Search","language":"java","code":"class WordFilter {\n    private HashMap\u003cString, Integer\u003e cache =  new HashMap\u003c\u003e();\n    /**\n     * For a word like \"test\", consider \"#test\", \"t#test\", \"st#test\", \"est#test\",\n     * \"test#test\". Then if we have a query like prefix = \"te\", suffix = \"t\", we can\n     * find it by searching for something we've inserted starting with \"t#te\".\n     */\n    \n    public WordFilter(String[] words) {\n        String salt = \"$@\"; int wordIdx = 0;\n        for (int i = 0; i \u003c words.length; i++) {\n            for (int j = 0; j \u003c words[i].length(); j++) {\n                for (int k = 0; k \u003c words[i].length(); k++) {\n                    String key = words[i].substring(0, j+1) + salt + words[i].substring(k);\n                    cache.put(key, i);\n                }\n            }\n        }\n    }\n    \n    public int f(String prefix, String suffix) {\n        String key = prefix+\"$@\"+suffix;\n        return cache.getOrDefault(key, -1);\n    }\n}\n​\n/**\n * Your WordFilter object will be instantiated and called as such:\n * WordFilter obj = new WordFilter(words);\n * int param_1 = obj.f(prefix,suffix);\n */\n"},{"id":"556","name":" Next Greater Element III","language":"java","code":"class Solution {\n  private int dipIndex(char[] arr) {\n        int indx = arr.length - 2;\n        while(indx \u003e= 0 \u0026\u0026 (arr[indx] \u003e= arr[indx + 1])) {\n            indx--;\n        }\n        return indx;\n    }\n​\n    private  int ceilIndex(char[] arr, int indx) {\n        for(int i = arr.length - 1; i \u003e= 0; i--) {\n            if(arr[i] \u003e arr[indx]) {\n                return i;\n            }\n        }\n        return -1;\n    } \n​\n    private void swap(char[] arr, int left, int right) {\n        char temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n    }\n​\n    private void reverse(char[] arr, int indx) {\n        int left = indx;\n        int right = arr.length - 1;\n        while(left \u003c right) {\n            swap(arr, left, right);\n            left++;\n            right--;\n        }\n    }\n    \n    public String nextGreaterElement_(String str) {\n        if(str.length() == 1) return \"-1\";\n        char[] arr = str.toCharArray();\n        int dipIndx = dipIndex(arr);\n        if(dipIndx == -1) {\n            return \"-1\";\n        }\n        int ceilIndx = ceilIndex(arr, dipIndx);\n        swap(arr, dipIndx, ceilIndx);\n        reverse(arr, dipIndx + 1);\n        return String.valueOf(arr);\n    }\n​\n​\n​\n    // for leetcode, above problem\n    public int nextGreaterElement(int n) {\n        String str = n + \"\";\n        String res_ = nextGreaterElement_(str);\n        long res = Long.parseLong(res_);\n        if(res \u003c= Integer.MAX_VALUE) {\n            return (int)res;\n        } else {\n            return -1;\n        }\n    }\n}\n"},{"id":"82","name":" Remove Duplicates from Sorted List II","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n         ListNode dummy = new ListNode(-1);\n        ListNode temp = dummy;\n​\n        while (head != null) {\n​\n            if (head.next != null \u0026\u0026 head.val == head.next.val) {\n                // skipping the duplicate nodes\n                while (head.next != null \u0026\u0026 head.val == head.next.val)\n                    head = head.next;\n                temp.next = head.next;\n            }\n​\n            else {\n                temp.next = head;\n                temp = temp.next;\n            }\n​\n            head = head.next;\n        }\n        return dummy.next;\n    }\n}\n"},{"id":"754","name":" Reach a Number","language":"cpp","code":"class Solution {\npublic:\n    int reachNumber(int n) {\n        n = abs(n);\n​\n        int sum = 0, steps = 0;\n        while(sum \u003c n) {sum+=(steps++);}\n        while ((sum-n) % 2 == 1) {\n            sum+= (steps++);\n        }\n        return steps-1;\n    }\n};\n"},{"id":"561","name":" Array Partition I","language":"java","code":"class Solution {\n    public int arrayPairSum(int[] nums) {\n        Arrays.sort(nums);\n        int ans = 0;\n​\n        for (int i = 0; i \u003c nums.length; i += 2) {\n            ans += nums[i]; // pair = { nums[i], nums[i+1] }\n        }\n​\n        return ans;\n    }\n}\n"},{"id":"994","name":" Rotting Oranges","language":"java","code":"class Solution {\n    public int orangesRotting(int[][] grid) {\n        int timeElapsed = 0;\n​\n        int R = grid.length;\n        int C = grid[0].length;\n​\n        // faster access for fresh / rotten\n        Set\u003cString\u003e freshOranges = new HashSet\u003cString\u003e();\n        Set\u003cString\u003e rottenOranges = new HashSet\u003cString\u003e();\n​\n        for (int row = 0; row \u003c R; row++) {\n            for (int col = 0; col \u003c C; col++) {\n                int o = grid[row][col];\n                String key = generateKey(row, col);\n                if (o == 1)\n                    freshOranges.add(key);\n                else if (o == 2)\n                    rottenOranges.add(key);\n            }\n        }\n​\n        int[] dx = new int[] { 1, -1, 0, 0 };\n        int[] dy = new int[] { 0, 0, -1, 1 };\n​\n        // joto khon fresh orange ache\n        while (freshOranges.isEmpty() == false) {\n            Set\u003cString\u003e infected = new HashSet\u003cString\u003e();\n​\n            for (String s : rottenOranges) {\n                int row = s.charAt(0) - '0';\n                int col = s.charAt(2) - '0';\n​\n                for (int k = 0; k \u003c 4; k++) {\n                    int nrow = row + dx[k];\n                    int ncol = col + dy[k];\n                    String key = generateKey(nrow, ncol);\n                    if (freshOranges.contains(key) == true) {\n                        freshOranges.remove(key);\n                        infected.add(key);\n                    }\n                }\n            }\n            if (infected.size() == 0)\n                return -1;\n            rottenOranges.addAll(infected);\n            timeElapsed++;\n        }\n​\n        return timeElapsed;\n    }\n​\n    private String generateKey(int row, int col) {\n        // TODO Auto-generated method stub\n        return \"\" + row + \"#\" + col;\n    }\n​\n}\n"},{"id":"816","name":" Ambiguous Coordinates","language":"java","code":"class Solution {\n    public List\u003cString\u003e ambiguousCoordinates(String S) {\n        List\u003cString\u003e ans = new ArrayList();\n        for (int i = 2; i \u003c S.length()-1; ++i)\n            for (String left: make(S, 1, i))\n                for (String right: make(S, i, S.length()-1))\n                    ans.add(\"(\" + left + \", \" + right + \")\");\n        return ans;\n    }\n​\n    public List\u003cString\u003e make(String S, int i, int j) {\n        // Make on S.substring(i, j)\n        List\u003cString\u003e ans = new ArrayList();\n        for (int d = 1; d \u003c= j-i; ++d) {\n            String left = S.substring(i, i+d);\n            String right = S.substring(i+d, j);\n            if ((!left.startsWith(\"0\") || left.equals(\"0\"))\n                    \u0026\u0026 !right.endsWith(\"0\"))\n                ans.add(left + (d \u003c j-i ? \".\" : \"\") + right);\n        }\n        return ans;\n    }\n}\n"},{"id":"76","name":" Minimum Window Substring","language":"java","code":"class Solution {\n    public String minWindow(String s, String t) {\n        return this.miniWindowSubstring(s, t);\n    }\n    \n    private String miniWindowSubstring(String s, String p) {\n        /**\n         * in this problem the problem is we donot know what will be the window length\n         * as its a dynamic / variable size window problem.\n         * \n         * thr trick is always for such kind of problem check how many characters were matched?.\n         * that is going to be your first Window\n         */\n        int[] sfreq = new int[256];\n        int[] pfreq = new int[256];\n\n        for (int c : p.toCharArray()) {\n            pfreq[c]++;\n        }\n\n        int start = 0;\n\n        int cnt = 0;\n        int start_idx = -1;\n        int maxLength = Integer.MAX_VALUE;\n\n        for (int end = 0; end \u003c s.length(); end++) {\n            int schar = s.charAt(end);\n            sfreq[schar]++;\n            // count of chars matched with `p` so far\n            if (pfreq[schar] != 0 \u0026\u0026 sfreq[schar] \u003c= pfreq[schar]) {\n                cnt++;\n            }\n\n            if (cnt == p.length()) {\n                // start reducing the curr window\n                while (pfreq[s.charAt(start)] == 0 || sfreq[s.charAt(start)] \u003e pfreq[s.charAt(start)]) {\n                    sfreq[s.charAt(start)]--;\n                    start++;\n                }\n\n                int windowLength = end - start + 1;\n                if (windowLength \u003c maxLength) {\n                    start_idx = start;\n                    maxLength = windowLength;\n                }\n            }\n        }\n\n        if (start_idx == -1) {\n            System.out.println(\"no window found\");\n            return \"\";\n        }\n\n        String answer = s.substring(start_idx, start_idx + maxLength);\n        return answer;\n    }\n\n    private String minimumWindowSubstring(String s, String p, int start, int end) {\n        if (s.length() \u003c p.length())\n            return \"\";\n\n        if (s.equals(p))\n            return p;\n        if (start \u003e end) {\n            return s;\n        }\n\n        String substring = s.substring(start, end + 1);\n        if (this.isPatternFound(substring, p)) {\n            int substringLength = substring.length();\n            String rres = this.minimumWindowSubstring(s, p, start + 1, end);\n            if (rres == null)\n                return substring;\n            return substringLength \u003c rres.length() ? substring : rres;\n        }\n\n        String way1 = this.minimumWindowSubstring(s, p, start + 1, end);\n        String way2 = this.minimumWindowSubstring(s, p, start, end - 1);\n        if (way1 == null)\n            return way2;\n        if (way2 == null)\n            return way1;\n        return way1.length() \u003c way2.length() ? way1 : way2;\n    }\n\n    private boolean isPatternFound(String s, String p) {\n        Map\u003cCharacter, Integer\u003e smap = new HashMap\u003c\u003e();\n        for (char c : s.toCharArray())\n            smap.put(c, smap.getOrDefault(c, 0) + 1);\n\n        for (char pc : p.toCharArray()) {\n            if (smap.containsKey(pc)) {\n                int freq = smap.get(pc);\n                if (freq == 0) {\n                    smap.remove(pc);\n                    return false;\n                }\n                smap.put(pc, freq - 1);\n            } else {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"},{"id":"75","name":" Sort Colors","language":"java","code":"class Solution {\n    public void sortColors(int[] nums) {\n        int zero = 0, one = 0;\n        for (int x : nums){\n            if(x == 0) zero++;\n            if(x == 1) one++;\n        }\n        int i = 0;\n        while(zero-- \u003e 0)\n            nums[i++] = 0;\n        while(one-- \u003e 0)\n            nums[i++] = 1;\n        while(i \u003c nums.length)\n            nums[i++] = 2;\n    }\n}\n"},{"id":"Amazon5Apple4Microsoft2LinkedIn2Facebook2Adobe2Twitter2MindTickle2895","name":" Maximum Frequency Stack","language":"java","code":"class FreqStack {\n  private Map\u003cInteger, Stack\u003cInteger\u003e\u003e stackMap = new HashMap\u003c\u003e(); // \u003cfreq, stack\u003e\n    private Map\u003cInteger, Integer\u003e accessCountMap = new HashMap\u003c\u003e(); // \u003cfreq, count\u003e\n    int maximumFrequency = 0;\n​\n    void push(int val) {\n        accessCountMap.put(val, accessCountMap.getOrDefault(val, 0) + 1);\n        maximumFrequency = Math.max(maximumFrequency, accessCountMap.get(val));\n​\n        stackMap.putIfAbsent(accessCountMap.get(val), new Stack\u003c\u003e());\n        stackMap.get(accessCountMap.get(val)).add(val);\n    }\n​\n    int pop() {\n        // return the val whose accessControl Map is too latest...\n        int elem = stackMap.get(maximumFrequency).pop();\n        // work on the maximumFreq reduction logic\n        if (stackMap.get(maximumFrequency).size() == 0) {\n            maximumFrequency--;\n        }\n        accessCountMap.put(elem, accessCountMap.get(elem) - 1);\n​\n        return elem;\n    }\n}\n​\n/**\n * Your FreqStack object will be instantiated and called as such:\n * FreqStack obj = new FreqStack();\n * obj.push(val);\n * int param_2 = obj.pop();\n */\n"},{"id":"752","name":" Open the Lock","language":"java","code":"class Solution {\n    public int openLock(String[] deadends, String target) {\n        if (target.equals(\"0000\")) return 0;\n        Queue\u003cInteger\u003e queue = new LinkedList\u003c\u003e();\n        queue.add(0);\n        boolean[] seen = new boolean[10000];\n        for (String el : deadends)\n            seen[Integer.parseInt(el)] = true;\n        int targ = Integer.parseInt(target);\n        if (seen[0]) return -1;\n        for (int turns = 1; !queue.isEmpty(); turns++) {\n            int qlen = queue.size();\n            for (int i = 0; i \u003c qlen; i++) {\n                int curr = queue.poll();\n                for (int j = 1; j \u003c 10000; j *= 10) {\n                    int mask = curr % (j * 10) / j,\n                        masked = curr - (mask * j);\n                    for (int k = 1; k \u003c 10; k += 8) {\n                        int next = masked + (mask + k) % 10 * j;\n                        if (seen[next]) continue;\n                        if (next == targ) return turns;\n                        seen[next] = true;\n                        queue.add(next);\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n"},{"id":"98","name":" Validate Binary Search Tree","language":"java","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        return simpleCheck(root, Long.MIN_VALUE, Long.MAX_VALUE);\n        // return isBST(root).isbst;\n    }\n\n    boolean simpleCheck(TreeNode root, long start, long end) {\n        if (root == null) return true ;\n\n        if (start \u003c root.val \u0026\u0026 root.val \u003c end) {\n            boolean leftTree = simpleCheck(root.left, start, root.val);\n            boolean rightTree = simpleCheck(root.right, root.val, end);\n            return leftTree \u0026\u0026 rightTree;\n        }\n\n        return false;\n    }\n    \n    class State {\n        int minimum;\n        int maximum;\n        boolean isbst;\n\n        State() {\n            this.minimum = Integer.MAX_VALUE;\n            this.maximum = Integer.MIN_VALUE;\n            this.isbst = true;\n        }\n        State(int min, int mx, boolean bst) {\n            this.minimum = min;\n            this.maximum = mx;\n            this.isbst = bst;\n        }\n    }\n\n    State isBST(TreeNode root) {\n        if (root == null) return new State();\n        \n        // faith\n        State left = isBST(root.left);\n        State right = isBST(root.right);\n\n        if (left.isbst == false || right.isbst == false) return new State(Integer.MAX_VALUE, Integer.MIN_VALUE, false); \n\n        boolean isbst = (left.maximum \u003c root.val \u0026\u0026 root.val \u003c right.minimum) ? true : false ;\n        if (isbst == false) return new State(Integer.MAX_VALUE, Integer.MIN_VALUE, false);\n\n        State state = new State();\n        state.minimum = Math.min(left.minimum, right.minimum);\n        state.maximum = Math.min(left.maximum, right.maximum);\n        state.isbst = isbst;\n\n        return state;\n    }\n}\n"},{"id":"Goldman Sachs11Amazon5Google2740","name":" Delete and Earn","language":"java","code":"class Solution {\n    private int MOD = 1000000007;\n​\n    public int deleteAndEarn(int[] nums) {\n        /**\n         * 1. maximise the points\n         * 2. operations:\n         * 2.1. nums[i] pick any, and delete. score += nums[i]\n         * 2.2. after that, delete, nums[i] - 1 and nums[i] + 1.\n         * \n         * [3,4,2]\n         * 3 --- 2x 4x -- [_,_,_]\n         * 2 --- 1x 3x -- [_,4,_] ---\u003e (2+4) --\u003e 6\n         * 4 --- 3x 5x -- [_,_,2] ---\u003e (4+2) --\u003e 6\n         * \n         * [2,2,3,3,3,4]\n         * [_,_,_,3,3,_] 3\n         * [_,_,_,_,3,_] 3+3=6\n         * [_,_,_,_,_,_] 6+3=9 **** highest ****\n         **/\n​\n        int included = 0;\n        int excluded = 0;\n        int[] countFrequency = new int[100000];\n​\n        for (int i = 0; i \u003c nums.length; i++) {\n            countFrequency[nums[i]]++;\n        }\n​\n        for (int i = 0; i \u003c countFrequency.length; i++) {\n            int ninclude = excluded + countFrequency[i] * i;\n            int nexclude = Math.max(excluded, included);\n​\n            included = ninclude;\n            excluded = nexclude;\n        }\n​\n        return Math.max(included, excluded);\n​\n    }\n}\n"},{"id":"Facebook18515","name":" Find Largest Value in Each Tree Row","language":"java","code":"class Solution {\n    private static class Pair {\n        TreeNode node;\n        int level;\n​\n        Pair(TreeNode node, int level) {\n            this.node = node;\n            this.level = level;\n        }\n    }\n​\n    public List\u003cInteger\u003e largestValues(TreeNode root) {\n        // simply perform the level order traversal on the tree\n        // store the vals into a sorted list set like TreeSet / PriorityQueue\n        if (root==null) return new ArrayList\u003c\u003e();\n        int level = 0;\n        Queue\u003cPair\u003e queue = new LinkedList\u003c\u003e();\n        Map\u003cInteger, PriorityQueue\u003cInteger\u003e\u003e pqMap = new TreeMap\u003c\u003e();\n​\n        queue.offer(new Pair(root, level));\n        pqMap.putIfAbsent(level, new PriorityQueue\u003c\u003e(Comparator.reverseOrder()));\n​\n        // until my queue is not empty\n        while (!queue.isEmpty()) {\n            int qsize = queue.size();\n            for (int k = 0; k \u003c qsize; k++) {\n                Pair pairNode = queue.poll();\n                pqMap.putIfAbsent(pairNode.level, new PriorityQueue\u003c\u003e(Comparator.reverseOrder()));\n                pqMap.get(pairNode.level).add(pairNode.node.val);\n                if (pairNode.node.left != null) {\n                    queue.add(new Pair(pairNode.node.left, pairNode.level + 1));\n                }\n                if (pairNode.node.right != null) {\n                    queue.add(new Pair(pairNode.node.right, pairNode.level + 1));\n                }\n            }\n        }\n​\n        List\u003cInteger\u003e levelMaximumList = new ArrayList\u003c\u003e();\n        for (Map.Entry\u003cInteger, PriorityQueue\u003cInteger\u003e\u003e kv : pqMap.entrySet()) {\n            int levelMax = kv.getValue().poll();\n            levelMaximumList.add(levelMax);\n        }\n​\n        return levelMaximumList;\n    }\n}\n"},{"id":"Google3Amazon2Walmart Global Tech2355","name":" Design Twitter","language":"java","code":"// Sounish Nath - 17.10.2023\n\nclass Tweet {\n    int tweetId;\n    int userId;\n    int clock;\n    \n    Tweet(int ti, int ui, int c) {\n        tweetId=ti;\n        userId=ui;\n        clock=c;\n    }\n}\n\nclass User {\n    int userId;\n    Set\u003cInteger\u003e followees=new HashSet\u003c\u003e();\n    LinkedList\u003cTweet\u003e tweets=new LinkedList\u003c\u003e();\n    \n    User (int ui) {\n        userId=ui;\n    }\n    \n    void publishTweet(int twi, int c) {\n        tweets.addLast(new Tweet(twi, userId, c));\n        if (tweets.size() \u003e 10) {\n            tweets.removeFirst();\n        }\n    }\n}\n\nclass Twitter {\n    \n    private Map\u003cInteger, User\u003e users=new HashMap\u003c\u003e();\n    private int clock=0; // monotonically increasing counter;\n\n    public Twitter() {\n        \n    }\n    \n    public void postTweet(int userId, int tweetId) {\n        users.putIfAbsent(userId, new User(userId));\n        users.get(userId).publishTweet(tweetId, ++clock);\n    }\n    \n    public List\u003cInteger\u003e getNewsFeed(int userId) {\n        users.putIfAbsent(userId, new User(userId));\n        \n        User user=users.get(userId);\n        PriorityQueue\u003cTweet\u003e pq=new PriorityQueue\u003c\u003e((a,b) -\u003e {\n            return b.clock - a.clock; // highest value on TOP ==\u003e Mxheap\n        });\n        \n        for (Tweet tweet : user.tweets) {\n            pq.offer(tweet);\n        }\n        \n        // go all of her followees and put their tweets into pq\n        for (Integer fId : user.followees) {\n            User followee=users.get(fId);\n            // grab all of tweets\n            for (Tweet tweet : followee.tweets) {\n                pq.offer(tweet);\n            }\n        }\n        \n        // take the top 10. from pq\n        List\u003cInteger\u003e tws=new ArrayList\u003c\u003e();\n        for (int i=0; i \u003c 10 \u0026\u0026 !pq.isEmpty(); i++) {\n            tws.add(pq.poll().tweetId);\n        }\n        \n        return tws;\n    }\n    \n    public void follow(int followerId, int followeeId) {\n        users.putIfAbsent(followerId, new User(followerId));\n        users.putIfAbsent(followeeId, new User(followeeId));\n        \n        users.get(followerId).followees.add(followeeId);\n        \n    }\n    \n    public void unfollow(int followerId, int followeeId) {\n        users.putIfAbsent(followerId, new User(followerId));\n        users.putIfAbsent(followeeId, new User(followeeId));\n        \n        users.get(followerId).followees.remove(followeeId);\n    }\n}\n"},{"id":"746","name":" Min Cost Climbing Stairs","language":"java","code":"class Solution {\n    private HashMap\u003cInteger, Integer\u003e dp = new HashMap\u003c\u003e();\n    public int minCostClimbingStairs(int[] cost) {\n        int finalCost = this._minCostClimbingStairs(cost, cost.length);\n        return finalCost;\n    }\n​\n    private int _minCostClimbingStairs(int[] cost, int curIndex) {\n​\n        if (curIndex \u003c 2)\n            return 0;\n​\n        if (dp.containsKey(curIndex))\n            return this.dp.get(curIndex);\n​\n        // faith\n        int costWithStep1 = this._minCostClimbingStairs(cost, curIndex - 1);\n        int costWithStep2 = this._minCostClimbingStairs(cost, curIndex - 2);\n​\n        costWithStep1 += cost[curIndex-1];\n        costWithStep2 += cost[curIndex-2];\n​\n        int minSoFar = Math.min(costWithStep1, costWithStep2);\n​\n        this.dp.put(curIndex, minSoFar);\n        return minSoFar;\n    }\n}\n"},{"id":"98","name":" Validate Binary Search Tree","language":"js","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    function validateBST (root, start, end) {\n        if(!root) {\n            return true ;\n        }\n​\n        if(start \u003c root.val \u0026\u0026 root.val \u003c end) {\n            return true \u0026\u0026 validateBST(root.left, start, root.val) \u0026\u0026 validateBST(root.right, root.val, end) ;\n        }\n        return false ;\n    }\n​\n    return validateBST(root, -Infinity, Infinity)\n};\n"},{"id":"769","name":" Max Chunks To Make Sorted","language":"java","code":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        return maxChunksToSorted1(arr);\n    }\n    public int maxChunksToSorted1(int[] arr) {\n        int chunks = 0;\n        int max = 0;\n        for(int i = 0; i \u003c arr.length; i++) {\n            max = Math.max(max, arr[i]);\n            if(max == i)\n                chunks++;\n        }\n        return chunks;\n    }\n​\n}\n"},{"id":"Facebook9Amazon8Microsoft7Bloomberg2Adobe2Apple224","name":" Swap Nodes in Pairs","language":"java","code":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        // if single node or NULL return itself....\n        if (head == null || head.next == null) {\n            return head;\n        }\n        \n        ListNode rres=swapPairs(head.next.next);\n        \n        ListNode nextnode=head.next;\n        nextnode.next=head;\n        head.next=rres;\n        \n        return nextnode;\n    }\n}\n"},{"id":"987","name":" Vertical Order Traversal of a Binary Tree","language":"java","code":"class Solution {\n    static class NodePair {\n        int level;\n        int horizontal_distance;\n        TreeNode node;\n        public NodePair(int level, int horizontal_distance, TreeNode node) {\n            this.level = level;\n            this.horizontal_distance = horizontal_distance;\n            this.node = node;\n        }\n​\n    }\n    public List\u003cList\u003cInteger\u003e\u003e verticalTraversal(TreeNode root) {\n        Queue\u003cNodePair\u003e queue = new LinkedList\u003c\u003e();\n        queue.offer(new NodePair(0, 0, root));\n        Map\u003cInteger, TreeMap\u003cInteger,PriorityQueue\u003cTreeNode\u003e\u003e\u003e node_map = new TreeMap\u003c\u003e(); // \u003cHD, \u003cLEVEL,NODEPAIR\u003e\u003e\n​\n        while (!queue.isEmpty()) {\n            NodePair node = queue.poll();\n            if (!node_map.containsKey(node.horizontal_distance)) {\n                node_map.put(node.horizontal_distance, new TreeMap\u003c\u003e());\n            } \n            if (!node_map.get(node.horizontal_distance).containsKey(node.level)) {\n                node_map.get(node.horizontal_distance).put(node.level, new PriorityQueue\u003c\u003e((a, b) -\u003e a.val - b.val ));\n            }\n            node_map.get(node.horizontal_distance).get(node.level).offer(node.node);\n            if (node.node.left != null) {\n                queue.offer(new NodePair(node.level+1, node.horizontal_distance-1, node.node.left));\n            }\n            if (node.node.right != null) {\n                queue.offer(new NodePair(node.level+1, node.horizontal_distance+1, node.node.right));\n            }\n        }\n​\n        List\u003cList\u003cInteger\u003e\u003e list = new ArrayList\u003c\u003e();\n        for (TreeMap\u003cInteger, PriorityQueue\u003cTreeNode\u003e\u003e ys : node_map.values()) {\n            list.add(new ArrayList\u003c\u003e());\n            for (PriorityQueue\u003cTreeNode\u003e nodes : ys.values()) {\n                while (!nodes.isEmpty()) {\n                    list.get(list.size() - 1).add(nodes.poll().val);\n                }\n            }\n        }\n        return list;\n    }\n}\n"},{"id":"766","name":" Toeplitz Matrix","language":"java","code":"class Solution {\n    public boolean isToeplitzMatrix(int[][] matrix) {\n        int R = matrix.length;\n        int C = matrix[0].length;\n​\n        // check for upper right corners\n        for(int col=0; col \u003c C; col++) {\n            boolean f = checkUpperDiagonal(matrix, col);\n            if(!f) return false;\n        }\n​\n        // check for lower left corners\n        for(int row=0; row \u003c R; row++) {\n            boolean f = checkLowerDiagonal(matrix, row);\n            if(!f) return false;\n        }\n​\n        return true;\n    }\n​\n    private boolean checkLowerDiagonal(int[][] matrix, int row) {\n        // TODO Auto-generated method stub\n        int R = matrix.length;\n        int C = matrix[0].length;\n​\n        int felem=matrix[row][0];\n        for(int col=0; row \u003c R \u0026\u0026 col \u003c C; row++, col++) {\n            int selem=matrix[row][col];\n            if(felem != selem) return false;\n        }\n​\n        return true;\n    }\n​\n    private boolean checkUpperDiagonal(int[][]matrix, int col) {\n        // TODO Auto-generated method stub\n        int R = matrix.length;\n        int C = matrix[0].length;\n​\n        int felem=matrix[0][col];\n        for(int row = 0; row \u003c R \u0026\u0026 col \u003c C; row++, col++) {\n            int selem=matrix[row][col];\n            if(felem!=selem) return false;\n        }\n​\n        return true;\n    }\n}\n"},{"id":"No companies found for this problem1269","name":" Number of Ways to Stay in the Same Place After Some Steps","language":"java","code":"​\nclass Solution {\n    private Map\u003cString, Integer\u003e cache = new HashMap\u003c\u003e();\n    private int MOD = 1000000007;\n​\n    public int numWays(int steps, int arrLen) {\n        return exploreAllWays(steps, arrLen, 0, \"*\");\n    }\n​\n    private int exploreAllWays(int steps, int arrLen, int currentIndex, String choosen) {\n​\n        if (steps \u003c 0 || currentIndex \u003c 0 || currentIndex \u003e= arrLen)\n            return 0;\n​\n        String key = \"\" + steps + \"#\" + currentIndex;\n        if (cache.containsKey(key))\n            return cache.get(key);\n​\n        // System.out.println(\"i am triggered....\");\n​\n        if (steps == 0 \u0026\u0026 currentIndex == 0) {\n            // System.out.println(choosen);\n            return 1;\n        }\n​\n        int rres = 0;\n        rres = (rres + (exploreAllWays(steps - 1, arrLen, currentIndex + 1, choosen + \"-RIGHT\") % MOD)) % MOD;\n        rres = (rres + (exploreAllWays(steps - 1, arrLen, currentIndex - 1, choosen + \"-LEFT\") % MOD)) % MOD;\n        rres = (rres + (exploreAllWays(steps - 1, arrLen, currentIndex, choosen + \"-STAY\") % MOD)) % MOD;\n​\n        int out = rres % MOD;\n        cache.put(key, out);\n​\n        return out;\n    }\n}\n"},{"id":"990","name":" Satisfiability of Equality Equations","language":"java","code":"class Solution {\n    public boolean equationsPossible(String[] equations) {\n        int[] parent = new int[26];\n        for (int i = 0; i \u003c parent.length; i++) {\n            parent[i] = i;\n        }\n​\n        for (int i = 0; i \u003c equations.length; i++) {\n            if (equations[i].charAt(1) == '=') {\n                int x = equations[i].charAt(0) - 'a';\n                int y = equations[i].charAt(3) - 'a';\n​\n                int leader_x = find_leader(parent, x);\n                int leader_y = find_leader(parent, y);\n                \n                System.out.println(leader_x + \" - \" + leader_y);\n​\n                if (leader_x == leader_y) continue;\n                do_union(leader_x, leader_y, parent);\n            }\n        }\n​\n        for (int i = 0; i \u003c equations.length; i++) {\n            if (equations[i].charAt(1) == '!') {\n                int x = equations[i].charAt(0) - 'a';\n                int y = equations[i].charAt(3) - 'a';\n​\n                int leader_x = find_leader(parent, x);\n                int leader_y = find_leader(parent, y);\n​\n                if (leader_x == leader_y) return false;\n            }\n        }\n​\n        return true;\n    }\n​\n    private void do_union(int leader_x, int leader_x1, int[] parent) {\n        if (leader_x1 != leader_x)\n            parent[leader_x1] = leader_x;\n    }\n    \n    // with path compression\n    private int find_leader(int[] parent, int x) {\n        if (parent[x]==x) return x;\n        int t = find_leader(parent, parent[x]);\n        parent[x]=t;\n        return t;\n    }\n}\n"},{"id":"77","name":" Combinations","language":"cpp","code":"class Solution {\npublic:\n    void dfs( vector\u003cvector\u003cint\u003e\u003e\u0026 subsets,\n    int index, int n, int k, vector\u003cint\u003e currrent) {\n        if((int) currrent.size() == k) {\n            subsets.push_back(currrent);\n            return;\n        }\n        for(int i = index; i \u003c n+1; i++) {\n            currrent.push_back(i);\n            dfs(subsets, i+1, n, k, currrent);\n            currrent.pop_back();\n        }\n    }\n    \n    vector\u003cvector\u003cint\u003e\u003e combine(int n, int k) {\n      vector\u003cvector\u003cint\u003e\u003e subsets;\n      dfs(subsets, 1, n, k, vector\u003cint\u003e());\n      return subsets;\n    }\n};\n"},{"id":"981","name":" Time Based Key-Value Store","language":"java","code":"class TimeMap {\n    private Map\u003cString, TreeMap\u003cInteger, String\u003e\u003e cache;\n​\n    public TimeMap() {\n        this.cache = new HashMap\u003c\u003e();\n    }\n​\n    public void set(String key, String value, int timestamp) {\n        if (this.cache.containsKey(key)) {\n            TreeMap\u003cInteger, String\u003e keystore = this.cache.get(key);\n            keystore.put(timestamp, value);\n        } else {\n            // new entry\n            TreeMap\u003cInteger, String\u003e temp = new TreeMap\u003c\u003e();\n            temp.put(timestamp, value);\n            this.cache.put(key, temp);\n        }\n    }\n​\n    public String get(String key, int timestamp) {\n        if (this.cache.containsKey(key)) {\n            TreeMap\u003cInteger, String\u003e availableKeys = this.cache.get(key);\n            Map.Entry\u003cInteger, String\u003e val = availableKeys.floorEntry(timestamp);\n            return val == null ? \"\" : val.getValue();\n        }\n​\n        return \"\";\n    }\n}\n"}]}